{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importUrlForm: {\n        url: '',\n        isChecking: false,\n        isAccessible: null\n      },\n      importRules: {\n        url: [{\n          required: true,\n          message: '请输入URL地址',\n          trigger: 'blur'\n        }, {\n          type: 'url',\n          message: '请输入正确的URL地址',\n          trigger: ['blur', 'change']\n        }],\n        group: [{\n          required: true,\n          message: '请选择分组',\n          trigger: 'change'\n        }]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        urlStatus: {},\n        // 添加urlStatus对象\n        autoCollect: false,\n        collectType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1',\n        mode: 'tv'\n      },\n      collectRules: {\n        urls: [{\n          type: 'array',\n          validator: (rule, value, callback) => {\n            if (value.length === 0) {\n              callback(new Error('请至少添加一个采集地址'));\n            }\n            // 验证每个URL\n            const errors = value.map(url => {\n              if (!url) return '采集地址不能为空';\n              if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址';\n              return null;\n            }).filter(error => error !== null);\n            if (errors.length > 0) {\n              callback(new Error(errors[0]));\n            } else {\n              callback();\n            }\n          },\n          trigger: 'change'\n        }],\n        executeTime: [{\n          required: true,\n          message: '请选择执行时间',\n          trigger: 'change'\n        }],\n        weekDay: [{\n          required: true,\n          message: '请选择执行日期',\n          trigger: 'change'\n        }]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',\n      // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        scheduleType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      scheduleRules: {\n        executeTime: [{\n          required: true,\n          message: '请选择执行时间',\n          trigger: 'change'\n        }],\n        weekDay: [{\n          required: true,\n          message: '请选择执行日期',\n          trigger: 'change'\n        }]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState',\n      // 用于本地存储的key\n      hasActiveOperations: false,\n      // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      },\n      searchDialogVisible: false,\n      searchForm: {\n        name: '',\n        group: '',\n        status: ''\n      },\n      filteredList: [],\n      // 用于存储搜索过滤后的列表\n      realIp: '',\n      // 存储真实IP地址\n      syncDialogVisible: false,\n      syncForm: {\n        token: localStorage.getItem('githubToken') || '',\n        repo: localStorage.getItem('githubRepo') || '',\n        txtPath: localStorage.getItem('githubTxtPath') || '',\n        m3uPath: localStorage.getItem('githubM3uPath') || '',\n        autoSync: localStorage.getItem('githubAutoSync') === 'true',\n        syncType: localStorage.getItem('githubSyncType') || 'daily',\n        executeTime: localStorage.getItem('githubExecuteTime') || '00:00',\n        weekDay: localStorage.getItem('githubWeekDay') || '1',\n        message: '更新直播源列表'\n      },\n      syncRules: {\n        token: [{\n          required: true,\n          message: '请输入GitHub Token',\n          trigger: 'blur'\n        }],\n        repo: [{\n          required: true,\n          message: '请输入仓库名称',\n          trigger: 'blur'\n        }, {\n          pattern: /^[\\w-]+\\/[\\w-]+$/,\n          message: '格式：用户名/仓库名',\n          trigger: 'blur'\n        }],\n        txtPath: [{\n          required: true,\n          message: '请输入文件路径',\n          trigger: 'blur'\n        }],\n        m3uPath: [{\n          required: true,\n          message: '请输入文件路径',\n          trigger: 'blur'\n        }],\n        message: [{\n          required: true,\n          message: '请输入提交消息',\n          trigger: 'blur'\n        }]\n      },\n      syncTimer: null,\n      messages: [],\n      // 用于存储消息\n      messageId: 0,\n      // 用于生成唯一的消息ID\n      isPageSwitching: false,\n      // 添加页面切换标志\n      // 添加标准分组名称常量\n      STANDARD_GROUPS: {\n        CCTV: '央视频道',\n        SATELLITE: '卫视频道'\n      }\n    };\n  },\n  computed: {\n    paginatedData() {\n      // 使用过滤后的列表进行分页\n      const start = (this.currentPage - 1) * this.pageSize;\n      const end = start + this.pageSize;\n      return (this.filteredList.length > 0 ? this.filteredList : this.streamList).slice(start, end);\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测';\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`;\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map();\n\n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name; // 使用名称作为键\n\n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key);\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url);\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          });\n        }\n      });\n\n      // 转换回数组格式\n      return Array.from(streamMap.values());\n    },\n    groupOptions() {\n      return [...new Set(this.streamList.map(item => item.group))];\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList');\n      if (savedList) {\n        this.streamList = JSON.parse(savedList);\n        // 初始化时检查多播源\n        this.$nextTick(() => {\n          this.checkMulticastStreams(); // 使用新方法\n        });\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList);\n\n    // 监听设置更新事件\n    this.$root.$on('settings-updated', this.handleSettingsUpdate);\n\n    // 从本地存储恢复状态\n    this.restoreState();\n\n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true); // true表示是恢复状态\n    }\n    // 如果GitHub自动同步是开启状态，重新启动同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule();\n    }\n    this.filteredList = [];\n    this.getRealIp(); // 获取真实IP地址\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList);\n    this.$root.$off('settings-updated', this.handleSettingsUpdate);\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck();\n    // 在组件销毁前保存状态\n    this.saveState();\n    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n  },\n  methods: {\n    // 添加处理设置更新的方法\n    handleSettingsUpdate(event) {\n      console.log('收到设置更新事件:', event);\n      if (event && event.type === 'settings-changed' && event.settings) {\n        console.log('设置已更新，当前设置:', event.settings);\n        // 重新检查所有多播源\n        this.$nextTick(() => {\n          this.checkMulticastStreams();\n        });\n      }\n    },\n    // 添加多播源检测的辅助方法\n    isMulticastStream(url) {\n      if (!url) return false;\n\n      // 更完整的多播源检测正则表达式\n      const patterns = [\n      // 标准格式\n      /[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // 带@的格式\n      /^(udp|rtp):\\/\\/@239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/@225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/@224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // 不带@的格式\n      /^(udp|rtp):\\/\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // IPv6格式\n      /^(udp|rtp):\\/\\/\\[239\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i, /^(udp|rtp):\\/\\/\\[225\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i, /^(udp|rtp):\\/\\/\\[224\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i,\n      // 其他常见格式\n      /^(udp|rtp):\\/\\/@?239\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i, /^(udp|rtp):\\/\\/@?225\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i, /^(udp|rtp):\\/\\/@?224\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i,\n      // 简单格式\n      /^udp\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^rtp\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^udp\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^rtp\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^udp\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^rtp\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // 带端口的格式\n      /^(udp|rtp):\\/\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /^(udp|rtp):\\/\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // 特殊格式\n      /^(udp|rtp)[/](239|225|224)\\.\\d+\\.\\d+\\.\\d+[/]?(\\d+)?/i, /^(udp|rtp):\\/\\/(239|225|224)\\.\\d+\\.\\d+\\.\\d+[/]?(\\d+)?/i,\n      // HTTP代理的UDP/RTP多播源格式\n      /http:\\/\\/[^/]+[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /http:\\/\\/[^/]+[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /http:\\/\\/[^/]+[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // HTTPS代理的UDP/RTP多播源格式\n      /https:\\/\\/[^/]+[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /https:\\/\\/[^/]+[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i, /https:\\/\\/[^/]+[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n      // 任何包含 udp 或 rtp 的链接\n      /^(udp|rtp):\\/\\//i, /\\/(udp|rtp)\\//i, /^(udp|rtp)@/i];\n\n      // 先转换为小写进行检查\n      const lowerUrl = url.toLowerCase();\n      const isMulticast = patterns.some(pattern => pattern.test(lowerUrl));\n      if (isMulticast) {\n        console.log('检测到多播源:', url);\n      }\n      return isMulticast;\n    },\n    // 检查多播源的方法\n    checkMulticastStreams() {\n      try {\n        // 从localStorage直接获取autoRemoveMulticast设置\n        const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true';\n        console.log('自动清除多播源设置状态:', autoRemoveMulticast);\n\n        // 只有在设置为true时才执行清除\n        if (autoRemoveMulticast) {\n          console.log('开始检查多播源...');\n          let removedCount = 0;\n          const toRemove = [];\n\n          // 检查所有流\n          this.streamList.forEach((stream, index) => {\n            if (this.isMulticastStream(stream.url)) {\n              toRemove.push(index);\n              removedCount++;\n              console.log('发现多播源:', stream.url);\n            }\n          });\n\n          // 从后向前删除\n          for (let i = toRemove.length - 1; i >= 0; i--) {\n            const index = toRemove[i];\n            const stream = this.streamList[index];\n            console.log('正在删除多播源:', stream.name, stream.url);\n            this.streamList.splice(index, 1);\n            this.handleStreamRemoval(stream, '多播源');\n          }\n          if (removedCount > 0) {\n            console.log(`成功清除 ${removedCount} 个多播源`);\n            this.$message.warning(`已自动清除 ${removedCount} 个多播源`);\n            this.saveStreamList();\n\n            // 如果当前页没有数据，跳转到上一页\n            if (this.paginatedData.length === 0 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n          }\n        } else {\n          console.log('自动清除多播源功能未开启，跳过检查');\n        }\n      } catch (error) {\n        console.error('检查多播源失败:', error);\n      }\n    },\n    async checkStream(stream) {\n      // 优先从 appSettings 中读取 FFprobe 路径\n      let ffprobePath = '';\n      try {\n        const appSettings = localStorage.getItem('appSettings');\n        if (appSettings) {\n          const settings = JSON.parse(appSettings);\n          ffprobePath = settings.ffprobePath;\n        }\n      } catch (error) {\n        console.error('读取 appSettings 失败:', error);\n      }\n\n      // 如果 appSettings 中没有，则从独立设置中读取\n      if (!ffprobePath) {\n        ffprobePath = localStorage.getItem('ffprobePath');\n      }\n      if (!ffprobePath) {\n        console.error('未找到 FFprobe 路径配置');\n        this.$message.error('请先在系统设置中配置FFprobe路径');\n        return false;\n      }\n\n      // 检查是否是多播源\n      if (this.isMulticastStream(stream.url)) {\n        // 直接返回false，不再设置状态\n        return false;\n      }\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n\n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常';\n        stream.resolution = result.resolution || '-';\n        stream.responseTime = result.responseTime || '-';\n\n        // 检查是否需要自动清除\n        if (!result.available || this.shouldRemoveStream(stream)) {\n          let reason = '';\n          if (!result.available || stream.status === '异常') {\n            reason = '异常源';\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢';\n          } else {\n            reason = '分辨率过低';\n          }\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            this.handleStreamRemoval(stream, reason);\n          }\n        }\n        this.saveStreamList();\n        return result.available;\n      } catch (error) {\n        console.error('检测错误:', error);\n        stream.status = '异常';\n\n        // 如果设置了自动清除异常源，在这里也进行清除\n        if (this.shouldRemoveStream(stream)) {\n          const currentPageItems = this.paginatedData;\n          const pageIndex = currentPageItems.indexOf(stream);\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n            console.log(`清除异常直播源: ${stream.name}, 原因: 检测失败`);\n            this.$message.warning('已自动清除直播源：检测失败');\n          }\n        }\n        this.saveStreamList();\n        return false;\n      }\n    },\n    shouldRemoveStream(stream) {\n      try {\n        // 获取设置\n        const appSettings = localStorage.getItem('appSettings');\n        let settings = {};\n        if (appSettings) {\n          settings = JSON.parse(appSettings);\n        }\n\n        // 检查是否需要清除异常源\n        if (settings.autoRemoveInvalid === true && (stream.status === '异常' || stream.status === '未知')) {\n          console.log(`应清除异常源: ${stream.name}, 状态: ${stream.status}`);\n          return true;\n        }\n\n        // 获取模式设置\n        const extremeMode = settings.extremeMode === true;\n        const strictMode = settings.strictMode === true;\n\n        // 检查是否需要清除低分辨率源\n        if (settings.autoRemoveLowRes === true && stream.resolution !== '未知' && stream.resolution !== '多播源' && stream.resolution !== '-') {\n          const [width, height] = stream.resolution.split('x').map(Number);\n          if (extremeMode ? width < 1920 || height < 1080 : strictMode ? width < 1920 || height < 1080 : width < 1280 || height < 720) {\n            console.log(`应清除低分辨率源: ${stream.name}, 分辨率: ${stream.resolution}`);\n            return true;\n          }\n        }\n\n        // 检查响应时间\n        if (settings.autoRemoveSlowResponse === true && stream.responseTime !== '-' && Number(stream.responseTime) > (extremeMode ? 1500 : strictMode ? 2000 : 3000)) {\n          console.log(`应清除慢速源: ${stream.name}, 响应时间: ${stream.responseTime}ms`);\n          return true;\n        }\n        return false;\n      } catch (error) {\n        console.error('检查是否应该移除流时出错:', error);\n        return false;\n      }\n    },\n    async handleBatchCheck() {\n      if (this.isChecking) return;\n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex);\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源');\n        return;\n      }\n      this.isChecking = true;\n      this.shouldStop = false;\n      this.totalCount = uncheckedStreams.length;\n      this.checkedCount = this.isPaused ? this.checkedCount : 0;\n      try {\n        // 获取并发检测数量设置\n        const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3;\n\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0;\n\n        // 分批处理，每批次处理固定数量的流\n        const batchSize = Math.min(concurrentChecks, 10); // 限制最大并发数\n\n        for (let i = startIndex; i < uncheckedStreams.length; i += batchSize) {\n          if (this.shouldStop) break;\n\n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + batchSize);\n\n          // 并发检测当前批次的所有流\n          await Promise.all(batch.map(async stream => {\n            if (this.shouldStop) return;\n            try {\n              stream.status = '检测中';\n              const success = await this.checkStream(stream);\n              this.checkedCount++;\n              if (success) {\n                this.saveState();\n              }\n            } catch (error) {\n              console.error('检测流失败:', error);\n              stream.status = '异常';\n              this.checkedCount++;\n            }\n          }));\n\n          // 更新暂停位置\n          this.pausedIndex = i + batchSize - 1;\n\n          // 每批次完成后保存状态\n          this.saveState();\n        }\n        if (!this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = false;\n          this.pausedIndex = -1;\n          this.$message.success('批量检测完成');\n\n          // 检查是否需要在批量检测完成后同步\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath);\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath);\n            this.$message.success('已同步到GitHub');\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error);\n        this.$message.error('批量检测失败');\n      } finally {\n        if (this.shouldStop && this.streamList.length > 0) {\n          this.isChecking = false;\n          this.isPaused = true;\n          this.$message.info('检测已暂停');\n        } else {\n          this.isChecking = false;\n          this.isPaused = false;\n          this.pausedIndex = -1;\n        }\n      }\n    },\n    pauseCheck() {\n      this.shouldStop = true;\n    },\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true;\n        this.isPaused = false;\n        this.shouldStop = false;\n        await this.batchCheck(this.pausedIndex);\n      }\n    },\n    async handleCheck(row) {\n      row.status = '检测中';\n      const success = await this.checkStream(row);\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`);\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row);\n        this.streamList.splice(index, 1);\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('删除成功');\n      }).catch(() => {});\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate();\n      if (!valid) return;\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importForm.url\n          })\n        });\n        if (!response.ok) throw new Error('导入失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n            this.importUrlDialogVisible = false;\n\n            // 导入后立即检查多播源\n            this.$nextTick(() => {\n              this.checkMulticastStreams();\n            });\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message);\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      const streams = [];\n      let currentGroup = '未分组';\n      let currentName = '';\n\n      // 获取自动清除多播源设置\n      const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true';\n      console.log('解析内容时的自动清除多播源设置状态:', autoRemoveMulticast);\n\n      // 清理HTML标签\n      content = content.replace(/<[^>]*>/g, '');\n\n      // 按行分割内容\n      const lines = content.split('\\n');\n      lines.forEach(line => {\n        line = line.trim();\n        if (!line) return;\n\n        // 处理M3U格式\n        if (line.startsWith('#EXTINF:-1')) {\n          // 提取tvg-name属性\n          const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/);\n          if (tvgNameMatch) {\n            currentName = tvgNameMatch[1].trim();\n          } else {\n            // 如果没有tvg-name，尝试提取最后的逗号后的名称\n            const lastCommaIndex = line.lastIndexOf(',');\n            if (lastCommaIndex !== -1) {\n              currentName = line.substring(lastCommaIndex + 1).trim();\n            }\n          }\n          return;\n        }\n\n        // 处理普通分组标记\n        if (line.endsWith(',#genre#')) {\n          currentGroup = line.slice(0, -8);\n          return;\n        }\n\n        // 如果是URL行（不以#开头）\n        if (!line.startsWith('#')) {\n          let name = currentName || '';\n          let urls = [];\n\n          // 处理普通格式（名称,URL）\n          if (line.includes(',')) {\n            const parts = line.split(',');\n            name = name || parts[0].trim();\n            // 清理URL中的HTML标签\n            urls = parts.slice(1).join(',').split('#').map(url => url.replace(/<[^>]*>/g, ''));\n          } else {\n            // 处理纯URL格式，清理HTML标签\n            urls = [line.replace(/<[^>]*>/g, '')];\n          }\n          if (name && urls.length > 0) {\n            // 确定分组\n            let group = currentGroup;\n            // 处理卫视频道\n            if (/卫视/.test(name)) {\n              group = this.STANDARD_GROUPS.SATELLITE;\n            }\n            // 处理CCTV频道（不区分大小写）\n            else if (/CCTV/i.test(name)) {\n              group = this.STANDARD_GROUPS.CCTV;\n            }\n\n            // 添加所有有效的URL\n            urls.forEach(url => {\n              url = url.trim();\n              // 验证URL格式，只有在autoRemoveMulticast为false时才添加多播源\n              if (url && (!autoRemoveMulticast && this.isMulticastStream(url) || !this.isMulticastStream(url)) && this.isValidUrl(url)) {\n                streams.push({\n                  name: name,\n                  url: url,\n                  group: group,\n                  status: '未检测',\n                  resolution: '-',\n                  responseTime: '-'\n                });\n              }\n            });\n          }\n          currentName = ''; // 重置当前名称\n        }\n      });\n\n      // 最后再次检查所有流的分组\n      streams.forEach(stream => {\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV;\n        } else if (/卫视/.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.SATELLITE;\n        }\n      });\n      console.log(`解析完成: 共发现 ${streams.length} 个有效直播源`);\n      return streams;\n    },\n    // 添加URL验证方法\n    isValidUrl(url) {\n      try {\n        // 移除HTML标签\n        url = url.replace(/<[^>]*>/g, '');\n        // 检查是否是有效的URL格式\n        return url.startsWith('http://') || url.startsWith('https://') || url.startsWith('rtmp://') || url.startsWith('rtsp://');\n      } catch (e) {\n        return false;\n      }\n    },\n    addStreamsToList(streams) {\n      // 标准化所有流的分组名称\n      streams.forEach(stream => {\n        // 优先根据名称判断分组，不区分大小写\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV;\n        } else if (/卫视/.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.SATELLITE;\n        }\n      });\n\n      // 检查重复并添加到列表\n      const existingStreams = new Set(this.streamList.map(s => `${s.url}|${s.group}`));\n      const uniqueStreams = streams.filter(stream => {\n        const key = `${stream.url}|${stream.group}`;\n        if (existingStreams.has(key)) {\n          return false;\n        }\n        existingStreams.add(key);\n        return true;\n      });\n\n      // 添加到列表前再次确认CCTV频道分组\n      uniqueStreams.forEach(stream => {\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV;\n        }\n      });\n      this.streamList.push(...uniqueStreams);\n      this.currentPage = 1;\n      this.saveStreamList();\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源（同时考虑URL和分组）\n          const existingKeys = new Set(this.streamList.map(s => `${s.url}|${s.group}`));\n          const uniqueStreams = newStreams.filter(s => {\n            const key = `${s.url}|${s.group}`;\n            if (existingKeys.has(key)) {\n              return false;\n            }\n            existingKeys.add(key);\n            return true;\n          });\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n\n            // 只有在设置开启时才检查多播源\n            const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true';\n            if (autoRemoveMulticast) {\n              this.$nextTick(() => {\n                this.checkMulticastStreams();\n              });\n            }\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (/cctv/i.test(name)) return this.STANDARD_GROUPS.CCTV;\n      if (name.includes('卫视')) return this.STANDARD_GROUPS.SATELLITE;\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      this.$confirm('确认清空列表吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 先停止所有检测和采集任务\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n        this.pausedIndex = -1;\n\n        // 清除所有定时器\n        if (this.collectTimer) {\n          clearInterval(this.collectTimer);\n          this.collectTimer = null;\n        }\n        if (this.scheduleTimer) {\n          clearInterval(this.scheduleTimer);\n          this.scheduleTimer = null;\n        }\n        if (this.syncTimer) {\n          clearInterval(this.syncTimer);\n          this.syncTimer = null;\n        }\n\n        // 重置所有状态\n        this.isCollecting = false;\n        this.isScheduled = false;\n        this.checkedCount = 0;\n        this.totalCount = 0;\n\n        // 清空列表和重置页码\n        this.streamList = [];\n        this.currentPage = 1;\n\n        // 更新链接内容和保存状态\n        this.updateLinkContent();\n        this.saveState();\n        this.$message({\n          type: 'success',\n          message: '列表已清空'\n        });\n      }).catch(() => {\n        this.$message({\n          type: 'info',\n          message: '已取消清空'\n        });\n      });\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', ['']);\n          return;\n        }\n\n        // 检查所有URL是否可访问\n        const hasInvalidUrls = Object.values(this.collectForm.urlStatus || {}).some(status => status && status.isAccessible === false);\n        if (hasInvalidUrls) {\n          this.$message.error('存在无法访问的链接，请检查后重试');\n          return;\n        }\n\n        // 检查是否有正在检测的URL\n        const hasCheckingUrls = Object.values(this.collectForm.urlStatus || {}).some(status => status && status.isChecking);\n        if (hasCheckingUrls) {\n          this.$message.warning('有链接正在检测中，请等待检测完成');\n          return;\n        }\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState(); // 保存状态\n\n      // 立即执行一次采集\n      await this.collect();\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule();\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false;\n        this.saveState();\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集');\n      }\n    },\n    async collect() {\n      let progressMessage = null;\n      try {\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集');\n          return;\n        }\n        const total = this.collectForm.urls.length;\n        if (total === 0) {\n          this.$message.warning('没有需要采集的地址');\n          return;\n        }\n\n        // 创建进度消息提示\n        progressMessage = this.$message({\n          message: `正在采集: 0/${total}`,\n          type: 'info',\n          duration: 0,\n          // 消息不会自动关闭\n          showClose: false\n        });\n\n        // 将URL列表分批处理，每批最多5个\n        const batchSize = 5;\n        const urlBatches = [];\n        for (let i = 0; i < this.collectForm.urls.length; i += batchSize) {\n          urlBatches.push(this.collectForm.urls.slice(i, i + batchSize));\n        }\n        let allResults = [];\n        let current = 0;\n\n        // 处理每一批URL\n        for (const batch of urlBatches) {\n          const batchPromises = batch.map(async url => {\n            try {\n              const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'text/plain'\n                }\n              });\n              if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n              }\n              const content = await response.text();\n              const newStreams = this.parseContent(content);\n\n              // 根据采集模式过滤直播源\n              let filteredStreams = newStreams;\n              if (this.collectForm.mode === 'tv') {\n                filteredStreams = newStreams.filter(s => {\n                  // 处理央视频道\n                  const isCCTV = /CCTV/i.test(s.name);\n                  if (isCCTV) {\n                    s.group = this.STANDARD_GROUPS.CCTV;\n                    const cctvNumber = this.extractCCTVNumber(s.name);\n                    if (cctvNumber) {\n                      s.name = cctvNumber;\n                    }\n                    return true;\n                  }\n                  // 处理卫视频道\n                  const isSatellite = /卫视/.test(s.name);\n                  if (isSatellite) {\n                    s.group = this.STANDARD_GROUPS.SATELLITE;\n                    return true;\n                  }\n                  return false;\n                });\n              }\n\n              // 再次确保所有CCTV频道都在正确分组\n              filteredStreams.forEach(s => {\n                if (/CCTV/i.test(s.name)) {\n                  s.group = this.STANDARD_GROUPS.CCTV;\n                }\n              });\n              current++;\n              // 更新进度消息\n              if (progressMessage) {\n                progressMessage.message = `正在采集: ${Math.min(current, total)}/${total}`;\n              }\n              return {\n                status: 'fulfilled',\n                value: filteredStreams\n              };\n            } catch (error) {\n              current++;\n              // 更新进度消息（即使失败也计入进度）\n              if (progressMessage) {\n                progressMessage.message = `正在采集: ${Math.min(current, total)}/${total}`;\n              }\n              console.error(`采集地址失败 ${url}:`, error);\n              return {\n                status: 'rejected',\n                reason: error\n              };\n            }\n          });\n          const batchResults = await Promise.all(batchPromises);\n          allResults = allResults.concat(batchResults);\n        }\n\n        // 合并所有采集结果\n        const allNewStreams = allResults.filter(result => result.status === 'fulfilled').flatMap(result => result.value).filter((stream, index, self) => index === self.findIndex(s => s.url === stream.url));\n\n        // 关闭进度消息\n        if (progressMessage) {\n          progressMessage.close();\n        }\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams);\n          const modeText = this.collectForm.mode === 'tv' ? '央视卫视' : '';\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个${modeText}直播源`);\n        } else {\n          const modeText = this.collectForm.mode === 'tv' ? '央视卫视' : '';\n          this.$message.info(`未发现新的${modeText}直播源`);\n        }\n\n        // 统计失败的地址\n        const failedUrls = allResults.filter(result => result.status === 'rejected').length;\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`);\n        }\n      } catch (error) {\n        console.error('采集失败:', error);\n        this.$message.error('采集失败：' + error.message);\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      } finally {\n        // 确保进度消息被关闭\n        if (progressMessage) {\n          progressMessage.close();\n        }\n      }\n    },\n    // 添加带重试机制的采集方法\n    async collectWithRetry(url, maxRetries = 3) {\n      let lastError;\n      for (let i = 0; i < maxRetries; i++) {\n        try {\n          const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n            method: 'GET',\n            headers: {\n              'Accept': 'text/plain'\n            }\n          });\n          if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n          }\n          const content = await response.text();\n          const newStreams = this.parseContent(content);\n\n          // 根据采集模式过滤直播源\n          let filteredStreams = newStreams;\n          if (this.collectForm.mode === 'tv') {\n            filteredStreams = newStreams.filter(s => {\n              // 处理央视频道\n              const isCCTV = /CCTV/i.test(s.name);\n              if (isCCTV) {\n                s.group = this.STANDARD_GROUPS.CCTV;\n                const cctvNumber = this.extractCCTVNumber(s.name);\n                if (cctvNumber) {\n                  s.name = cctvNumber;\n                }\n                return true;\n              }\n              // 处理卫视频道\n              const isSatellite = /卫视/.test(s.name);\n              if (isSatellite) {\n                s.group = this.STANDARD_GROUPS.SATELLITE;\n                return true;\n              }\n              return false;\n            });\n          }\n\n          // 再次确保所有CCTV频道都在正确分组\n          filteredStreams.forEach(s => {\n            if (/CCTV/i.test(s.name)) {\n              s.group = this.STANDARD_GROUPS.CCTV;\n            }\n          });\n          return filteredStreams;\n        } catch (error) {\n          lastError = error;\n          console.warn(`采集地址 ${url} 第 ${i + 1} 次尝试失败:`, error);\n          if (i < maxRetries - 1) {\n            continue; // 直接进行下一次重试，不等待\n          }\n        }\n      }\n\n      // 所有重试都失败后抛出最后一次的错误\n      throw new Error(`采集失败 [${url}]: ${lastError.message}`);\n    },\n    // 修改提取CCTV频道号的方法\n    extractCCTVNumber(name) {\n      // 尝试直接匹配CCTV+数字的形式\n      const cctvMatch = name.match(/CCTV-?(\\d+)(\\+)?/i);\n      if (cctvMatch) {\n        const number = cctvMatch[1];\n        const plus = cctvMatch[2] || '';\n        return `CCTV${number}${plus}`;\n      }\n\n      // 处理特殊频道名称（如CCTV5+）\n      if (/CCTV5\\+|CCTV5Plus|体育赛事/.test(name)) {\n        return 'CCTV5+';\n      }\n\n      // 如果无法提取频道号，保留原始CCTV名称\n      const cctvNameMatch = name.match(/CCTV[^a-z0-9]*([a-z0-9]+)/i);\n      if (cctvNameMatch) {\n        return `CCTV${cctvNameMatch[1]}`;\n      }\n\n      // 如果都无法匹配，返回原始名称\n      return name;\n    },\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true;\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text();\n          const m3uLink = await m3uResponse.text();\n\n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          };\n          this.generatedLink = this.generatedLinks[this.linkForm.format];\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error);\n        this.$message.error('生成链接失败');\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent();\n    },\n    // 添加自定义排序方法\n    customSort(streams, group) {\n      return streams.sort((a, b) => {\n        if (group === this.STANDARD_GROUPS.CCTV) {\n          // 提取CCTV频道号进行排序\n          const getNumber = name => {\n            const match = name.match(/CCTV-?(\\d+)(\\+)?/i);\n            if (match) {\n              return parseInt(match[1]) + (match[2] ? 0.5 : 0); // CCTV5+ 会排在 CCTV5 后面\n            }\n            // 特殊处理CCTV5+\n            if (/CCTV5\\+|CCTV5Plus|体育赛事/.test(name)) {\n              return 5.5;\n            }\n            return 999; // 无法识别的排在最后\n          };\n          const numA = getNumber(a.name);\n          const numB = getNumber(b.name);\n          return numA - numB;\n        } else if (group === this.STANDARD_GROUPS.SATELLITE) {\n          // 卫视按照拼音首字母排序\n          return a.name.localeCompare(b.name, 'zh-CN');\n        } else {\n          // 其他分组按照默认排序\n          return a.name.localeCompare(b.name);\n        }\n      });\n    },\n    generateTxtContent() {\n      let content = '';\n      const groupedStreams = {};\n\n      // 首先整理所有流到对应的分组\n      this.mergedStreams.forEach(stream => {\n        const group = stream.group || '未分组';\n        if (!groupedStreams[group]) {\n          groupedStreams[group] = [];\n        }\n        groupedStreams[group].push(stream);\n      });\n\n      // 优先处理央视和卫视分组\n      const orderedGroups = [this.STANDARD_GROUPS.CCTV, this.STANDARD_GROUPS.SATELLITE, ...Object.keys(groupedStreams).filter(group => group !== this.STANDARD_GROUPS.CCTV && group !== this.STANDARD_GROUPS.SATELLITE)];\n\n      // 按分组生成内容\n      orderedGroups.forEach(group => {\n        if (groupedStreams[group] && groupedStreams[group].length > 0) {\n          content += `${group},#genre#\\n`;\n          // 使用自定义排序方法\n          this.customSort(groupedStreams[group], group).forEach(stream => {\n            content += `${stream.name},${stream.urls.join('#')}\\n`;\n          });\n        }\n      });\n      return content.trim();\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n';\n      const groupedStreams = {};\n\n      // 首先整理所有流到对应的分组\n      this.mergedStreams.forEach(stream => {\n        const group = stream.group || '未分组';\n        if (!groupedStreams[group]) {\n          groupedStreams[group] = [];\n        }\n        groupedStreams[group].push(stream);\n      });\n\n      // 优先处理央视和卫视分组\n      const orderedGroups = [this.STANDARD_GROUPS.CCTV, this.STANDARD_GROUPS.SATELLITE, ...Object.keys(groupedStreams).filter(group => group !== this.STANDARD_GROUPS.CCTV && group !== this.STANDARD_GROUPS.SATELLITE)];\n\n      // 按分组生成内容\n      orderedGroups.forEach(group => {\n        if (groupedStreams[group] && groupedStreams[group].length > 0) {\n          // 使用自定义排序方法\n          this.customSort(groupedStreams[group], group).forEach(stream => {\n            stream.urls.forEach(url => {\n              content += `#EXTINF:-1 group-title=\"${group}\",${stream.name}\\n${url}\\n`;\n            });\n          });\n        }\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n      const calculateNextExecutionTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime;\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck();\n          }\n          // 设置下一次执行\n          scheduleNextExecution();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextExecution();\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 清除旧的分块数据\n        this.clearStorageData();\n\n        // 只保存必要的数据字段，减少数据量\n        const minimalStreamList = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution || '',\n          responseTime: stream.responseTime || 0\n        }));\n\n        // 将streamList分块存储，减小分块大小\n        const streamListStr = JSON.stringify(minimalStreamList);\n        const chunkSize = 100000; // 减小到100KB\n        const chunks = Math.ceil(streamListStr.length / chunkSize);\n\n        // 如果数据量太大，只保存基本信息\n        if (chunks > 10) {\n          console.warn('数据量过大，只保存基本状态信息');\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize,\n            scheduleForm: this.scheduleForm,\n            collectForm: this.collectForm\n          };\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n          return;\n        }\n\n        // 分块存储\n        for (let i = 0; i < chunks; i++) {\n          const chunk = streamListStr.slice(i * chunkSize, (i + 1) * chunkSize);\n          try {\n            localStorage.setItem(`${this.stateKey}_streamList_${i}`, chunk);\n          } catch (e) {\n            console.error('存储分块失败:', e);\n            this.clearStorageData();\n            // 尝试只保存基本信息\n            const basicState = {\n              currentPage: this.currentPage,\n              pageSize: this.pageSize,\n              scheduleForm: this.scheduleForm,\n              collectForm: this.collectForm\n            };\n            localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n            return;\n          }\n        }\n\n        // 存储其他状态数据\n        const state = {\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm,\n          streamListChunks: chunks\n        };\n        localStorage.setItem(this.stateKey, JSON.stringify(state));\n      } catch (error) {\n        console.error('保存状态失败:', error);\n        this.clearStorageData();\n        // 尝试只保存基本信息\n        try {\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize\n          };\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n        } catch (e) {\n          console.error('保存基本状态也失败:', e);\n        }\n      }\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 恢复streamList\n          if (state.streamListChunks) {\n            try {\n              let streamListStr = '';\n              for (let i = 0; i < state.streamListChunks; i++) {\n                const chunk = localStorage.getItem(`${this.stateKey}_streamList_${i}`);\n                if (chunk) {\n                  streamListStr += chunk;\n                }\n              }\n              if (streamListStr) {\n                this.streamList = JSON.parse(streamListStr);\n              }\n            } catch (e) {\n              console.error('恢复streamList失败:', e);\n              this.streamList = [];\n            }\n          }\n\n          // 恢复其他状态\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          if (state.scheduleForm) this.scheduleForm = state.scheduleForm;\n          if (state.collectForm) this.collectForm = state.collectForm;\n        }\n\n        // 重置所有运行状态\n        this.isChecking = false;\n        this.isPaused = false;\n        this.isScheduled = false;\n        this.isCollecting = false;\n        this.checkedCount = 0;\n        this.totalCount = 0;\n        this.pausedIndex = -1;\n        this.nextScheduleTime = null;\n      } catch (error) {\n        console.error('恢复状态失败:', error);\n        this.clearStorageData();\n        this.streamList = [];\n      }\n    },\n    // 清理存储数据\n    clearStorageData() {\n      try {\n        localStorage.removeItem(this.stateKey);\n        for (let i = 0;; i++) {\n          const key = `${this.stateKey}_streamList_${i}`;\n          if (localStorage.getItem(key) === null) {\n            break;\n          }\n          localStorage.removeItem(key);\n        }\n      } catch (error) {\n        console.error('清理存储数据失败:', error);\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    },\n    addCollectUrl() {\n      const newIndex = this.collectForm.urls.length;\n      this.collectForm.urls.push('');\n      // 初始化新URL的状态\n      this.$set(this.collectForm.urlStatus, newIndex, {\n        isChecking: false,\n        isAccessible: null\n      });\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1);\n\n        // 重新排序urlStatus\n        const newUrlStatus = {};\n        Object.keys(this.collectForm.urlStatus || {}).filter(key => parseInt(key) !== index).forEach((key, i) => {\n          newUrlStatus[i] = this.collectForm.urlStatus[key];\n        });\n        this.collectForm.urlStatus = newUrlStatus;\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '-') return 'info';\n      if (resolution === '多播源') return 'warning'; // 为多播源添加特殊样式\n      const [width] = resolution.split('x').map(Number);\n      if (width >= 1920) return 'success';\n      if (width >= 1280) return ''; // 默认类型\n      return 'warning';\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime || responseTime === '-') return 'info';\n      const time = Number(responseTime);\n      if (time <= 1000) return 'success';\n      if (time <= 2000) return ''; // 默认类型\n      if (time <= 3000) return 'warning';\n      return 'danger';\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n      }\n      const calculateNextCollectTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect();\n          // 设置下一次执行\n          scheduleNextCollection();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextCollection();\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        // 对CCTV频道进行精确匹配\n        if (this.searchForm.name && /^cctv\\d*$/i.test(this.searchForm.name)) {\n          const searchPattern = new RegExp(`^${this.searchForm.name}[\\\\s-]*$`, 'i');\n          const nameMatch = searchPattern.test(item.name.toLowerCase().replace(/[^a-z0-9]/gi, ''));\n          const groupMatch = !this.searchForm.group || item.group === this.searchForm.group;\n          const statusMatch = !this.searchForm.status || item.status === this.searchForm.status;\n          return nameMatch && groupMatch && statusMatch;\n        }\n\n        // 对其他搜索使用常规匹配\n        const nameMatch = !this.searchForm.name || item.name.toLowerCase().includes(this.searchForm.name.toLowerCase());\n        const groupMatch = !this.searchForm.group || item.group === this.searchForm.group;\n        const statusMatch = !this.searchForm.status || item.status === this.searchForm.status;\n        return nameMatch && groupMatch && statusMatch;\n      });\n\n      // 重置到第一页\n      this.currentPage = 1;\n      this.searchDialogVisible = false;\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      };\n      this.filteredList = [];\n      this.currentPage = 1;\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`);\n        if (response.ok) {\n          const data = await response.json();\n          this.realIp = data.ip;\n          localStorage.setItem('realIp', data.ip); // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error);\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      // 在生产环境中使用相对路径\n      if (process.env.NODE_ENV === 'production') {\n        return ''; // 返回空字符串，这样会使用相对路径\n      }\n      // 在开发环境中使用配置的服务器IP\n      const serverIp = localStorage.getItem('serverIp');\n      if (serverIp) {\n        return `http://${serverIp}:8080`;\n      }\n      return 'http://localhost:8080';\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate();\n\n        // 保存设置到localStorage\n        localStorage.setItem('githubToken', this.syncForm.token);\n        localStorage.setItem('githubRepo', this.syncForm.repo);\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath);\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath);\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync);\n        localStorage.setItem('githubSyncType', this.syncForm.syncType);\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime);\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay);\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule();\n        } else {\n          this.clearSyncSchedule();\n        }\n        this.$message.success('设置已保存');\n        this.syncDialogVisible = false;\n      } catch (error) {\n        this.$message.error(error.message || '保存失败');\n      }\n    },\n    async syncToGithub(content, path) {\n      try {\n        // 首先获取文件的SHA\n        const getResponse = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${path}`, {\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`\n          }\n        });\n        if (!getResponse.ok) {\n          throw new Error(`获取文件信息失败: ${getResponse.status} ${getResponse.statusText}`);\n        }\n        const fileInfo = await getResponse.json();\n        const sha = fileInfo.sha;\n\n        // 将内容转换为UTF-8编码的Base64\n        const base64Content = btoa(unescape(encodeURIComponent(content)));\n\n        // 更新文件内容\n        const updateResponse = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${path}`, {\n          method: 'PUT',\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            message: this.syncForm.message || '更新直播源列表',\n            content: base64Content,\n            sha: sha\n          })\n        });\n        if (!updateResponse.ok) {\n          throw new Error(`更新文件失败: ${updateResponse.status} ${updateResponse.statusText}`);\n        }\n        return await updateResponse.json();\n      } catch (error) {\n        console.error('同步到GitHub失败:', error);\n        throw new Error('同步失败: ' + error.message);\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule();\n      } else {\n        this.clearSyncSchedule();\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule();\n      const calculateNextSyncTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(async () => {\n          try {\n            // 执行同步\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath);\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath);\n            this.$message.success('已同步到GitHub');\n          } catch (error) {\n            this.$message.error('同步失败：' + error.message);\n          }\n          // 设置下一次执行\n          scheduleNextSync();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextSync();\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer);\n        this.syncTimer = null;\n      }\n    },\n    getStatusTagType(status) {\n      switch (status) {\n        case '正常':\n          return 'success';\n        case '异常':\n          return 'danger';\n        case '未知':\n          return 'warning';\n        case '未检测':\n          return 'info';\n        default:\n          return 'info';\n      }\n    },\n    // 修改显示消息的方法\n    showMessage(content) {\n      // 如果是清除直播源的消息，使用新的消息系统\n      if (content.includes('已自动清除直播源') || content.includes('(')) {\n        const id = this.messageId++;\n        const message = {\n          id,\n          content: content.includes('(') ? content : content.replace('已自动清除直播源：', '')\n        };\n        this.messages.push(message);\n\n        // 3秒后自动移除消息\n        setTimeout(() => {\n          this.removeMessage(id);\n        }, 3000);\n\n        // 最多显示3条消息\n        if (this.messages.length > 3) {\n          this.messages.shift();\n        }\n      } else {\n        // 其他消息使用 Element UI 的消息提示\n        this.$message.info(content);\n      }\n    },\n    // 移除消息\n    removeMessage(id) {\n      const index = this.messages.findIndex(msg => msg.id === id);\n      if (index !== -1) {\n        this.messages.splice(index, 1);\n      }\n    },\n    // 修改清除直播源的提示\n    handleStreamRemoval(stream, reason) {\n      this.showMessage(`${stream.name} (${reason})`);\n    },\n    async checkUrlAccessibility() {\n      if (!this.importUrlForm.url) return;\n      this.importUrlForm.isChecking = true;\n      this.importUrlForm.isAccessible = null;\n      try {\n        // 添加延迟，避免频繁请求\n        await new Promise(resolve => setTimeout(resolve, 500));\n        const baseUrl = process.env.VUE_APP_API_URL || ''; // 从环境变量获取API基础URL\n        const response = await fetch(`${baseUrl}/api/check-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importUrlForm.url\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n        this.importUrlForm.isAccessible = result.accessible;\n      } catch (error) {\n        console.error('检查链接可达性失败:', error);\n        this.importUrlForm.isAccessible = false;\n      } finally {\n        this.importUrlForm.isChecking = false;\n      }\n    },\n    async handleImportUrl() {\n      if (!this.importUrlForm.url) {\n        this.$message.warning('请输入文件链接');\n        return;\n      }\n\n      // 如果链接未经过检测或检测失败，先进行检测\n      if (this.importUrlForm.isAccessible === null || this.importUrlForm.isAccessible === false) {\n        await this.checkUrlAccessibility();\n        if (!this.importUrlForm.isAccessible) {\n          return;\n        }\n      }\n      try {\n        // 获取文件内容\n        const response = await fetch(this.importUrlForm.url);\n        if (!response.ok) throw new Error('获取文件失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 提取URL列表并过滤重复项\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            // 批量添加到列表\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n            this.importUrlDialogVisible = false;\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        console.error('导入失败:', error);\n        this.$message.error('导入失败: ' + error.message);\n      } finally {\n        this.importUrlForm.isChecking = false;\n      }\n    },\n    getPlaceholderText() {\n      switch (this.collectForm.mode) {\n        case 'tv':\n          return '请输入包含央视或卫视频道的网络地址';\n        default:\n          return '请输入需要采集的网络地址';\n      }\n    },\n    async handleCollectUrlsFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        // 按行分割并过滤空行\n        const urls = content.split('\\n').map(line => line.trim()).filter(line => line && line.length > 0);\n        if (urls.length === 0) {\n          this.$message.warning('文件中未找到有效的URL地址');\n          return;\n        }\n\n        // 验证URL格式\n        const invalidUrls = urls.filter(url => !/^https?:\\/\\/.+/.test(url));\n        if (invalidUrls.length > 0) {\n          this.$message.warning(`发现 ${invalidUrls.length} 个无效的URL地址`);\n          return;\n        }\n\n        // 初始化状态对象\n        const urlStatus = {};\n        urls.forEach((_, index) => {\n          urlStatus[index] = {\n            isChecking: false,\n            isAccessible: null\n          };\n        });\n\n        // 使用Vue的响应式更新\n        this.$set(this.collectForm, 'urls', urls);\n        this.$set(this.collectForm, 'urlStatus', urlStatus);\n\n        // 手动触发每个URL的检测\n        this.$nextTick(() => {\n          urls.forEach((url, index) => {\n            this.checkCollectUrlAccessibility(url, index);\n          });\n        });\n        this.$message.success(`成功导入 ${urls.length} 个采集地址`);\n      } catch (error) {\n        this.$message.error('读取文件失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    async checkCollectUrlAccessibility(url, index) {\n      if (!url) {\n        console.warn('URL为空，跳过检测');\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: null,\n          error: '地址为空'\n        });\n        return;\n      }\n\n      // 标准化URL格式\n      let normalizedUrl = url;\n      if (!url.toLowerCase().startsWith('http')) {\n        normalizedUrl = 'http://' + url;\n      }\n      console.log(`开始检测URL (${index}):`, normalizedUrl);\n\n      // 设置检查状态\n      this.$set(this.collectForm.urlStatus, index, {\n        isChecking: true,\n        isAccessible: null,\n        error: null\n      });\n      try {\n        // 添加延迟，避免频繁请求\n        await new Promise(resolve => setTimeout(resolve, 500));\n        const response = await fetch(`${this.getBaseUrl()}/api/check-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: normalizedUrl\n          })\n        });\n        if (!response.ok) {\n          throw new Error(`HTTP错误: ${response.status}`);\n        }\n        const result = await response.json();\n        console.log(`URL (${index}) 检测结果:`, result);\n\n        // 更新状态\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: result.accessible,\n          statusCode: result.statusCode,\n          error: result.error\n        });\n\n        // 如果检测失败，记录错误信息\n        if (!result.accessible) {\n          console.warn(`URL (${index}) 不可访问:`, result.error || '未知错误');\n        }\n      } catch (error) {\n        console.error(`URL (${index}) 检测失败:`, error);\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: false,\n          error: error.message || '检测失败'\n        });\n      }\n    },\n    clearCollectUrls() {\n      this.$confirm('确认清空所有采集地址吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 重置采集地址列表\n        this.$set(this.collectForm, 'urls', ['']);\n        // 重置状态对象\n        this.$set(this.collectForm, 'urlStatus', {\n          0: {\n            isChecking: false,\n            isAccessible: null\n          }\n        });\n        this.$message.success('已清空采集地址');\n      }).catch(() => {\n        // 用户取消操作\n      });\n    },\n    async importFromGithub() {\n      if (!this.syncForm.token || !this.syncForm.repo || !this.syncForm.txtPath) {\n        this.$message.warning('请先配置GitHub同步设置');\n        return;\n      }\n      this.$message.info('正在从GitHub导入...');\n      try {\n        // 使用GitHub API获取文件内容\n        const response = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${this.syncForm.txtPath}`, {\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`,\n            'Accept': 'application/vnd.github.v3.raw'\n          }\n        });\n        if (!response.ok) {\n          throw new Error(`GitHub API请求失败: ${response.status} ${response.statusText}`);\n        }\n        const content = await response.text();\n        if (!content) {\n          throw new Error('获取到的内容为空');\n        }\n\n        // 解析内容\n        const lines = content.split('\\n');\n        const newStreams = [];\n        let currentGroup = '未分组';\n        let currentStream = null;\n        for (const line of lines) {\n          const trimmedLine = line.trim();\n          if (!trimmedLine || trimmedLine.startsWith('#')) continue;\n          if (trimmedLine.startsWith('[')) {\n            // 这是一个分组\n            currentGroup = trimmedLine.replace(/[[\\]]/g, '').trim();\n          } else if (trimmedLine.includes(',')) {\n            // 这是一个直播源\n            const [name, url] = trimmedLine.split(',').map(s => s.trim());\n            if (name && url) {\n              currentStream = {\n                name,\n                url,\n                group: currentGroup,\n                status: '待检测',\n                resolution: '',\n                responseTime: 0,\n                lastCheck: '',\n                isSelected: false\n              };\n              newStreams.push(currentStream);\n            }\n          }\n        }\n        if (newStreams.length === 0) {\n          throw new Error('未找到有效的直播源');\n        }\n\n        // 更新列表\n        this.streamList = newStreams;\n        this.filteredList = [...newStreams];\n        this.currentPage = 1;\n        this.total = newStreams.length;\n\n        // 保存到localStorage\n        localStorage.setItem('streamList', JSON.stringify(newStreams));\n        localStorage.setItem('filteredList', JSON.stringify(newStreams));\n        this.$message.success(`成功导入 ${newStreams.length} 个直播源`);\n        this.importDialogVisible = false;\n      } catch (error) {\n        console.error('导入失败:', error);\n        this.$message.error('导入失败: ' + error.message);\n      }\n    },\n    async checkIpv6(stream) {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-ipv6`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n        if (result.success) {\n          stream.ipv6 = result.ipv6;\n          stream.ipv6Checked = true;\n        } else {\n          throw new Error(result.message);\n        }\n      } catch (error) {\n        console.error('检查IPv6失败:', error);\n        stream.ipv6Checked = true;\n        stream.ipv6 = false;\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink();\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，且不是从其他页面切换回来，才恢复采集\n    if (this.isCollecting && !this.isPageSwitching) {\n      this.startCollecting(true);\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule();\n    }\n    // 重置页面切换标志\n    this.isPageSwitching = false;\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 设置页面切换标志\n    this.isPageSwitching = true;\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","loading","streamList","importUrlDialogVisible","importUrlForm","url","isChecking","isAccessible","importRules","required","message","trigger","type","group","currentPage","pageSize","isPaused","checkedCount","totalCount","pausedIndex","shouldStop","isCollecting","collectDialogVisible","collectForm","urls","urlStatus","autoCollect","collectType","executeTime","weekDay","mode","collectRules","validator","rule","value","callback","length","Error","errors","map","test","filter","error","collectTimer","generateLinkDialogVisible","generatedLink","previewContent","currentLinkId","scheduleDialogVisible","isScheduled","scheduleForm","scheduleType","scheduleRules","scheduleTimer","nextScheduleTime","stateKey","hasActiveOperations","linkForm","format","searchDialogVisible","searchForm","status","filteredList","realIp","syncDialogVisible","syncForm","token","localStorage","getItem","repo","txtPath","m3uPath","autoSync","syncType","syncRules","pattern","syncTimer","messages","messageId","isPageSwitching","STANDARD_GROUPS","CCTV","SATELLITE","computed","paginatedData","start","end","slice","checkButtonText","mergedStreams","streamMap","Map","forEach","stream","key","has","existing","get","includes","push","set","Array","from","values","groupOptions","Set","item","created","savedList","JSON","parse","$nextTick","checkMulticastStreams","$root","$on","saveStreamList","handleSettingsUpdate","restoreState","setupSchedule","startCollecting","setupSyncSchedule","getRealIp","beforeDestroy","$off","clearInterval","stopScheduleCheck","saveState","window","removeEventListener","handleBeforeUnload","methods","event","console","log","settings","isMulticastStream","patterns","lowerUrl","toLowerCase","isMulticast","some","autoRemoveMulticast","removedCount","toRemove","index","i","splice","handleStreamRemoval","$message","warning","checkStream","ffprobePath","appSettings","response","fetch","getBaseUrl","method","headers","body","stringify","ok","result","json","available","resolution","responseTime","shouldRemoveStream","reason","listIndex","indexOf","currentPageItems","pageIndex","autoRemoveInvalid","extremeMode","strictMode","autoRemoveLowRes","width","height","split","Number","autoRemoveSlowResponse","handleBatchCheck","uncheckedStreams","s","info","concurrentChecks","parseInt","startIndex","batchSize","Math","min","batch","Promise","all","success","syncToGithub","generateContent","pauseCheck","resumeCheck","batchCheck","handleCheck","row","handleDelete","$confirm","confirmButtonText","cancelButtonText","then","maxPage","ceil","max","catch","handleUrlImport","valid","$refs","importForm","validate","content","text","newStreams","parseContent","existingUrls","uniqueStreams","readFile","file","resolve","reject","reader","FileReader","onload","e","target","onerror","readAsText","streams","currentGroup","currentName","replace","lines","line","trim","startsWith","tvgNameMatch","match","lastCommaIndex","lastIndexOf","substring","endsWith","parts","join","isValidUrl","addStreamsToList","existingStreams","add","handleSizeChange","val","handleCurrentChange","handleFileUpload","files","existingKeys","getGroupFromFileName","filename","handleClearList","updateLinkContent","handleCopy","textarea","document","createElement","appendChild","select","execCommand","err","removeChild","setItem","handleCollectMode","stopCollecting","isRestore","isArray","$set","hasInvalidUrls","Object","hasCheckingUrls","collect","setupCollectSchedule","progressMessage","total","duration","showClose","urlBatches","allResults","current","batchPromises","encodeURIComponent","statusText","filteredStreams","isCCTV","cctvNumber","extractCCTVNumber","isSatellite","batchResults","concat","allNewStreams","flatMap","self","findIndex","close","modeText","failedUrls","collectWithRetry","maxRetries","lastError","warn","cctvMatch","number","plus","cctvNameMatch","handleGenerateLink","txtResponse","m3uResponse","txtLink","m3uLink","generatedLinks","txt","m3u","generateTxtContent","generateM3uContent","customSort","sort","a","b","getNumber","numA","numB","localeCompare","groupedStreams","orderedGroups","keys","copyGeneratedLink","downloadTxtFile","blob","Blob","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","handleScheduleCheck","startScheduleCheck","calculateNextExecutionTime","now","hours","minutes","nextTime","setHours","setDate","getDate","targetDay","getDay","scheduleNextExecution","delay","getTime","setTimeout","clearStorageData","minimalStreamList","streamListStr","chunkSize","chunks","basicState","chunk","state","streamListChunks","savedState","removeItem","resetAllStates","updateActiveStatus","hasActive","addEventListener","preventDefault","returnValue","addCollectUrl","newIndex","removeCollectUrl","newUrlStatus","getResolutionTagType","getResponseTimeTagType","time","calculateNextCollectTime","scheduleNextCollection","handleSearch","searchPattern","RegExp","nameMatch","groupMatch","statusMatch","resetSearch","ip","process","env","NODE_ENV","serverIp","saveGithubSettings","clearSyncSchedule","path","getResponse","fileInfo","sha","base64Content","btoa","unescape","updateResponse","handleAutoSyncChange","calculateNextSyncTime","scheduleNextSync","getStatusTagType","showMessage","id","removeMessage","shift","msg","checkUrlAccessibility","baseUrl","VUE_APP_API_URL","accessible","handleImportUrl","getPlaceholderText","handleCollectUrlsFileUpload","invalidUrls","_","checkCollectUrlAccessibility","normalizedUrl","statusCode","clearCollectUrls","importFromGithub","currentStream","trimmedLine","lastCheck","isSelected","importDialogVisible","checkIpv6","ipv6","ipv6Checked","watch","handler","deep","linkForm.format","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\n  <div class=\"stream-check\">\n    <!-- 修改消息面板位置和样式 -->\n    <div class=\"message-panel\" :class=\"{ 'has-messages': messages.length > 0 }\">\n      <transition-group name=\"message-list\">\n        <div v-for=\"msg in messages\" :key=\"msg.id\" class=\"message-item\">\n          <i class=\"el-icon-delete\"></i>\n          <span class=\"message-content\">{{ msg.content }}</span>\n        </div>\n      </transition-group>\n    </div>\n\n    <div class=\"table-operations\">\n      <div class=\"button-groups\">\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-upload2\"\n            @click=\"$refs.fileInput.click()\"\n            :disabled=\"isCollecting\">\n          导入本地文件\n        </el-button>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-download\"\n            @click=\"importUrlDialogVisible = true\"\n            :disabled=\"isCollecting\">\n          导入网络文件\n        </el-button>\n      </el-button-group>\n        </div>\n\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            type=\"success\"\n            icon=\"el-icon-refresh\"\n            @click=\"handleBatchCheck\"\n            :loading=\"isChecking\">\n          {{ checkButtonText }}\n        </el-button>\n        <el-button\n            v-if=\"isChecking\"\n            type=\"warning\"\n            icon=\"el-icon-video-pause\"\n            @click=\"pauseCheck\">\n          暂停检测\n        </el-button>\n        <el-button\n            v-if=\"isPaused\"\n            type=\"primary\"\n            icon=\"el-icon-video-play\"\n            @click=\"resumeCheck\">\n          继续检测\n        </el-button>\n        <el-button\n            type=\"danger\"\n            icon=\"el-icon-delete\"\n            @click=\"handleClearList\">\n          清空列表\n        </el-button>\n      </el-button-group>\n        </div>\n\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            :type=\"isCollecting ? 'danger' : 'primary'\"\n            icon=\"el-icon-connection\"\n            @click=\"handleCollectMode\">\n          {{ isCollecting ? '停止采集' : '采集模式' }}\n        </el-button>\n      </el-button-group>\n        </div>\n\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-link\"\n            @click=\"handleGenerateLink\">\n          生成链接\n        </el-button>\n        <el-button\n            type=\"success\"\n            icon=\"el-icon-upload\"\n            @click=\"syncDialogVisible = true\">\n          同步到GitHub\n        </el-button>\n      </el-button-group>\n        </div>\n\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            :type=\"isScheduled ? 'danger' : 'primary'\"\n            icon=\"el-icon-timer\"\n            @click=\"handleScheduleCheck\">\n          {{ isScheduled ? '停止定时' : '定时检测' }}\n        </el-button>\n      </el-button-group>\n        </div>\n\n        <div class=\"button-group\">\n      <el-button-group>\n        <el-button\n            :type=\"filteredList.length > 0 ? 'danger' : 'primary'\"\n            icon=\"el-icon-search\"\n            @click=\"filteredList.length > 0 ? resetSearch() : searchDialogVisible = true\">\n          {{ filteredList.length > 0 ? '重置' : '搜索' }}\n        </el-button>\n      </el-button-group>\n        </div>\n      </div>\n\n      <!-- 隐藏的文件输入框 -->\n      <input\n          type=\"file\"\n          ref=\"fileInput\"\n          style=\"display: none\"\n          accept=\".txt,.m3u,.m3u8\"\n          @change=\"handleFileUpload\"\n      >\n    </div>\n\n    <div class=\"el-table-wrapper\">\n      <el-table\n          :data=\"paginatedData\"\n          border\n          style=\"width: 100%\">\n        <el-table-column\n            prop=\"name\"\n            label=\"名称\"\n            min-width=\"120\"\n            align=\"center\">\n        </el-table-column>\n\n        <el-table-column\n            prop=\"url\"\n            label=\"链接\"\n            min-width=\"200\"\n            align=\"center\"\n            show-overflow-tooltip>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"resolution\"\n            label=\"分辨率\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                :type=\"getResolutionTagType(scope.row.resolution)\">\n              {{ scope.row.resolution || '未知' }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"responseTime\"\n            label=\"响应速度\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                :type=\"getResponseTimeTagType(scope.row.responseTime)\">\n              {{ scope.row.responseTime === '-' ? '-' : scope.row.responseTime + 'ms' }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"group\"\n            label=\"分组\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                type=\"info\">\n              {{ scope.row.group }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"status\"\n            label=\"状态\"\n            width=\"100\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag :type=\"getStatusTagType(scope.row.status)\">\n              {{ scope.row.status }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            label=\"操作\"\n            width=\"120\"\n            align=\"center\"\n            fixed=\"right\">\n          <template slot-scope=\"scope\">\n            <el-tooltip content=\"复制链接\" placement=\"top\">\n              <el-button\n                  type=\"text\"\n                  icon=\"el-icon-document-copy\"\n                  @click=\"handleCopy(scope.row)\">\n              </el-button>\n            </el-tooltip>\n            <el-tooltip content=\"删除\" placement=\"top\">\n              <el-button\n                  type=\"text\"\n                  class=\"delete-btn\"\n                  icon=\"el-icon-delete\"\n                  @click=\"handleDelete(scope.row)\">\n              </el-button>\n            </el-tooltip>\n          </template>\n        </el-table-column>\n      </el-table>\n    </div>\n\n    <!-- 添加分页组件 -->\n    <div class=\"pagination-container\">\n      <el-pagination\n          @size-change=\"handleSizeChange\"\n          @current-change=\"handleCurrentChange\"\n          :current-page=\"currentPage\"\n          :page-sizes=\"[5, 10, 20, 50]\"\n          :page-size=\"pageSize\"\n          layout=\"total, sizes, prev, pager, next, jumper\"\n          :total=\"filteredList.length || streamList.length\">\n      </el-pagination>\n    </div>\n\n    <!-- 添加/编辑对话框 -->\n    <el-dialog\n        title=\"导入网络文件\"\n        :visible.sync=\"importUrlDialogVisible\"\n        width=\"500px\"\n        :close-on-click-modal=\"false\"\n        @closed=\"importUrlForm = { url: '', isChecking: false, isAccessible: null }\">\n      <el-form ref=\"importUrlForm\" label-width=\"80px\">\n        <el-form-item label=\"文件链接\" required>\n          <el-input\n            v-model=\"importUrlForm.url\"\n            placeholder=\"请输入直播源文件链接\"\n            @input=\"checkUrlAccessibility\">\n            <template slot=\"append\">\n              <i v-if=\"importUrlForm.isChecking\" class=\"el-icon-loading\"></i>\n              <i v-else-if=\"importUrlForm.isAccessible === true\" class=\"el-icon-success\" style=\"color: #67C23A\"></i>\n              <i v-else-if=\"importUrlForm.isAccessible === false\" class=\"el-icon-error\" style=\"color: #F56C6C\"></i>\n            </template>\n          </el-input>\n        </el-form-item>\n        <div v-if=\"importUrlForm.isAccessible === false\" style=\"color: #F56C6C; font-size: 12px; margin-bottom: 10px;\">\n          该链接无法访问，请检查链接是否正确\n        </div>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"importUrlDialogVisible = false\">取 消</el-button>\n        <el-button\n          type=\"primary\"\n          @click=\"handleImportUrl\"\n          :loading=\"importUrlForm.isChecking\"\n          :disabled=\"!importUrlForm.url || importUrlForm.isAccessible === false\">\n          确 定\n        </el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 采集模式设置对话框 -->\n    <el-dialog\n        title=\"采集模式设置\"\n        :visible.sync=\"collectDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"collectForm\" label-width=\"100px\" ref=\"collectForm\" :rules=\"collectRules\">\n        <!-- 采集模式选择 -->\n        <el-form-item label=\"采集模式\">\n          <el-radio-group v-model=\"collectForm.mode\">\n            <el-radio label=\"all\">全部采集</el-radio>\n            <el-radio label=\"tv\">央视卫视专采</el-radio>\n          </el-radio-group>\n        </el-form-item>\n\n        <!-- 采集地址列表 -->\n        <el-form-item\n            v-for=\"(url, index) in collectForm.urls\"\n            :key=\"index\"\n            :label=\"index === 0 ? '采集地址' : ''\"\n            :prop=\"'urls.' + index\">\n          <el-input\n              v-model=\"collectForm.urls[index]\"\n              placeholder=\"请输入需要采集的网络地址\"\n              @input=\"(val) => checkCollectUrlAccessibility(val, index)\">\n            <template slot=\"append\">\n              <i v-if=\"collectForm.urlStatus && collectForm.urlStatus[index] && collectForm.urlStatus[index].isChecking\" class=\"el-icon-loading\"></i>\n              <i v-else-if=\"collectForm.urlStatus && collectForm.urlStatus[index] && collectForm.urlStatus[index].isAccessible === true\" class=\"el-icon-success\" style=\"color: #67C23A\"></i>\n              <i v-else-if=\"collectForm.urlStatus && collectForm.urlStatus[index] && collectForm.urlStatus[index].isAccessible === false\" class=\"el-icon-error\" style=\"color: #F56C6C\"></i>\n              <el-button\n                  icon=\"el-icon-delete\"\n                  @click=\"removeCollectUrl(index)\"\n                  v-if=\"collectForm.urls.length > 1\">\n              </el-button>\n            </template>\n          </el-input>\n          <div v-if=\"collectForm.urlStatus && collectForm.urlStatus[index] && collectForm.urlStatus[index].isAccessible === false\"\n               style=\"color: #F56C6C; font-size: 12px; margin-top: 5px;\">\n            该链接无法访问，请检查链接是否正确\n          </div>\n        </el-form-item>\n\n        <!-- 添加地址按钮和导入按钮 -->\n        <el-form-item>\n          <div style=\"display: flex; gap: 10px;\">\n          <el-button\n              type=\"text\"\n              icon=\"el-icon-plus\"\n              @click=\"addCollectUrl\">\n            添加采集地址\n          </el-button>\n            <el-button\n                type=\"text\"\n                icon=\"el-icon-upload2\"\n                @click=\"$refs.collectUrlsFileInput.click()\">\n              导入地址文件\n            </el-button>\n            <el-button\n                type=\"text\"\n                icon=\"el-icon-delete\"\n                style=\"color: #F56C6C;\"\n                @click=\"clearCollectUrls\">\n              清空采集地址\n            </el-button>\n            <input\n                type=\"file\"\n                ref=\"collectUrlsFileInput\"\n                style=\"display: none\"\n                accept=\".txt\"\n                @change=\"handleCollectUrlsFileUpload\">\n          </div>\n        </el-form-item>\n\n        <el-form-item label=\"自动采集\">\n          <el-switch v-model=\"collectForm.autoCollect\"></el-switch>\n        </el-form-item>\n\n        <!-- 采集时间设置 -->\n        <template v-if=\"collectForm.autoCollect\">\n          <el-form-item label=\"采集周期\" prop=\"collectType\">\n            <el-radio-group v-model=\"collectForm.collectType\">\n              <el-radio label=\"daily\">每天</el-radio>\n              <el-radio label=\"weekly\">每周</el-radio>\n            </el-radio-group>\n          </el-form-item>\n\n          <el-form-item label=\"执行时间\" prop=\"executeTime\">\n            <el-time-picker\n                v-model=\"collectForm.executeTime\"\n                format=\"HH:mm\"\n                value-format=\"HH:mm\"\n                placeholder=\"选择时间\">\n            </el-time-picker>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行日期\"\n              prop=\"weekDay\"\n              v-if=\"collectForm.collectType === 'weekly'\">\n            <el-select v-model=\"collectForm.weekDay\">\n              <el-option label=\"星期一\" value=\"1\"></el-option>\n              <el-option label=\"星期二\" value=\"2\"></el-option>\n              <el-option label=\"星期三\" value=\"3\"></el-option>\n              <el-option label=\"星期四\" value=\"4\"></el-option>\n              <el-option label=\"星期五\" value=\"5\"></el-option>\n              <el-option label=\"星期六\" value=\"6\"></el-option>\n              <el-option label=\"星期日\" value=\"0\"></el-option>\n            </el-select>\n          </el-form-item>\n        </template>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"collectDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startCollecting\">开始采集</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 生成链接对话框 -->\n    <el-dialog\n        title=\"生成链接\"\n        :visible.sync=\"generateLinkDialogVisible\"\n        width=\"500px\"\n        custom-class=\"generate-link-dialog\">\n      <div class=\"link-container\">\n        <!-- 添加格式选择 -->\n        <el-form :model=\"linkForm\" label-width=\"80px\">\n          <el-form-item label=\"文件格式\">\n            <el-radio-group v-model=\"linkForm.format\">\n              <el-radio label=\"txt\">TXT格式</el-radio>\n              <el-radio label=\"m3u\">M3U格式</el-radio>\n            </el-radio-group>\n          </el-form-item>\n        </el-form>\n\n        <!-- 链接展示卡片 -->\n        <el-card class=\"link-card\">\n          <div class=\"link-content\">\n            <el-input\n                v-model=\"generatedLink\"\n                placeholder=\"正在生成链接...\"\n                readonly>\n              <template slot=\"prepend\">链接地址</template>\n              <el-button\n                  slot=\"append\"\n                  icon=\"el-icon-document-copy\"\n                  @click=\"copyGeneratedLink\">\n                复制\n              </el-button>\n            </el-input>\n          </div>\n        </el-card>\n\n        <!-- 使用说明 -->\n        <el-card class=\"tips-card\">\n          <div class=\"tips-content\">\n            <ul>\n              <li>生成的链接可以直接在支持网络导入的播放器中使用</li>\n              <li>链接内容会随列表更新而自动更新</li>\n              <li>TXT格式适用于大多数播放器</li>\n              <li>M3U格式提供更好的播放器兼容性</li>\n            </ul>\n          </div>\n        </el-card>\n      </div>\n    </el-dialog>\n\n    <!-- 添加定时检测设置对话框 -->\n    <el-dialog\n        title=\"定时检测设置\"\n        :visible.sync=\"scheduleDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"scheduleForm\" label-width=\"100px\" ref=\"scheduleForm\" :rules=\"scheduleRules\">\n        <el-form-item label=\"检测周期\" prop=\"scheduleType\">\n          <el-radio-group v-model=\"scheduleForm.scheduleType\">\n            <el-radio label=\"daily\">每天</el-radio>\n            <el-radio label=\"weekly\">每周</el-radio>\n          </el-radio-group>\n        </el-form-item>\n\n        <el-form-item label=\"执行时间\" prop=\"executeTime\">\n          <el-time-picker\n              v-model=\"scheduleForm.executeTime\"\n              format=\"HH:mm\"\n              value-format=\"HH:mm\"\n              placeholder=\"选择时间\">\n          </el-time-picker>\n        </el-form-item>\n\n        <el-form-item\n            label=\"执行日期\"\n            prop=\"weekDay\"\n            v-if=\"scheduleForm.scheduleType === 'weekly'\">\n          <el-select v-model=\"scheduleForm.weekDay\">\n            <el-option label=\"星期一\" value=\"1\"></el-option>\n            <el-option label=\"星期二\" value=\"2\"></el-option>\n            <el-option label=\"星期三\" value=\"3\"></el-option>\n            <el-option label=\"星期四\" value=\"4\"></el-option>\n            <el-option label=\"星期五\" value=\"5\"></el-option>\n            <el-option label=\"星期六\" value=\"6\"></el-option>\n            <el-option label=\"星期日\" value=\"0\"></el-option>\n          </el-select>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"scheduleDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startScheduleCheck\">开始定时</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 添加搜索对话框 -->\n    <el-dialog\n        title=\"搜索直播源\"\n        :visible.sync=\"searchDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"searchForm\" label-width=\"80px\">\n        <el-form-item label=\"名称\">\n          <el-input\n              v-model=\"searchForm.name\"\n              placeholder=\"支持模糊搜索\"\n              clearable>\n          </el-input>\n        </el-form-item>\n        <el-form-item label=\"分组\">\n          <el-select\n              v-model=\"searchForm.group\"\n              placeholder=\"请选择\"\n              clearable>\n            <el-option\n                v-for=\"group in groupOptions\"\n                :key=\"group\"\n                :label=\"group\"\n                :value=\"group\">\n            </el-option>\n          </el-select>\n        </el-form-item>\n        <el-form-item label=\"状态\">\n          <el-select\n              v-model=\"searchForm.status\"\n              placeholder=\"请选择\"\n              clearable>\n            <el-option label=\"正常\" value=\"正常\"></el-option>\n            <el-option label=\"异常\" value=\"异常\"></el-option>\n            <el-option label=\"未检测\" value=\"未检测\"></el-option>\n          </el-select>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"searchDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleSearch\">搜 索</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- GitHub同步设置对话框 -->\n    <el-dialog\n        title=\"GitHub同步设置\"\n        :visible.sync=\"syncDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"syncForm\" ref=\"syncForm\" label-width=\"120px\" :rules=\"syncRules\">\n        <el-form-item label=\"GitHub Token\" prop=\"token\">\n          <el-input\n              v-model=\"syncForm.token\"\n              type=\"password\"\n              placeholder=\"请输入GitHub Personal Access Token\"\n              show-password>\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"仓库名称\" prop=\"repo\">\n          <el-input\n              v-model=\"syncForm.repo\"\n              placeholder=\"格式：用户名/仓库名\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"TXT文件名\" prop=\"txtPath\">\n          <el-input\n              v-model=\"syncForm.txtPath\"\n              placeholder=\"例如：playlist.txt\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"M3U文件名\" prop=\"m3uPath\">\n          <el-input\n              v-model=\"syncForm.m3uPath\"\n              placeholder=\"例如：playlist.m3u\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"定时同步\">\n          <el-switch\n              v-model=\"syncForm.autoSync\"\n              @change=\"handleAutoSyncChange\">\n          </el-switch>\n        </el-form-item>\n        \n        <template v-if=\"syncForm.autoSync\">\n          <el-form-item label=\"同步周期\" prop=\"syncType\">\n            <el-radio-group v-model=\"syncForm.syncType\">\n              <el-radio label=\"daily\">每天</el-radio>\n              <el-radio label=\"weekly\">每周</el-radio>\n              <el-radio label=\"afterCheck\">批量检测完毕后</el-radio>\n            </el-radio-group>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行时间\"\n              prop=\"executeTime\"\n              v-if=\"syncForm.syncType !== 'afterCheck'\">\n            <el-time-picker\n                v-model=\"syncForm.executeTime\"\n                format=\"HH:mm\"\n                value-format=\"HH:mm\"\n                placeholder=\"选择时间\">\n            </el-time-picker>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行日期\"\n              prop=\"weekDay\"\n              v-if=\"syncForm.syncType === 'weekly'\">\n            <el-select v-model=\"syncForm.weekDay\">\n              <el-option label=\"星期一\" value=\"1\"></el-option>\n              <el-option label=\"星期二\" value=\"2\"></el-option>\n              <el-option label=\"星期三\" value=\"3\"></el-option>\n              <el-option label=\"星期四\" value=\"4\"></el-option>\n              <el-option label=\"星期五\" value=\"5\"></el-option>\n              <el-option label=\"星期六\" value=\"6\"></el-option>\n              <el-option label=\"星期日\" value=\"0\"></el-option>\n            </el-select>\n          </el-form-item>\n        </template>\n        \n        <el-form-item label=\"提交信息\" prop=\"message\">\n          <el-input\n              v-model=\"syncForm.message\"\n              placeholder=\"更新说明\">\n          </el-input>\n        </el-form-item>\n      </el-form>\n      \n      <div slot=\"footer\">\n        <el-button @click=\"syncDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"saveGithubSettings\">保 存</el-button>\n      </div>\n    </el-dialog>\n  </div>\n\n</template>\n\n<script>\nexport default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importUrlForm: {\n        url: '',\n        isChecking: false,\n        isAccessible: null\n      },\n      importRules: {\n        url: [\n          { required: true, message: '请输入URL地址', trigger: 'blur' },\n          { type: 'url', message: '请输入正确的URL地址', trigger: ['blur', 'change'] }\n        ],\n        group: [\n          { required: true, message: '请选择分组', trigger: 'change' }\n        ]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        urlStatus: {},  // 添加urlStatus对象\n        autoCollect: false,\n        collectType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1',\n        mode: 'tv'\n      },\n      collectRules: {\n        urls: [\n          { \n            type: 'array',\n            validator: (rule, value, callback) => {\n              if (value.length === 0) {\n                callback(new Error('请至少添加一个采集地址'))\n              }\n              // 验证每个URL\n              const errors = value.map(url => {\n                if (!url) return '采集地址不能为空'\n                if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址'\n                return null\n              }).filter(error => error !== null)\n              \n              if (errors.length > 0) {\n                callback(new Error(errors[0]))\n              } else {\n                callback()\n              }\n            },\n            trigger: 'change'\n          }\n        ],\n        executeTime: [\n          { required: true, message: '请选择执行时间', trigger: 'change' }\n        ],\n        weekDay: [\n          { required: true, message: '请选择执行日期', trigger: 'change' }\n        ]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',  // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        scheduleType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      scheduleRules: {\n        executeTime: [\n          { required: true, message: '请选择执行时间', trigger: 'change' }\n        ],\n        weekDay: [\n          { required: true, message: '请选择执行日期', trigger: 'change' }\n        ]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState', // 用于本地存储的key\n      hasActiveOperations: false,  // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      },\n      searchDialogVisible: false,\n      searchForm: {\n        name: '',\n        group: '',\n        status: ''\n      },\n      filteredList: [], // 用于存储搜索过滤后的列表\n      realIp: '',  // 存储真实IP地址\n      syncDialogVisible: false,\n      syncForm: {\n        token: localStorage.getItem('githubToken') || '',\n        repo: localStorage.getItem('githubRepo') || '',\n        txtPath: localStorage.getItem('githubTxtPath') || '',\n        m3uPath: localStorage.getItem('githubM3uPath') || '',\n        autoSync: localStorage.getItem('githubAutoSync') === 'true',\n        syncType: localStorage.getItem('githubSyncType') || 'daily',\n        executeTime: localStorage.getItem('githubExecuteTime') || '00:00',\n        weekDay: localStorage.getItem('githubWeekDay') || '1',\n        message: '更新直播源列表'\n      },\n      syncRules: {\n        token: [\n          { required: true, message: '请输入GitHub Token', trigger: 'blur' }\n        ],\n        repo: [\n          { required: true, message: '请输入仓库名称', trigger: 'blur' },\n          { pattern: /^[\\w-]+\\/[\\w-]+$/, message: '格式：用户名/仓库名', trigger: 'blur' }\n        ],\n        txtPath: [\n          { required: true, message: '请输入文件路径', trigger: 'blur' }\n        ],\n        m3uPath: [\n          { required: true, message: '请输入文件路径', trigger: 'blur' }\n        ],\n        message: [\n          { required: true, message: '请输入提交消息', trigger: 'blur' }\n        ]\n      },\n      syncTimer: null,\n      messages: [], // 用于存储消息\n      messageId: 0, // 用于生成唯一的消息ID\n      isPageSwitching: false, // 添加页面切换标志\n      // 添加标准分组名称常量\n      STANDARD_GROUPS: {\n        CCTV: '央视频道',\n        SATELLITE: '卫视频道'\n      },\n    }\n  },\n  computed: {\n    paginatedData() {\n      // 使用过滤后的列表进行分页\n      const start = (this.currentPage - 1) * this.pageSize\n      const end = start + this.pageSize\n      return (this.filteredList.length > 0 ? this.filteredList : this.streamList).slice(start, end)\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测'\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map()\n      \n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name // 使用名称作为键\n        \n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key)\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url)\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          })\n        }\n      })\n      \n      // 转换回数组格式\n      return Array.from(streamMap.values())\n    },\n    groupOptions() {\n      return [...new Set(this.streamList.map(item => item.group))]\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList')\n      if (savedList) {\n        this.streamList = JSON.parse(savedList)\n        // 初始化时检查多播源\n        this.$nextTick(() => {\n          this.checkMulticastStreams() // 使用新方法\n        })\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList)\n    \n    // 监听设置更新事件\n    this.$root.$on('settings-updated', this.handleSettingsUpdate)\n\n    // 从本地存储恢复状态\n    this.restoreState()\n    \n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true) // true表示是恢复状态\n    }\n    // 如果GitHub自动同步是开启状态，重新启动同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule()\n    }\n\n    this.filteredList = []\n    this.getRealIp()  // 获取真实IP地址\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList)\n    this.$root.$off('settings-updated', this.handleSettingsUpdate)\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck()\n    // 在组件销毁前保存状态\n    this.saveState()\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\n  },\n  methods: {\n    // 添加处理设置更新的方法\n    handleSettingsUpdate(event) {\n      console.log('收到设置更新事件:', event)\n      if (event && event.type === 'settings-changed' && event.settings) {\n        console.log('设置已更新，当前设置:', event.settings)\n        // 重新检查所有多播源\n        this.$nextTick(() => {\n          this.checkMulticastStreams()\n        })\n      }\n    },\n\n    // 添加多播源检测的辅助方法\n    isMulticastStream(url) {\n      if (!url) return false\n      \n      // 更完整的多播源检测正则表达式\n      const patterns = [\n        // 标准格式\n        /[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // 带@的格式\n        /^(udp|rtp):\\/\\/@239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/@225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/@224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // 不带@的格式\n        /^(udp|rtp):\\/\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // IPv6格式\n        /^(udp|rtp):\\/\\/\\[239\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i,\n        /^(udp|rtp):\\/\\/\\[225\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i,\n        /^(udp|rtp):\\/\\/\\[224\\.\\d+\\.\\d+\\.\\d+\\]:\\d+/i,\n        // 其他常见格式\n        /^(udp|rtp):\\/\\/@?239\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i,\n        /^(udp|rtp):\\/\\/@?225\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i,\n        /^(udp|rtp):\\/\\/@?224\\.\\d+\\.\\d+\\.\\d+[/]\\d+/i,\n        // 简单格式\n        /^udp\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^rtp\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^udp\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^rtp\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^udp\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^rtp\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // 带端口的格式\n        /^(udp|rtp):\\/\\/@?239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/@?225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /^(udp|rtp):\\/\\/@?224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // 特殊格式\n        /^(udp|rtp)[/](239|225|224)\\.\\d+\\.\\d+\\.\\d+[/]?(\\d+)?/i,\n        /^(udp|rtp):\\/\\/(239|225|224)\\.\\d+\\.\\d+\\.\\d+[/]?(\\d+)?/i,\n        // HTTP代理的UDP/RTP多播源格式\n        /http:\\/\\/[^/]+[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /http:\\/\\/[^/]+[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /http:\\/\\/[^/]+[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // HTTPS代理的UDP/RTP多播源格式\n        /https:\\/\\/[^/]+[/](udp|rtp)[/]224\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /https:\\/\\/[^/]+[/](udp|rtp)[/]225\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        /https:\\/\\/[^/]+[/](udp|rtp)[/]239\\.\\d+\\.\\d+\\.\\d+:\\d+/i,\n        // 任何包含 udp 或 rtp 的链接\n        /^(udp|rtp):\\/\\//i,\n        /\\/(udp|rtp)\\//i,\n        /^(udp|rtp)@/i\n      ]\n      \n      // 先转换为小写进行检查\n      const lowerUrl = url.toLowerCase()\n      const isMulticast = patterns.some(pattern => pattern.test(lowerUrl))\n            if (isMulticast) {\n        console.log('检测到多播源:', url)\n      }\n      return isMulticast\n    },\n\n    // 检查多播源的方法\n    checkMulticastStreams() {\n      try {\n        // 从localStorage直接获取autoRemoveMulticast设置\n        const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true'\n        console.log('自动清除多播源设置状态:', autoRemoveMulticast)\n\n        // 只有在设置为true时才执行清除\n        if (autoRemoveMulticast) {\n          console.log('开始检查多播源...')\n          let removedCount = 0\n          const toRemove = []\n\n          // 检查所有流\n          this.streamList.forEach((stream, index) => {\n            if (this.isMulticastStream(stream.url)) {\n              toRemove.push(index)\n              removedCount++\n              console.log('发现多播源:', stream.url)\n            }\n          })\n\n          // 从后向前删除\n          for (let i = toRemove.length - 1; i >= 0; i--) {\n            const index = toRemove[i]\n            const stream = this.streamList[index]\n            console.log('正在删除多播源:', stream.name, stream.url)\n            this.streamList.splice(index, 1)\n            this.handleStreamRemoval(stream, '多播源')\n          }\n\n          if (removedCount > 0) {\n            console.log(`成功清除 ${removedCount} 个多播源`)\n            this.$message.warning(`已自动清除 ${removedCount} 个多播源`)\n            this.saveStreamList()\n            \n            // 如果当前页没有数据，跳转到上一页\n            if (this.paginatedData.length === 0 && this.currentPage > 1) {\n              this.currentPage--\n            }\n          }\n        } else {\n          console.log('自动清除多播源功能未开启，跳过检查')\n        }\n      } catch (error) {\n        console.error('检查多播源失败:', error)\n      }\n    },\n\n    async checkStream(stream) {\n      // 优先从 appSettings 中读取 FFprobe 路径\n      let ffprobePath = ''\n      try {\n        const appSettings = localStorage.getItem('appSettings')\n        if (appSettings) {\n          const settings = JSON.parse(appSettings)\n          ffprobePath = settings.ffprobePath\n        }\n      } catch (error) {\n        console.error('读取 appSettings 失败:', error)\n      }\n\n      // 如果 appSettings 中没有，则从独立设置中读取\n      if (!ffprobePath) {\n        ffprobePath = localStorage.getItem('ffprobePath')\n      }\n\n      if (!ffprobePath) {\n        console.error('未找到 FFprobe 路径配置')\n        this.$message.error('请先在系统设置中配置FFprobe路径')\n              return false\n      }\n\n      // 检查是否是多播源\n      if (this.isMulticastStream(stream.url)) {\n        // 直接返回false，不再设置状态\n        return false\n      }\n\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        })\n\n        if (!response.ok) throw new Error('请求失败')\n        \n        const result = await response.json()\n        \n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常'\n        stream.resolution = result.resolution || '-'\n        stream.responseTime = result.responseTime || '-'\n\n        // 检查是否需要自动清除\n        if (!result.available || this.shouldRemoveStream(stream)) {\n          let reason = ''\n          if (!result.available || stream.status === '异常') {\n            reason = '异常源'\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢'\n          } else {\n            reason = '分辨率过低'\n          }\n\n          const listIndex = this.streamList.indexOf(stream)\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1)\n            this.handleStreamRemoval(stream, reason)\n          }\n        }\n        \n        this.saveStreamList()\n        return result.available\n      } catch (error) {\n        console.error('检测错误:', error)\n        stream.status = '异常'\n        \n        // 如果设置了自动清除异常源，在这里也进行清除\n        if (this.shouldRemoveStream(stream)) {\n          const currentPageItems = this.paginatedData\n          const pageIndex = currentPageItems.indexOf(stream)\n          const listIndex = this.streamList.indexOf(stream)\n          \n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1)\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--\n            }\n            console.log(`清除异常直播源: ${stream.name}, 原因: 检测失败`)\n            this.$message.warning('已自动清除直播源：检测失败')\n          }\n        }\n        \n        this.saveStreamList()\n        return false\n      }\n    },\n\n    shouldRemoveStream(stream) {\n      try {\n        // 获取设置\n        const appSettings = localStorage.getItem('appSettings')\n        let settings = {}\n        if (appSettings) {\n          settings = JSON.parse(appSettings)\n        }\n\n        // 检查是否需要清除异常源\n        if (settings.autoRemoveInvalid === true && \n            (stream.status === '异常' || stream.status === '未知')) {\n          console.log(`应清除异常源: ${stream.name}, 状态: ${stream.status}`)\n          return true\n        }\n\n        // 获取模式设置\n        const extremeMode = settings.extremeMode === true\n        const strictMode = settings.strictMode === true\n\n        // 检查是否需要清除低分辨率源\n        if (settings.autoRemoveLowRes === true && \n            stream.resolution !== '未知' && \n            stream.resolution !== '多播源' && \n            stream.resolution !== '-') {\n          const [width, height] = stream.resolution.split('x').map(Number)\n          if (extremeMode ? (width < 1920 || height < 1080) : \n              (strictMode ? (width < 1920 || height < 1080) : (width < 1280 || height < 720))) {\n            console.log(`应清除低分辨率源: ${stream.name}, 分辨率: ${stream.resolution}`)\n            return true\n          }\n        }\n\n        // 检查响应时间\n        if (settings.autoRemoveSlowResponse === true && \n            stream.responseTime !== '-' &&\n            Number(stream.responseTime) > (extremeMode ? 1500 : (strictMode ? 2000 : 3000))) {\n          console.log(`应清除慢速源: ${stream.name}, 响应时间: ${stream.responseTime}ms`)\n          return true\n        }\n\n        return false\n      } catch (error) {\n        console.error('检查是否应该移除流时出错:', error)\n        return false\n      }\n    },\n\n    async handleBatchCheck() {\n      if (this.isChecking) return\n      \n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex)\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源')\n        return\n      }\n\n      this.isChecking = true\n      this.shouldStop = false\n      this.totalCount = uncheckedStreams.length\n      this.checkedCount = this.isPaused ? this.checkedCount : 0\n      \n      try {\n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3\n      \n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0\n        \n        // 分批处理，每批次处理固定数量的流\n        const batchSize = Math.min(concurrentChecks, 10) // 限制最大并发数\n        \n        for (let i = startIndex; i < uncheckedStreams.length; i += batchSize) {\n          if (this.shouldStop) break\n          \n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + batchSize)\n          \n          // 并发检测当前批次的所有流\n          await Promise.all(\n            batch.map(async stream => {\n              if (this.shouldStop) return\n              \n              try {\n              stream.status = '检测中'\n              const success = await this.checkStream(stream)\n              this.checkedCount++\n              \n              if (success) {\n                this.saveState()\n                }\n              } catch (error) {\n                console.error('检测流失败:', error)\n                stream.status = '异常'\n                this.checkedCount++\n              }\n            })\n          )\n          \n          // 更新暂停位置\n          this.pausedIndex = i + batchSize - 1\n          \n          // 每批次完成后保存状态\n          this.saveState()\n        }\n\n        if (!this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = false\n          this.pausedIndex = -1\n          this.$message.success('批量检测完成')\n          \n          // 检查是否需要在批量检测完成后同步\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath)\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath)\n            this.$message.success('已同步到GitHub')\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error)\n        this.$message.error('批量检测失败')\n      } finally {\n        if (this.shouldStop && this.streamList.length > 0) {\n          this.isChecking = false\n          this.isPaused = true\n          this.$message.info('检测已暂停')\n        } else {\n          this.isChecking = false\n          this.isPaused = false\n          this.pausedIndex = -1\n        }\n      }\n    },\n\n    pauseCheck() {\n      this.shouldStop = true\n    },\n\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true\n        this.isPaused = false\n        this.shouldStop = false\n        await this.batchCheck(this.pausedIndex)\n      }\n    },\n\n    async handleCheck(row) {\n      row.status = '检测中'\n      \n      const success = await this.checkStream(row)\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`)\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row)\n        this.streamList.splice(index, 1)\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1)\n        }\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('删除成功')\n      }).catch(() => {})\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate()\n      if (!valid) return\n\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: this.importForm.url })\n        })\n\n        if (!response.ok) throw new Error('导入失败')\n\n        const content = await response.text()\n        const newStreams = this.parseContent(content)\n\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            this.importUrlDialogVisible = false\n            \n            // 导入后立即检查多播源\n            this.$nextTick(() => {\n              this.checkMulticastStreams()\n            })\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message)\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = (e) => resolve(e.target.result)\n        reader.onerror = () => reject(new Error('文件读取失败'))\n        reader.readAsText(file)\n      })\n    },\n    parseContent(content) {\n      const streams = []\n      let currentGroup = '未分组'\n      let currentName = ''\n      \n      // 获取自动清除多播源设置\n      const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true'\n      console.log('解析内容时的自动清除多播源设置状态:', autoRemoveMulticast)\n      \n      // 清理HTML标签\n      content = content.replace(/<[^>]*>/g, '')\n      \n      // 按行分割内容\n      const lines = content.split('\\n')\n\n      lines.forEach(line => {\n        line = line.trim()\n        if (!line) return\n\n        // 处理M3U格式\n        if (line.startsWith('#EXTINF:-1')) {\n          // 提取tvg-name属性\n          const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/)\n          if (tvgNameMatch) {\n            currentName = tvgNameMatch[1].trim()\n          } else {\n            // 如果没有tvg-name，尝试提取最后的逗号后的名称\n            const lastCommaIndex = line.lastIndexOf(',')\n            if (lastCommaIndex !== -1) {\n              currentName = line.substring(lastCommaIndex + 1).trim()\n            }\n          }\n          return\n        }\n        \n        // 处理普通分组标记\n        if (line.endsWith(',#genre#')) {\n          currentGroup = line.slice(0, -8)\n          return\n        }\n        \n        // 如果是URL行（不以#开头）\n        if (!line.startsWith('#')) {\n          let name = currentName || ''\n          let urls = []\n          \n          // 处理普通格式（名称,URL）\n          if (line.includes(',')) {\n            const parts = line.split(',')\n            name = name || parts[0].trim()\n            // 清理URL中的HTML标签\n            urls = parts.slice(1).join(',').split('#').map(url => url.replace(/<[^>]*>/g, ''))\n          } else {\n            // 处理纯URL格式，清理HTML标签\n            urls = [line.replace(/<[^>]*>/g, '')]\n          }\n          \n          if (name && urls.length > 0) {\n            // 确定分组\n            let group = currentGroup\n            // 处理卫视频道\n            if (/卫视/.test(name)) {\n              group = this.STANDARD_GROUPS.SATELLITE\n            }\n            // 处理CCTV频道（不区分大小写）\n            else if (/CCTV/i.test(name)) {\n              group = this.STANDARD_GROUPS.CCTV\n            }\n            \n            // 添加所有有效的URL\n            urls.forEach(url => {\n              url = url.trim()\n              // 验证URL格式，只有在autoRemoveMulticast为false时才添加多播源\n              if (url && ((!autoRemoveMulticast && this.isMulticastStream(url)) || !this.isMulticastStream(url)) && this.isValidUrl(url)) {\n                streams.push({\n                  name: name,\n                  url: url,\n                  group: group,\n                  status: '未检测',\n                  resolution: '-',\n                  responseTime: '-'\n                })\n              }\n            })\n          }\n          currentName = ''  // 重置当前名称\n        }\n      })\n\n      // 最后再次检查所有流的分组\n      streams.forEach(stream => {\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV\n        } else if (/卫视/.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.SATELLITE\n        }\n      })\n\n      console.log(`解析完成: 共发现 ${streams.length} 个有效直播源`)\n      return streams\n    },\n\n    // 添加URL验证方法\n    isValidUrl(url) {\n      try {\n        // 移除HTML标签\n        url = url.replace(/<[^>]*>/g, '')\n        // 检查是否是有效的URL格式\n        return url.startsWith('http://') || url.startsWith('https://') || url.startsWith('rtmp://') || url.startsWith('rtsp://')\n      } catch (e) {\n        return false\n      }\n    },\n    addStreamsToList(streams) {\n      // 标准化所有流的分组名称\n      streams.forEach(stream => {\n        // 优先根据名称判断分组，不区分大小写\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV\n        } else if (/卫视/.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.SATELLITE\n        }\n      })\n\n      // 检查重复并添加到列表\n      const existingStreams = new Set(\n        this.streamList.map(s => `${s.url}|${s.group}`)\n      )\n\n      const uniqueStreams = streams.filter(stream => {\n        const key = `${stream.url}|${stream.group}`\n        if (existingStreams.has(key)) {\n          return false\n        }\n        existingStreams.add(key)\n        return true\n      })\n\n      // 添加到列表前再次确认CCTV频道分组\n      uniqueStreams.forEach(stream => {\n        if (/CCTV/i.test(stream.name)) {\n          stream.group = this.STANDARD_GROUPS.CCTV\n        }\n      })\n\n      this.streamList.push(...uniqueStreams)\n      this.currentPage = 1\n      this.saveStreamList()\n    },\n    handleSizeChange(val) {\n      this.pageSize = val\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 过滤重复的直播源（同时考虑URL和分组）\n          const existingKeys = new Set(\n            this.streamList.map(s => `${s.url}|${s.group}`)\n          )\n          const uniqueStreams = newStreams.filter(s => {\n            const key = `${s.url}|${s.group}`\n            if (existingKeys.has(key)) {\n              return false\n            }\n            existingKeys.add(key)\n            return true\n          })\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            \n            // 只有在设置开启时才检查多播源\n            const autoRemoveMulticast = localStorage.getItem('autoRemoveMulticast') === 'true'\n            if (autoRemoveMulticast) {\n              this.$nextTick(() => {\n                this.checkMulticastStreams()\n              })\n            }\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase()\n      if (/cctv/i.test(name)) return this.STANDARD_GROUPS.CCTV\n      if (name.includes('卫视')) return this.STANDARD_GROUPS.SATELLITE\n      if (name.includes('地方')) return '地方台'\n      return '未分组'\n    },\n    handleClearList() {\n      this.$confirm('确认清空列表吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 先停止所有检测和采集任务\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n        this.pausedIndex = -1\n        \n        // 清除所有定时器\n        if (this.collectTimer) {\n          clearInterval(this.collectTimer)\n          this.collectTimer = null\n        }\n        if (this.scheduleTimer) {\n          clearInterval(this.scheduleTimer)\n          this.scheduleTimer = null\n        }\n        if (this.syncTimer) {\n          clearInterval(this.syncTimer)\n          this.syncTimer = null\n        }\n        \n        // 重置所有状态\n        this.isCollecting = false\n        this.isScheduled = false\n        this.checkedCount = 0\n        this.totalCount = 0\n        \n        // 清空列表和重置页码\n        this.streamList = []\n        this.currentPage = 1\n        \n        // 更新链接内容和保存状态\n        this.updateLinkContent()\n        this.saveState()\n        \n        this.$message({\n          type: 'success',\n          message: '列表已清空'\n        })\n      }).catch(() => {\n        this.$message({\n          type: 'info',\n          message: '已取消清空'\n        })\n      })\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea')\n      textarea.value = row.url\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting()\n      } else {\n        this.collectDialogVisible = true\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', [''])\n          return\n        }\n        \n        // 检查所有URL是否可访问\n        const hasInvalidUrls = Object.values(this.collectForm.urlStatus || {}).some(\n          status => status && status.isAccessible === false\n        )\n        \n        if (hasInvalidUrls) {\n          this.$message.error('存在无法访问的链接，请检查后重试')\n          return\n        }\n\n        // 检查是否有正在检测的URL\n        const hasCheckingUrls = Object.values(this.collectForm.urlStatus || {}).some(\n          status => status && status.isChecking\n        )\n\n        if (hasCheckingUrls) {\n          this.$message.warning('有链接正在检测中，请等待检测完成')\n          return\n        }\n        \n        const valid = await this.$refs.collectForm.validate()\n        if (!valid) return\n      }\n\n      this.collectDialogVisible = false\n      this.isCollecting = true\n      this.saveState() // 保存状态\n      \n      // 立即执行一次采集\n      await this.collect()\n      \n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule()\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false\n        this.saveState()\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      this.saveState() // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集')\n      }\n    },\n    async collect() {\n      let progressMessage = null;\n      try {\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集')\n          return\n        }\n\n        const total = this.collectForm.urls.length\n        if (total === 0) {\n          this.$message.warning('没有需要采集的地址')\n          return\n        }\n\n        // 创建进度消息提示\n        progressMessage = this.$message({\n          message: `正在采集: 0/${total}`,\n          type: 'info',\n          duration: 0,  // 消息不会自动关闭\n          showClose: false\n        });\n        \n        // 将URL列表分批处理，每批最多5个\n        const batchSize = 5\n        const urlBatches = []\n        for (let i = 0; i < this.collectForm.urls.length; i += batchSize) {\n          urlBatches.push(this.collectForm.urls.slice(i, i + batchSize))\n        }\n        \n        let allResults = []\n        let current = 0\n        \n        // 处理每一批URL\n        for (const batch of urlBatches) {\n          const batchPromises = batch.map(async (url) => {\n            try {\n              const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'text/plain'\n                },\n              })\n              \n              if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n              }\n              \n              const content = await response.text()\n              const newStreams = this.parseContent(content)\n              \n              // 根据采集模式过滤直播源\n              let filteredStreams = newStreams\n              if (this.collectForm.mode === 'tv') {\n                filteredStreams = newStreams.filter(s => {\n                  // 处理央视频道\n                  const isCCTV = /CCTV/i.test(s.name)\n                  if (isCCTV) {\n                    s.group = this.STANDARD_GROUPS.CCTV\n                    const cctvNumber = this.extractCCTVNumber(s.name)\n                    if (cctvNumber) {\n                      s.name = cctvNumber\n                    }\n                    return true\n                  }\n                  // 处理卫视频道\n                  const isSatellite = /卫视/.test(s.name)\n                  if (isSatellite) {\n                    s.group = this.STANDARD_GROUPS.SATELLITE\n                    return true\n                  }\n                  return false\n                })\n              }\n              \n              // 再次确保所有CCTV频道都在正确分组\n              filteredStreams.forEach(s => {\n                if (/CCTV/i.test(s.name)) {\n                  s.group = this.STANDARD_GROUPS.CCTV\n                }\n              })\n\n              current++\n              // 更新进度消息\n              if (progressMessage) {\n                progressMessage.message = `正在采集: ${Math.min(current, total)}/${total}`;\n              }\n              \n              return { status: 'fulfilled', value: filteredStreams }\n            } catch (error) {\n              current++\n              // 更新进度消息（即使失败也计入进度）\n              if (progressMessage) {\n                progressMessage.message = `正在采集: ${Math.min(current, total)}/${total}`;\n              }\n              console.error(`采集地址失败 ${url}:`, error)\n              return { status: 'rejected', reason: error }\n            }\n          })\n          \n          const batchResults = await Promise.all(batchPromises)\n          allResults = allResults.concat(batchResults)\n        }\n\n        // 合并所有采集结果\n        const allNewStreams = allResults\n          .filter(result => result.status === 'fulfilled')\n          .flatMap(result => result.value)\n          .filter((stream, index, self) => \n            index === self.findIndex(s => s.url === stream.url)\n          )\n\n        // 关闭进度消息\n        if (progressMessage) {\n          progressMessage.close();\n        }\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams)\n          const modeText = this.collectForm.mode === 'tv' ? '央视卫视' : ''\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个${modeText}直播源`)\n        } else {\n          const modeText = this.collectForm.mode === 'tv' ? '央视卫视' : ''\n          this.$message.info(`未发现新的${modeText}直播源`)\n        }\n\n        // 统计失败的地址\n        const failedUrls = allResults.filter(result => result.status === 'rejected').length\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`)\n        }\n\n      } catch (error) {\n        console.error('采集失败:', error)\n        this.$message.error('采集失败：' + error.message)\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting()\n        }\n      } finally {\n        // 确保进度消息被关闭\n        if (progressMessage) {\n          progressMessage.close();\n        }\n      }\n    },\n\n    // 添加带重试机制的采集方法\n    async collectWithRetry(url, maxRetries = 3) {\n      let lastError\n      \n      for (let i = 0; i < maxRetries; i++) {\n        try {\n          const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n            method: 'GET',\n            headers: {\n              'Accept': 'text/plain'\n            },\n          })\n          \n          if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n          }\n          \n          const content = await response.text()\n          const newStreams = this.parseContent(content)\n          \n          // 根据采集模式过滤直播源\n          let filteredStreams = newStreams\n          if (this.collectForm.mode === 'tv') {\n            filteredStreams = newStreams.filter(s => {\n              // 处理央视频道\n              const isCCTV = /CCTV/i.test(s.name)\n              if (isCCTV) {\n                s.group = this.STANDARD_GROUPS.CCTV\n                const cctvNumber = this.extractCCTVNumber(s.name)\n                if (cctvNumber) {\n                  s.name = cctvNumber\n                }\n                return true\n              }\n              // 处理卫视频道\n              const isSatellite = /卫视/.test(s.name)\n              if (isSatellite) {\n                s.group = this.STANDARD_GROUPS.SATELLITE\n                return true\n              }\n              return false\n            })\n          }\n          \n          // 再次确保所有CCTV频道都在正确分组\n          filteredStreams.forEach(s => {\n            if (/CCTV/i.test(s.name)) {\n              s.group = this.STANDARD_GROUPS.CCTV\n            }\n          })\n          \n          return filteredStreams\n          \n        } catch (error) {\n          lastError = error\n          console.warn(`采集地址 ${url} 第 ${i + 1} 次尝试失败:`, error)\n          \n          if (i < maxRetries - 1) {\n            continue // 直接进行下一次重试，不等待\n          }\n        }\n      }\n      \n      // 所有重试都失败后抛出最后一次的错误\n      throw new Error(`采集失败 [${url}]: ${lastError.message}`)\n    },\n\n    // 修改提取CCTV频道号的方法\n    extractCCTVNumber(name) {\n      // 尝试直接匹配CCTV+数字的形式\n      const cctvMatch = name.match(/CCTV-?(\\d+)(\\+)?/i)\n      if (cctvMatch) {\n        const number = cctvMatch[1]\n        const plus = cctvMatch[2] || ''\n        return `CCTV${number}${plus}`\n      }\n\n      // 处理特殊频道名称（如CCTV5+）\n      if (/CCTV5\\+|CCTV5Plus|体育赛事/.test(name)) {\n        return 'CCTV5+'\n      }\n\n      // 如果无法提取频道号，保留原始CCTV名称\n      const cctvNameMatch = name.match(/CCTV[^a-z0-9]*([a-z0-9]+)/i)\n      if (cctvNameMatch) {\n        return `CCTV${cctvNameMatch[1]}`\n      }\n\n      // 如果都无法匹配，返回原始名称\n      return name\n    },\n\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n        \n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text()\n          const m3uLink = await m3uResponse.text()\n          \n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          }\n          this.generatedLink = this.generatedLinks[this.linkForm.format]\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error)\n        this.$message.error('生成链接失败')\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent()\n    },\n    // 添加自定义排序方法\n    customSort(streams, group) {\n      return streams.sort((a, b) => {\n        if (group === this.STANDARD_GROUPS.CCTV) {\n          // 提取CCTV频道号进行排序\n          const getNumber = (name) => {\n            const match = name.match(/CCTV-?(\\d+)(\\+)?/i)\n            if (match) {\n              return parseInt(match[1]) + (match[2] ? 0.5 : 0) // CCTV5+ 会排在 CCTV5 后面\n            }\n            // 特殊处理CCTV5+\n            if (/CCTV5\\+|CCTV5Plus|体育赛事/.test(name)) {\n              return 5.5\n            }\n            return 999 // 无法识别的排在最后\n          }\n          const numA = getNumber(a.name)\n          const numB = getNumber(b.name)\n          return numA - numB\n        } else if (group === this.STANDARD_GROUPS.SATELLITE) {\n          // 卫视按照拼音首字母排序\n          return a.name.localeCompare(b.name, 'zh-CN')\n        } else {\n          // 其他分组按照默认排序\n          return a.name.localeCompare(b.name)\n        }\n      })\n    },\n    generateTxtContent() {\n      let content = ''\n      const groupedStreams = {}\n      \n      // 首先整理所有流到对应的分组\n      this.mergedStreams.forEach(stream => {\n        const group = stream.group || '未分组'\n        if (!groupedStreams[group]) {\n          groupedStreams[group] = []\n        }\n        groupedStreams[group].push(stream)\n      })\n\n      // 优先处理央视和卫视分组\n      const orderedGroups = [\n        this.STANDARD_GROUPS.CCTV,\n        this.STANDARD_GROUPS.SATELLITE,\n        ...Object.keys(groupedStreams).filter(group => \n          group !== this.STANDARD_GROUPS.CCTV && \n          group !== this.STANDARD_GROUPS.SATELLITE\n        )\n      ]\n\n      // 按分组生成内容\n      orderedGroups.forEach(group => {\n        if (groupedStreams[group] && groupedStreams[group].length > 0) {\n          content += `${group},#genre#\\n`\n          // 使用自定义排序方法\n          this.customSort(groupedStreams[group], group)\n            .forEach(stream => {\n        content += `${stream.name},${stream.urls.join('#')}\\n`\n            })\n        }\n      })\n      \n      return content.trim()\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n'\n      const groupedStreams = {}\n      \n      // 首先整理所有流到对应的分组\n      this.mergedStreams.forEach(stream => {\n        const group = stream.group || '未分组'\n        if (!groupedStreams[group]) {\n          groupedStreams[group] = []\n        }\n        groupedStreams[group].push(stream)\n      })\n\n      // 优先处理央视和卫视分组\n      const orderedGroups = [\n        this.STANDARD_GROUPS.CCTV,\n        this.STANDARD_GROUPS.SATELLITE,\n        ...Object.keys(groupedStreams).filter(group => \n          group !== this.STANDARD_GROUPS.CCTV && \n          group !== this.STANDARD_GROUPS.SATELLITE\n        )\n      ]\n\n      // 按分组生成内容\n      orderedGroups.forEach(group => {\n        if (groupedStreams[group] && groupedStreams[group].length > 0) {\n          // 使用自定义排序方法\n          this.customSort(groupedStreams[group], group)\n            .forEach(stream => {\n        stream.urls.forEach(url => {\n                content += `#EXTINF:-1 group-title=\"${group}\",${stream.name}\\n${url}\\n`\n        })\n            })\n        }\n      })\n      \n      return content.trim()\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea')\n      textarea.value = this.generatedLink\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\n      \n      document.body.appendChild(link)\n      link.click()\n      \n      // 清理\n      window.URL.revokeObjectURL(url)\n      document.body.removeChild(link)\n      this.$message.success('文件下载成功')\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n      } catch (error) {\n        console.error('更新链接内容失败：', error)\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      } else {\n        this.scheduleDialogVisible = true\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false\n          this.isScheduled = true\n          this.setupSchedule()\n          this.saveState() // 保存状态\n          this.$message.success('定时检测已开启')\n        }\n      })\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      this.isScheduled = false\n      this.nextScheduleTime = null\n      this.saveState() // 保存状态\n      this.$message.success('定时检测已停止')\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n      }\n\n      const calculateNextExecutionTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck()\n          }\n          // 设置下一次执行\n          scheduleNextExecution()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextExecution()\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 清除旧的分块数据\n        this.clearStorageData()\n\n        // 只保存必要的数据字段，减少数据量\n        const minimalStreamList = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution || '',\n          responseTime: stream.responseTime || 0\n        }))\n\n        // 将streamList分块存储，减小分块大小\n        const streamListStr = JSON.stringify(minimalStreamList)\n        const chunkSize = 100000 // 减小到100KB\n        const chunks = Math.ceil(streamListStr.length / chunkSize)\n        \n        // 如果数据量太大，只保存基本信息\n        if (chunks > 10) {\n          console.warn('数据量过大，只保存基本状态信息')\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize,\n            scheduleForm: this.scheduleForm,\n            collectForm: this.collectForm\n          }\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n          return\n        }\n\n        // 分块存储\n        for (let i = 0; i < chunks; i++) {\n          const chunk = streamListStr.slice(i * chunkSize, (i + 1) * chunkSize)\n          try {\n            localStorage.setItem(`${this.stateKey}_streamList_${i}`, chunk)\n          } catch (e) {\n            console.error('存储分块失败:', e)\n            this.clearStorageData()\n            // 尝试只保存基本信息\n            const basicState = {\n              currentPage: this.currentPage,\n              pageSize: this.pageSize,\n              scheduleForm: this.scheduleForm,\n              collectForm: this.collectForm\n            }\n            localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n            return\n          }\n        }\n\n        // 存储其他状态数据\n        const state = {\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm,\n          streamListChunks: chunks\n        }\n        localStorage.setItem(this.stateKey, JSON.stringify(state))\n      } catch (error) {\n        console.error('保存状态失败:', error)\n        this.clearStorageData()\n        // 尝试只保存基本信息\n        try {\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize\n          }\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n        } catch (e) {\n          console.error('保存基本状态也失败:', e)\n        }\n      }\n    },\n\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey)\n        if (savedState) {\n          const state = JSON.parse(savedState)\n          \n          // 恢复streamList\n          if (state.streamListChunks) {\n            try {\n              let streamListStr = ''\n              for (let i = 0; i < state.streamListChunks; i++) {\n                const chunk = localStorage.getItem(`${this.stateKey}_streamList_${i}`)\n                if (chunk) {\n                  streamListStr += chunk\n                }\n              }\n              if (streamListStr) {\n                this.streamList = JSON.parse(streamListStr)\n              }\n            } catch (e) {\n              console.error('恢复streamList失败:', e)\n              this.streamList = []\n            }\n          }\n          \n          // 恢复其他状态\n          this.currentPage = state.currentPage || 1\n          this.pageSize = state.pageSize || 5\n          if (state.scheduleForm) this.scheduleForm = state.scheduleForm\n          if (state.collectForm) this.collectForm = state.collectForm\n        }\n\n        // 重置所有运行状态\n        this.isChecking = false\n        this.isPaused = false\n        this.isScheduled = false\n        this.isCollecting = false\n        this.checkedCount = 0\n        this.totalCount = 0\n        this.pausedIndex = -1\n        this.nextScheduleTime = null\n      } catch (error) {\n        console.error('恢复状态失败:', error)\n        this.clearStorageData()\n        this.streamList = []\n      }\n    },\n\n    // 清理存储数据\n    clearStorageData() {\n      try {\n        localStorage.removeItem(this.stateKey)\n        for (let i = 0; ; i++) {\n          const key = `${this.stateKey}_streamList_${i}`\n          if (localStorage.getItem(key) === null) {\n            break\n          }\n          localStorage.removeItem(key)\n        }\n      } catch (error) {\n        console.error('清理存储数据失败:', error)\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      }\n      \n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting()\n      }\n      \n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n      }\n      \n      // 重置所有状态\n      this.isChecking = false\n      this.isPaused = false\n      this.isScheduled = false\n      this.isCollecting = false\n      this.checkedCount = 0\n      this.totalCount = 0\n      this.pausedIndex = -1\n      this.nextScheduleTime = null\n      \n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      \n      // 保存重置后的状态\n      this.saveState()\n      \n      this.$message.success('所有运行状态已重置')\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\n      \n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？'\n        e.preventDefault()\n        e.returnValue = message\n        return message\n      }\n    },\n    addCollectUrl() {\n      const newIndex = this.collectForm.urls.length\n        this.collectForm.urls.push('')\n      // 初始化新URL的状态\n      this.$set(this.collectForm.urlStatus, newIndex, {\n        isChecking: false,\n        isAccessible: null\n      })\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1)\n        \n        // 重新排序urlStatus\n        const newUrlStatus = {}\n        Object.keys(this.collectForm.urlStatus || {})\n          .filter(key => parseInt(key) !== index)\n          .forEach((key, i) => {\n            newUrlStatus[i] = this.collectForm.urlStatus[key]\n          })\n        this.collectForm.urlStatus = newUrlStatus\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '-') return 'info'\n      if (resolution === '多播源') return 'warning'  // 为多播源添加特殊样式\n      const [width] = resolution.split('x').map(Number)\n      if (width >= 1920) return 'success'\n      if (width >= 1280) return ''  // 默认类型\n      return 'warning'\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime || responseTime === '-') return 'info'\n      const time = Number(responseTime)\n      if (time <= 1000) return 'success'\n      if (time <= 2000) return ''  // 默认类型\n      if (time <= 3000) return 'warning'\n      return 'danger'\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n      }\n\n      const calculateNextCollectTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect()\n          // 设置下一次执行\n          scheduleNextCollection()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextCollection()\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        // 对CCTV频道进行精确匹配\n        if (this.searchForm.name && /^cctv\\d*$/i.test(this.searchForm.name)) {\n          const searchPattern = new RegExp(`^${this.searchForm.name}[\\\\s-]*$`, 'i');\n          const nameMatch = searchPattern.test(item.name.toLowerCase().replace(/[^a-z0-9]/gi, ''));\n          const groupMatch = !this.searchForm.group || item.group === this.searchForm.group;\n          const statusMatch = !this.searchForm.status || item.status === this.searchForm.status;\n          return nameMatch && groupMatch && statusMatch;\n        }\n        \n        // 对其他搜索使用常规匹配\n        const nameMatch = !this.searchForm.name || \n          item.name.toLowerCase().includes(this.searchForm.name.toLowerCase());\n        const groupMatch = !this.searchForm.group || \n          item.group === this.searchForm.group;\n        const statusMatch = !this.searchForm.status || \n          item.status === this.searchForm.status;\n        \n        return nameMatch && groupMatch && statusMatch;\n      });\n      \n      // 重置到第一页\n      this.currentPage = 1;\n      this.searchDialogVisible = false;\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      }\n      this.filteredList = []\n      this.currentPage = 1\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`)\n        if (response.ok) {\n          const data = await response.json()\n          this.realIp = data.ip\n          localStorage.setItem('realIp', data.ip)  // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error)\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      // 在生产环境中使用相对路径\n      if (process.env.NODE_ENV === 'production') {\n        return ''  // 返回空字符串，这样会使用相对路径\n      }\n      // 在开发环境中使用配置的服务器IP\n      const serverIp = localStorage.getItem('serverIp')\n      if (serverIp) {\n        return `http://${serverIp}:8080`\n      }\n      return 'http://localhost:8080'\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate()\n\n        // 保存设置到localStorage\n        localStorage.setItem('githubToken', this.syncForm.token)\n        localStorage.setItem('githubRepo', this.syncForm.repo)\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath)\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath)\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync)\n        localStorage.setItem('githubSyncType', this.syncForm.syncType)\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime)\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay)\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule()\n        } else {\n          this.clearSyncSchedule()\n        }\n\n        this.$message.success('设置已保存')\n        this.syncDialogVisible = false\n      } catch (error) {\n        this.$message.error(error.message || '保存失败')\n      }\n    },\n    async syncToGithub(content, path) {\n      try {\n        // 首先获取文件的SHA\n        const getResponse = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${path}`, {\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`\n          }\n        })\n\n        if (!getResponse.ok) {\n          throw new Error(`获取文件信息失败: ${getResponse.status} ${getResponse.statusText}`)\n        }\n\n        const fileInfo = await getResponse.json()\n        const sha = fileInfo.sha\n\n        // 将内容转换为UTF-8编码的Base64\n        const base64Content = btoa(unescape(encodeURIComponent(content)))\n\n        // 更新文件内容\n        const updateResponse = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${path}`, {\n          method: 'PUT',\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            message: this.syncForm.message || '更新直播源列表',\n            content: base64Content,\n            sha: sha\n          })\n        })\n\n        if (!updateResponse.ok) {\n          throw new Error(`更新文件失败: ${updateResponse.status} ${updateResponse.statusText}`)\n        }\n\n        return await updateResponse.json()\n      } catch (error) {\n        console.error('同步到GitHub失败:', error)\n        throw new Error('同步失败: ' + error.message)\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule()\n      } else {\n        this.clearSyncSchedule()\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule()\n      const calculateNextSyncTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(async () => {\n          try {\n            // 执行同步\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath)\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath)\n            this.$message.success('已同步到GitHub')\n          } catch (error) {\n            this.$message.error('同步失败：' + error.message)\n          }\n          // 设置下一次执行\n          scheduleNextSync()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextSync()\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer)\n        this.syncTimer = null\n      }\n    },\n    getStatusTagType(status) {\n      switch (status) {\n        case '正常':\n          return 'success'\n        case '异常':\n          return 'danger'\n        case '未知':\n          return 'warning'\n        case '未检测':\n          return 'info'\n        default:\n          return 'info'\n      }\n    },\n    // 修改显示消息的方法\n    showMessage(content) {\n      // 如果是清除直播源的消息，使用新的消息系统\n      if (content.includes('已自动清除直播源') || content.includes('(')) {\n        const id = this.messageId++\n        const message = {\n          id,\n          content: content.includes('(') ? content : content.replace('已自动清除直播源：', '')\n        }\n        this.messages.push(message)\n        \n        // 3秒后自动移除消息\n        setTimeout(() => {\n          this.removeMessage(id)\n        }, 3000)\n        \n        // 最多显示3条消息\n        if (this.messages.length > 3) {\n          this.messages.shift()\n        }\n      } else {\n        // 其他消息使用 Element UI 的消息提示\n        this.$message.info(content)\n      }\n    },\n    \n    // 移除消息\n    removeMessage(id) {\n      const index = this.messages.findIndex(msg => msg.id === id)\n      if (index !== -1) {\n        this.messages.splice(index, 1)\n      }\n    },\n    // 修改清除直播源的提示\n    handleStreamRemoval(stream, reason) {\n      this.showMessage(`${stream.name} (${reason})`)\n    },\n    async checkUrlAccessibility() {\n      if (!this.importUrlForm.url) return\n      \n      this.importUrlForm.isChecking = true\n      this.importUrlForm.isAccessible = null\n      \n      try {\n        // 添加延迟，避免频繁请求\n        await new Promise(resolve => setTimeout(resolve, 500))\n        \n        const baseUrl = process.env.VUE_APP_API_URL || ''  // 从环境变量获取API基础URL\n        const response = await fetch(`${baseUrl}/api/check-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importUrlForm.url\n          })\n        })\n        \n        if (!response.ok) throw new Error('请求失败')\n        const result = await response.json()\n        this.importUrlForm.isAccessible = result.accessible\n      } catch (error) {\n        console.error('检查链接可达性失败:', error)\n        this.importUrlForm.isAccessible = false\n      } finally {\n        this.importUrlForm.isChecking = false\n      }\n    },\n    async handleImportUrl() {\n      if (!this.importUrlForm.url) {\n        this.$message.warning('请输入文件链接')\n        return\n      }\n\n      // 如果链接未经过检测或检测失败，先进行检测\n      if (this.importUrlForm.isAccessible === null || this.importUrlForm.isAccessible === false) {\n        await this.checkUrlAccessibility()\n        if (!this.importUrlForm.isAccessible) {\n          return\n        }\n      }\n\n      try {\n        // 获取文件内容\n        const response = await fetch(this.importUrlForm.url)\n        if (!response.ok) throw new Error('获取文件失败')\n        \n        const content = await response.text()\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 提取URL列表并过滤重复项\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            // 批量添加到列表\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            this.importUrlDialogVisible = false\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        console.error('导入失败:', error)\n        this.$message.error('导入失败: ' + error.message)\n      } finally {\n        this.importUrlForm.isChecking = false\n      }\n    },\n    getPlaceholderText() {\n      switch (this.collectForm.mode) {\n        case 'tv':\n          return '请输入包含央视或卫视频道的网络地址'\n        default:\n          return '请输入需要采集的网络地址'\n      }\n    },\n    async handleCollectUrlsFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        // 按行分割并过滤空行\n        const urls = content.split('\\n')\n          .map(line => line.trim())\n          .filter(line => line && line.length > 0)\n        \n        if (urls.length === 0) {\n          this.$message.warning('文件中未找到有效的URL地址')\n          return\n        }\n\n        // 验证URL格式\n        const invalidUrls = urls.filter(url => !/^https?:\\/\\/.+/.test(url))\n        if (invalidUrls.length > 0) {\n          this.$message.warning(`发现 ${invalidUrls.length} 个无效的URL地址`)\n          return\n        }\n\n        // 初始化状态对象\n        const urlStatus = {}\n        urls.forEach((_, index) => {\n          urlStatus[index] = {\n            isChecking: false,\n            isAccessible: null\n          }\n        })\n        \n        // 使用Vue的响应式更新\n        this.$set(this.collectForm, 'urls', urls)\n        this.$set(this.collectForm, 'urlStatus', urlStatus)\n        \n        // 手动触发每个URL的检测\n        this.$nextTick(() => {\n          urls.forEach((url, index) => {\n            this.checkCollectUrlAccessibility(url, index)\n          })\n        })\n\n        this.$message.success(`成功导入 ${urls.length} 个采集地址`)\n      } catch (error) {\n        this.$message.error('读取文件失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    async checkCollectUrlAccessibility(url, index) {\n      if (!url) {\n        console.warn('URL为空，跳过检测')\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: null,\n          error: '地址为空'\n        })\n        return\n      }\n\n      // 标准化URL格式\n      let normalizedUrl = url\n      if (!url.toLowerCase().startsWith('http')) {\n        normalizedUrl = 'http://' + url\n      }\n      \n      console.log(`开始检测URL (${index}):`, normalizedUrl)\n      \n      // 设置检查状态\n      this.$set(this.collectForm.urlStatus, index, {\n        isChecking: true,\n        isAccessible: null,\n        error: null\n      })\n      \n      try {\n        // 添加延迟，避免频繁请求\n        await new Promise(resolve => setTimeout(resolve, 500))\n        \n        const response = await fetch(`${this.getBaseUrl()}/api/check-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: normalizedUrl })\n        })\n        \n        if (!response.ok) {\n          throw new Error(`HTTP错误: ${response.status}`)\n        }\n\n        const result = await response.json()\n        console.log(`URL (${index}) 检测结果:`, result)\n        \n        // 更新状态\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: result.accessible,\n          statusCode: result.statusCode,\n          error: result.error\n        })\n\n        // 如果检测失败，记录错误信息\n        if (!result.accessible) {\n          console.warn(`URL (${index}) 不可访问:`, result.error || '未知错误')\n        }\n      } catch (error) {\n        console.error(`URL (${index}) 检测失败:`, error)\n        this.$set(this.collectForm.urlStatus, index, {\n          isChecking: false,\n          isAccessible: false,\n          error: error.message || '检测失败'\n        })\n      }\n    },\n    clearCollectUrls() {\n      this.$confirm('确认清空所有采集地址吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 重置采集地址列表\n        this.$set(this.collectForm, 'urls', [''])\n        // 重置状态对象\n        this.$set(this.collectForm, 'urlStatus', {\n          0: {\n            isChecking: false,\n            isAccessible: null\n          }\n        })\n        this.$message.success('已清空采集地址')\n      }).catch(() => {\n        // 用户取消操作\n      })\n    },\n    async importFromGithub() {\n      if (!this.syncForm.token || !this.syncForm.repo || !this.syncForm.txtPath) {\n        this.$message.warning('请先配置GitHub同步设置')\n        return\n      }\n\n      this.$message.info('正在从GitHub导入...')\n      try {\n        // 使用GitHub API获取文件内容\n        const response = await fetch(`https://api.github.com/repos/${this.syncForm.repo}/contents/${this.syncForm.txtPath}`, {\n          headers: {\n            'Authorization': `token ${this.syncForm.token}`,\n            'Accept': 'application/vnd.github.v3.raw'\n          }\n        })\n\n        if (!response.ok) {\n          throw new Error(`GitHub API请求失败: ${response.status} ${response.statusText}`)\n        }\n\n        const content = await response.text()\n        if (!content) {\n          throw new Error('获取到的内容为空')\n        }\n\n        // 解析内容\n        const lines = content.split('\\n')\n        const newStreams = []\n        let currentGroup = '未分组'\n        let currentStream = null\n\n        for (const line of lines) {\n          const trimmedLine = line.trim()\n          if (!trimmedLine || trimmedLine.startsWith('#')) continue\n\n          if (trimmedLine.startsWith('[')) {\n            // 这是一个分组\n            currentGroup = trimmedLine.replace(/[[\\]]/g, '').trim()\n          } else if (trimmedLine.includes(',')) {\n            // 这是一个直播源\n            const [name, url] = trimmedLine.split(',').map(s => s.trim())\n            if (name && url) {\n              currentStream = {\n                name,\n                url,\n                group: currentGroup,\n                status: '待检测',\n                resolution: '',\n                responseTime: 0,\n                lastCheck: '',\n                isSelected: false\n              }\n              newStreams.push(currentStream)\n            }\n          }\n        }\n\n        if (newStreams.length === 0) {\n          throw new Error('未找到有效的直播源')\n        }\n\n        // 更新列表\n        this.streamList = newStreams\n        this.filteredList = [...newStreams]\n        this.currentPage = 1\n        this.total = newStreams.length\n\n        // 保存到localStorage\n        localStorage.setItem('streamList', JSON.stringify(newStreams))\n        localStorage.setItem('filteredList', JSON.stringify(newStreams))\n\n        this.$message.success(`成功导入 ${newStreams.length} 个直播源`)\n        this.importDialogVisible = false\n      } catch (error) {\n        console.error('导入失败:', error)\n        this.$message.error('导入失败: ' + error.message)\n      }\n    },\n    async checkIpv6(stream) {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-ipv6`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: stream.url })\n        })\n        \n        if (!response.ok) throw new Error('请求失败')\n        \n        const result = await response.json()\n        if (result.success) {\n          stream.ipv6 = result.ipv6\n          stream.ipv6Checked = true\n        } else {\n          throw new Error(result.message)\n        }\n      } catch (error) {\n        console.error('检查IPv6失败:', error)\n        stream.ipv6Checked = true\n        stream.ipv6 = false\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent()\n        this.saveState()\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState()\n    },\n    pageSize() {\n      this.saveState()\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus()\n    },\n    isCollecting() {\n      this.updateActiveStatus()\n    },\n    isScheduled() {\n      this.updateActiveStatus()\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink()\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果有采集任务，且不是从其他页面切换回来，才恢复采集\n    if (this.isCollecting && !this.isPageSwitching) {\n      this.startCollecting(true)\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule()\n    }\n    // 重置页面切换标志\n    this.isPageSwitching = false\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 设置页面切换标志\n    this.isPageSwitching = true\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer)\n      this.scheduleTimer = null\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n      this.collectTimer = null\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer)\n      this.syncTimer = null\n    }\n  }\n}\n</script>\n\n<style scoped>\n.stream-check {\n  padding: 25px;\n  background-color: #fff;\n  border-radius: 4px;\n  height: calc(100vh - 130px);\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative;\n}\n\n.table-operations {\n  margin-bottom: 20px;\n  flex-shrink: 0;\n}\n\n.button-groups {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 10px;\n  align-items: center;\n}\n\n.button-group {\n  display: flex;\n  align-items: center;\n}\n\n/* 确保按钮组在小屏幕上不会被压缩 */\n:deep(.el-button-group) {\n  white-space: nowrap;\n  margin: 0;\n}\n\n/* 确保按钮内容不会换行 */\n:deep(.el-button) {\n  white-space: nowrap;\n}\n\n/* 在较小屏幕上调整按钮大小 */\n@media screen and (max-width: 768px) {\n  :deep(.el-button) {\n    padding: 8px 15px;\n    font-size: 12px;\n  }\n  \n  :deep(.el-button [class*=\"el-icon-\"]) {\n    font-size: 14px;\n  }\n}\n\n/* 在更小的屏幕上进一步调整 */\n@media screen and (max-width: 576px) {\n  .button-groups {\n    gap: 5px;\n  }\n  \n  :deep(.el-button) {\n    padding: 6px 10px;\n    font-size: 12px;\n  }\n}\n\n/* 添加表格容器样式 */\n.el-table-wrapper {\n  flex: 1;\n  position: relative; /* 添加相对定位 */\n  min-height: 200px; /* 设置最小高度 */\n}\n\n/* 覆盖 element-ui 的表格样式 */\n:deep(.el-table) {\n  position: absolute; /* 绝对定位 */\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 100%;\n  max-height: 100%;\n}\n\n:deep(.el-table__body-wrapper) {\n  height: calc(100% - 40px) !important; /* 减去表头高度 */\n  overflow-y: auto !important;\n}\n\n:deep(.el-table__fixed-right) {\n  height: 100% !important; /* 修复固定列的高度 */\n  bottom: 0px;\n}\n\n:deep(.el-table__fixed-right .el-table__fixed-body-wrapper) {\n  height: calc(100% - 40px) !important; /* 减去表头高度 */\n}\n\n.pagination-container {\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n  flex-shrink: 0; /* 防止分页被压缩 */\n  padding-bottom: 10px; /* 添加底部间距 */\n  background-color: #fff; /* 确保分页器背景色 */\n  position: relative; /* 添加相对定位 */\n  z-index: 1; /* 确保分页器在最上层 */\n}\n\n.el-button [class*=\"el-icon-\"] {\n  font-size: 18px;\n}\n\n.delete-btn {\n  color: #F56C6C;\n}\n\n.delete-btn:hover {\n  color: #ff4d4d;\n}\n\n.setting-tip {\n  margin-left: 10px;\n  color: #909399;\n  font-size: 13px;\n}\n\n.link-info {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.link-info p {\n  margin: 0;\n  color: #606266;\n}\n\n.link-actions {\n  display: flex;\n  gap: 10px;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n/* 生成链接对话框样式 */\n.generate-link-dialog {\n  max-width: 600px;\n}\n\n.link-container {\n  display: flex;\n  flex-direction: column;\n  gap: 15px;\n}\n\n.link-card, .tips-card {\n  margin: 0;\n  border: 1px solid #EBEEF5;\n}\n\n.link-content {\n  padding: 10px;\n}\n\n.tips-content {\n  color: #606266;\n  font-size: 14px;\n  padding: 10px;\n}\n\n.tips-content ul {\n  margin: 0;\n  padding-left: 20px;\n  line-height: 1.8;\n}\n\n/* 覆盖 element-ui 的一些默认样式 */\n:deep(.el-dialog__body) {\n  padding: 20px;\n}\n\n:deep(.el-card__header) {\n  padding: 12px 20px;\n  font-weight: 500;\n}\n\n:deep(.el-card__body) {\n  padding: 15px;\n}\n\n/* 可以添加一些自定义样式 */\n.el-tag {\n  width: 90px;  /* 统一标签宽度 */\n}\n\n.el-tag + .el-tag {\n  margin-left: 4px;\n}\n\n/* 修改消息面板样式 */\n.message-panel {\n  position: fixed;\n  bottom: 20px;\n  right: 20px;\n  width: 300px;\n  z-index: 9999;\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.3s;\n}\n\n.message-panel.has-messages {\n  opacity: 1;\n}\n\n.message-item {\n  background: rgba(64, 158, 255, 0.95);\n  color: white;\n  border-radius: 4px;\n  padding: 10px 15px;\n  margin-bottom: 8px;\n  box-shadow: 0 2px 12px 0 rgba(0,0,0,.1);\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n  transition: all 0.3s;\n}\n\n.message-item i {\n  margin-right: 8px;\n  font-size: 16px;\n}\n\n.message-content {\n  flex: 1;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n/* 消息动画 */\n.message-list-enter-active, .message-list-leave-active {\n  transition: all 0.3s;\n}\n\n.message-list-enter {\n  transform: translateY(100%);\n  opacity: 0;\n}\n\n.message-list-leave-to {\n  transform: translateX(100%);\n  opacity: 0;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
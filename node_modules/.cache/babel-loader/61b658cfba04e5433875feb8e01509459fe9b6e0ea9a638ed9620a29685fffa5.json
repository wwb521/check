{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importForm: {\n        url: '',\n        group: ''\n      },\n      importRules: {\n        url: [{\n          required: true,\n          message: '请输入URL地址',\n          trigger: 'blur'\n        }, {\n          type: 'url',\n          message: '请输入正确的URL地址',\n          trigger: 'blur'\n        }],\n        group: [{\n          required: true,\n          message: '请选择分组',\n          trigger: 'change'\n        }]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        autoCollect: false,\n        interval: 30\n      },\n      collectRules: {\n        urls: [{\n          type: 'array',\n          validator: (rule, value, callback) => {\n            if (value.length === 0) {\n              callback(new Error('请至少添加一个采集地址'));\n            }\n            // 验证每个URL\n            const errors = value.map(url => {\n              if (!url) return '采集地址不能为空';\n              if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址';\n              return null;\n            }).filter(error => error !== null);\n            if (errors.length > 0) {\n              callback(new Error(errors[0]));\n            } else {\n              callback();\n            }\n          },\n          trigger: 'change'\n        }]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',\n      // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        interval: 30,\n        unit: 'minute'\n      },\n      scheduleRules: {\n        interval: [{\n          required: true,\n          message: '请设置检测间隔',\n          trigger: 'change'\n        }, {\n          validator: (rule, value, callback) => {\n            if (this.scheduleForm.unit === 'second') {\n              if (value < 10 || value > 59) {\n                callback(new Error('秒数必须在10到59之间'));\n              }\n            } else {\n              if (value < 1 || value > 7980) {\n                callback(new Error('分钟数必须在1到7980之间'));\n              }\n            }\n            callback();\n          },\n          trigger: 'change'\n        }]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState',\n      // 用于本地存储的key\n      hasActiveOperations: false // 添加标记表示是否有动作在执行\n    };\n  },\n  computed: {\n    paginatedData() {\n      const start = (this.currentPage - 1) * this.pageSize;\n      const end = start + this.pageSize;\n      return this.streamList.slice(start, end);\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测';\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`;\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map();\n\n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name; // 使用名称作为键\n\n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key);\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url);\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          });\n        }\n      });\n\n      // 转换回数组格式\n      return Array.from(streamMap.values());\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList');\n      if (savedList) {\n        this.streamList = JSON.parse(savedList);\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList);\n\n    // 从本地存储恢复状态\n    this.restoreState();\n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true); // true表示是恢复状态\n    }\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList);\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck();\n    // 在组件销毁前保存状态\n    this.saveState();\n    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n  },\n  methods: {\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath');\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径');\n        return false;\n      }\n      try {\n        const response = await fetch('http://localhost:8080/api/check-stream', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n\n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常';\n        stream.resolution = result.resolution || '';\n        stream.responseTime = result.responseTime || 0;\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = '';\n          if (stream.status === '异常') {\n            reason = '异常源';\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢';\n          } else {\n            reason = '分辨率过低';\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData;\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream);\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`);\n          }\n        }\n        this.saveStreamList();\n        return result.available;\n      } catch (error) {\n        console.error('检测错误:', error);\n        stream.status = '异常';\n        return false;\n      }\n    },\n    async handleBatchCheck() {\n      if (this.isPaused) {\n        this.resumeCheck();\n        return;\n      }\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表为空');\n        return;\n      }\n      this.isChecking = true;\n      this.isPaused = false;\n      this.shouldStop = false;\n      this.checkedCount = 0;\n      this.totalCount = this.streamList.length;\n      await this.batchCheck(0);\n    },\n    async batchCheck(startIndex) {\n      let successCount = 0;\n      let failCount = 0;\n      const validStreams = [];\n      for (let i = startIndex; i < this.streamList.length; i++) {\n        if (this.shouldStop) {\n          this.pausedIndex = i;\n          this.isPaused = true;\n          this.isChecking = false;\n          return;\n        }\n        const stream = this.streamList[i];\n        try {\n          const response = await fetch('http://localhost:8080/api/check-stream', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              url: stream.url,\n              ffprobePath: localStorage.getItem('ffprobePath')\n            })\n          });\n          if (!response.ok) throw new Error('请求失败');\n          const result = await response.json();\n\n          // 更新流信息\n          stream.status = result.available ? '正常' : '异常';\n          stream.resolution = result.resolution || '';\n          stream.responseTime = result.responseTime || 0;\n          if (result.available) {\n            successCount++;\n          } else {\n            failCount++;\n          }\n\n          // 根据设置决定是否保留该项\n          if (!this.shouldRemoveStream(stream)) {\n            validStreams.push(stream);\n          }\n        } catch (error) {\n          console.error('检测错误:', error);\n          stream.status = '异常';\n          failCount++;\n\n          // 如果不自动清除异常源，则保留该项\n          if (!localStorage.getItem('autoRemoveInvalid') === 'true') {\n            validStreams.push(stream);\n          }\n        }\n        this.checkedCount++;\n      }\n\n      // 如果检测完成（不是暂停状态）\n      if (!this.shouldStop) {\n        // 批量更新列表\n        this.streamList = validStreams;\n\n        // 更新分页\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n\n        // 保存更新后的列表\n        this.saveStreamList();\n        this.isChecking = false;\n        this.isPaused = false;\n        this.pausedIndex = -1;\n        this.$message.success(`检测完成: ${successCount}个正常, ${failCount}个异常`);\n      }\n    },\n    pauseCheck() {\n      this.shouldStop = true;\n    },\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true;\n        this.isPaused = false;\n        this.shouldStop = false;\n        await this.batchCheck(this.pausedIndex);\n      }\n    },\n    async handleCheck(row) {\n      row.status = '检测中';\n      const success = await this.checkStream(row);\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`);\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row);\n        this.streamList.splice(index, 1);\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('删除成功');\n      }).catch(() => {});\n    },\n    async handleUrlImport() {\n      if (!this.importForm.url) {\n        this.$message.warning('请输入URL地址');\n        return;\n      }\n      this.loading = true;\n      try {\n        const response = await fetch(this.importForm.url);\n        if (!response.ok) throw new Error('网络请求失败');\n        const content = await response.text();\n        const streams = this.parseContent(content);\n        this.addStreamsToList(streams);\n        this.importUrlDialogVisible = false;\n        this.$message.success('网络文件导入成功');\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message);\n      } finally {\n        this.loading = false;\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      // 将内容按行分割\n      const lines = content.split(/\\r?\\n/).filter(line => line.trim());\n      const streams = [];\n\n      // 解析m3u格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = '';\n        lines.forEach(line => {\n          if (line.startsWith('#EXTINF:')) {\n            // 提取频道名称\n            currentName = line.split(',')[1]?.trim() || '';\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL\n            streams.push({\n              name: currentName || `未命名频道${streams.length + 1}`,\n              url: line.trim(),\n              resolution: '',\n              responseTime: 0,\n              status: '未检测',\n              group: '未分组'\n            });\n            currentName = '';\n          }\n        });\n      } else {\n        // 解析txt格式\n        let currentGroup = '未分组';\n        lines.forEach(line => {\n          const trimmedLine = line.trim();\n\n          // 检查是否是分组标签\n          if (trimmedLine.includes('#genre#')) {\n            currentGroup = trimmedLine.split(',')[0].trim();\n            return;\n          }\n\n          // 跳过其他#开头的行和空行\n          if (trimmedLine.startsWith('#') || !trimmedLine) {\n            return;\n          }\n\n          // 处理实际的直播源行\n          if (trimmedLine.includes(',')) {\n            // 如果行包含逗号，假设格式为：名称,URL\n            const parts = trimmedLine.split(',');\n            // 取最后一个部分作为URL，其余部分作为名称\n            const url = parts.pop().trim();\n            const name = parts.join(',').trim();\n            if (url && !url.startsWith('#')) {\n              // 确保URL存在且不是注释\n              streams.push({\n                name: name || `未命名频道${streams.length + 1}`,\n                url: url,\n                resolution: '',\n                responseTime: 0,\n                status: '未检测',\n                group: currentGroup\n              });\n            }\n          } else {\n            // 如果行不包含逗号且不是注释，则整行作为URL\n            streams.push({\n              name: `未命名频道${streams.length + 1}`,\n              url: trimmedLine,\n              resolution: '',\n              responseTime: 0,\n              status: '未检测',\n              group: currentGroup\n            });\n          }\n        });\n      }\n      return streams;\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream);\n      });\n      this.currentPage = 1;\n      this.saveStreamList(); // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        this.loading = true;\n        const content = await this.readFile(file);\n        const streams = this.parseContent(content);\n        this.addStreamsToList(streams);\n        this.$message.success('文件导入成功');\n      } catch (error) {\n        this.$message.error('文件导入失败：' + error.message);\n      } finally {\n        this.loading = false;\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (name.includes('cctv')) return 'CCTV';\n      if (name.includes('卫视')) return '卫视';\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空');\n        return;\n      }\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = [];\n        this.currentPage = 1;\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('列表已清空');\n      }).catch(() => {});\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && stream.status === '异常') {\n        return true;\n      }\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number);\n        if (width < 1280 || height < 720) {\n          return true;\n        }\n      }\n\n      // 添加新的检查：响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && stream.responseTime > 3000) {\n        return true;\n      }\n      return false;\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 正常启动时才验证表单\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState(); // 保存状态\n\n      // 立即执行一次采集\n      if (!isRestore) {\n        await this.collect();\n      }\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.collectTimer = setInterval(async () => {\n          await this.collect();\n        }, this.collectForm.interval * 60 * 1000);\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      this.$message.success('已停止采集');\n    },\n    async collect() {\n      try {\n        this.$message.info('开始采集直播源...');\n        const response = await fetch(this.collectForm.urls[0]);\n        if (!response.ok) throw new Error('网络请求失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n\n        // 过滤出新的直播源\n        const existingUrls = new Set(this.streamList.map(s => s.url));\n        const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n        if (uniqueStreams.length > 0) {\n          this.addStreamsToList(uniqueStreams);\n          this.$message.success(`采集成功: 新增${uniqueStreams.length}个直播源`);\n        } else {\n          this.$message.info('未发现新的直播源');\n        }\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message);\n        // 如果是单次采集模式，出错时停止采集\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      }\n    },\n    async handleGenerateLink() {\n      try {\n        this.generateLinkDialogVisible = true;\n\n        // 生成内容\n        const content = this.generateContent();\n\n        // 创建或更新链接内容\n        const response = await fetch('http://localhost:8080/api/generate-link', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        });\n        if (!response.ok) {\n          throw new Error('生成链接失败');\n        }\n\n        // 使用返回的固定链接\n        this.generatedLink = await response.text();\n      } catch (error) {\n        this.$message.error('生成链接失败：' + error.message);\n      }\n    },\n    generateContent() {\n      let content = '';\n      let currentGroup = '';\n\n      // 按组生成内容\n      this.mergedStreams.forEach(stream => {\n        // 如果组发生变化，添加组标记\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `${currentGroup},#genre#\\n`;\n        }\n\n        // 合并相同名称的链接，用#连接\n        content += `${stream.name},${stream.urls.join('#')}\\n`;\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        const content = this.generateContent();\n        await fetch('http://localhost:8080/api/update-content', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n\n      // 计算检查间隔（转换为毫秒）\n      const interval = this.scheduleForm.unit === 'second' ? this.scheduleForm.interval * 1000 : this.scheduleForm.interval * 60 * 1000;\n\n      // 设置下次执行时间\n      this.nextScheduleTime = new Date(Date.now() + interval);\n\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000;\n      this.scheduleTimer = setInterval(() => {\n        const now = new Date();\n\n        // 如果当前正在检测中，跳过这次执行\n        if (this.isChecking) {\n          return;\n        }\n\n        // 检查是否到达执行时间\n        if (now >= this.nextScheduleTime) {\n          this.handleBatchCheck();\n          // 更新下次执行时间\n          this.nextScheduleTime = new Date(Date.now() + interval);\n        }\n      }, checkInterval);\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      // 只保存基础数据和设置，不保存运行状态\n      const state = {\n        streamList: this.streamList,\n        currentPage: this.currentPage,\n        pageSize: this.pageSize,\n        scheduleForm: this.scheduleForm,\n        collectForm: this.collectForm\n      };\n      localStorage.setItem(this.stateKey, JSON.stringify(state));\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 只恢复基础数据和设置\n          this.streamList = state.streamList || [];\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          this.scheduleForm = state.scheduleForm || this.scheduleForm;\n          this.collectForm = state.collectForm || this.collectForm;\n\n          // 重置所有运行状态\n          this.isChecking = false;\n          this.isPaused = false;\n          this.isScheduled = false;\n          this.isCollecting = false;\n          this.checkedCount = 0;\n          this.totalCount = 0;\n          this.pausedIndex = -1;\n          this.nextScheduleTime = null;\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error);\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true);\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","loading","streamList","importUrlDialogVisible","importForm","url","group","importRules","required","message","trigger","type","currentPage","pageSize","isChecking","isPaused","checkedCount","totalCount","pausedIndex","shouldStop","isCollecting","collectDialogVisible","collectForm","urls","autoCollect","interval","collectRules","validator","rule","value","callback","length","Error","errors","map","test","filter","error","collectTimer","generateLinkDialogVisible","generatedLink","previewContent","currentLinkId","scheduleDialogVisible","isScheduled","scheduleForm","unit","scheduleRules","scheduleTimer","nextScheduleTime","stateKey","hasActiveOperations","computed","paginatedData","start","end","slice","checkButtonText","mergedStreams","streamMap","Map","forEach","stream","key","has","existing","get","includes","push","set","Array","from","values","created","localStorage","getItem","savedList","JSON","parse","$root","$on","saveStreamList","restoreState","setupSchedule","startCollecting","beforeDestroy","$off","clearInterval","stopScheduleCheck","saveState","window","removeEventListener","handleBeforeUnload","methods","checkStream","ffprobePath","$message","response","fetch","method","headers","body","stringify","ok","result","json","status","available","resolution","responseTime","shouldRemoveStream","reason","currentPageItems","pageIndex","indexOf","listIndex","splice","warning","console","handleBatchCheck","resumeCheck","batchCheck","startIndex","successCount","failCount","validStreams","i","maxPage","Math","ceil","max","success","pauseCheck","handleCheck","row","handleDelete","$confirm","confirmButtonText","cancelButtonText","then","index","catch","handleUrlImport","content","text","streams","parseContent","addStreamsToList","readFile","file","Promise","resolve","reject","reader","FileReader","onload","e","target","onerror","readAsText","lines","split","line","trim","currentName","startsWith","currentGroup","trimmedLine","parts","pop","join","handleSizeChange","val","handleCurrentChange","handleFileUpload","event","files","getGroupFromFileName","filename","toLowerCase","handleClearList","handleCopy","textarea","document","createElement","appendChild","select","execCommand","err","removeChild","width","height","Number","setItem","handleCollectMode","stopCollecting","isRestore","valid","$refs","validate","collect","setInterval","info","newStreams","existingUrls","Set","s","uniqueStreams","handleGenerateLink","generateContent","copyGeneratedLink","downloadTxtFile","blob","Blob","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","updateLinkContent","handleScheduleCheck","startScheduleCheck","now","checkInterval","state","savedState","resetAllStates","updateActiveStatus","hasActive","addEventListener","preventDefault","returnValue","watch","handler","deep","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\r\n  <div class=\"stream-check\">\r\n    <div class=\"table-operations\">\r\n      <el-button-group>\r\n        <el-button \r\n          type=\"primary\" \r\n          icon=\"el-icon-upload2\"\r\n          @click=\"$refs.fileInput.click()\"\r\n          :disabled=\"isCollecting\">\r\n          导入本地文件\r\n        </el-button>\r\n        <el-button \r\n          type=\"primary\" \r\n          icon=\"el-icon-download\"\r\n          @click=\"importUrlDialogVisible = true\"\r\n          :disabled=\"isCollecting\">\r\n          导入网络文件\r\n        </el-button>\r\n      </el-button-group>\r\n      \r\n      <el-button-group>\r\n        <el-button \r\n          type=\"success\" \r\n          icon=\"el-icon-refresh\"\r\n          @click=\"handleBatchCheck\"\r\n          :loading=\"isChecking\">\r\n          {{ checkButtonText }}\r\n        </el-button>\r\n        <el-button \r\n          v-if=\"isChecking\"\r\n          type=\"warning\" \r\n          icon=\"el-icon-video-pause\"\r\n          @click=\"pauseCheck\">\r\n          暂停检测\r\n        </el-button>\r\n        <el-button \r\n          v-if=\"isPaused\"\r\n          type=\"primary\" \r\n          icon=\"el-icon-video-play\"\r\n          @click=\"resumeCheck\">\r\n          继续检测\r\n        </el-button>\r\n        <el-button \r\n          type=\"danger\" \r\n          icon=\"el-icon-delete\"\r\n          @click=\"handleClearList\">\r\n          清空列表\r\n        </el-button>\r\n      </el-button-group>\r\n      \r\n      <el-button-group>\r\n        <el-button \r\n          :type=\"isCollecting ? 'danger' : 'primary'\"\r\n          icon=\"el-icon-connection\"\r\n          @click=\"handleCollectMode\">\r\n          {{ isCollecting ? '停止采集' : '采集模式' }}\r\n        </el-button>\r\n      </el-button-group>\r\n      \r\n      <el-button-group>\r\n        <el-button \r\n          type=\"primary\"\r\n          icon=\"el-icon-link\"\r\n          @click=\"handleGenerateLink\">\r\n          生成链接\r\n        </el-button>\r\n      </el-button-group>\r\n      \r\n      <el-button-group>\r\n        <el-button \r\n          :type=\"isScheduled ? 'danger' : 'primary'\"\r\n          icon=\"el-icon-timer\"\r\n          @click=\"handleScheduleCheck\">\r\n          {{ isScheduled ? '停止定时' : '定时检测' }}\r\n        </el-button>\r\n      </el-button-group>\r\n      \r\n      <!-- 隐藏的文件输入框 -->\r\n      <input\r\n        type=\"file\"\r\n        ref=\"fileInput\"\r\n        style=\"display: none\"\r\n        accept=\".txt,.m3u,.m3u8\"\r\n        @change=\"handleFileUpload\"\r\n      >\r\n    </div>\r\n\r\n    <el-table\r\n      :data=\"paginatedData\"\r\n      border\r\n      style=\"width: 100%\">\r\n      <el-table-column\r\n        prop=\"name\"\r\n        label=\"名称\"\r\n        min-width=\"120\"\r\n        align=\"center\">\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        prop=\"url\"\r\n        label=\"链接\"\r\n        min-width=\"200\"\r\n        align=\"center\"\r\n        show-overflow-tooltip>\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        prop=\"resolution\"\r\n        label=\"分辨率\"\r\n        width=\"120\"\r\n        align=\"center\">\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        prop=\"responseTime\"\r\n        label=\"响应速度\"\r\n        width=\"120\"\r\n        align=\"center\">\r\n        <template slot-scope=\"scope\">\r\n          {{ scope.row.responseTime }}ms\r\n        </template>\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        prop=\"group\"\r\n        label=\"分组\"\r\n        width=\"120\"\r\n        align=\"center\">\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        prop=\"status\"\r\n        label=\"状态\"\r\n        width=\"100\"\r\n        align=\"center\">\r\n        <template slot-scope=\"scope\">\r\n          <el-tag :type=\"scope.row.status === '正常' ? 'success' : 'danger'\">\r\n            {{ scope.row.status }}\r\n          </el-tag>\r\n        </template>\r\n      </el-table-column>\r\n      \r\n      <el-table-column\r\n        label=\"操作\"\r\n        width=\"120\"\r\n        align=\"center\"\r\n        fixed=\"right\">\r\n        <template slot-scope=\"scope\">\r\n          <el-tooltip content=\"复制链接\" placement=\"top\">\r\n            <el-button\r\n              type=\"text\"\r\n              icon=\"el-icon-document-copy\"\r\n              @click=\"handleCopy(scope.row)\">\r\n            </el-button>\r\n          </el-tooltip>\r\n          <el-tooltip content=\"删除\" placement=\"top\">\r\n            <el-button\r\n              type=\"text\"\r\n              class=\"delete-btn\"\r\n              icon=\"el-icon-delete\"\r\n              @click=\"handleDelete(scope.row)\">\r\n            </el-button>\r\n          </el-tooltip>\r\n        </template>\r\n      </el-table-column>\r\n    </el-table>\r\n\r\n    <!-- 添加分页组件 -->\r\n    <div class=\"pagination-container\">\r\n      <el-pagination\r\n        @size-change=\"handleSizeChange\"\r\n        @current-change=\"handleCurrentChange\"\r\n        :current-page=\"currentPage\"\r\n        :page-sizes=\"[5, 10, 20, 50]\"\r\n        :page-size=\"pageSize\"\r\n        layout=\"total, sizes, prev, pager, next, jumper\"\r\n        :total=\"streamList.length\">\r\n      </el-pagination>\r\n    </div>\r\n\r\n    <!-- 添加/编辑对话框 -->\r\n    <el-dialog\r\n      title=\"导入网络文件\"\r\n      :visible.sync=\"importUrlDialogVisible\"\r\n      width=\"500px\">\r\n      <el-form :model=\"importForm\" label-width=\"80px\" ref=\"importForm\" :rules=\"importRules\">\r\n        <el-form-item label=\"URL地址\" prop=\"url\">\r\n          <el-input \r\n            v-model=\"importForm.url\" \r\n            placeholder=\"请输入txt或m3u文件的网络地址\"\r\n          ></el-input>\r\n        </el-form-item>\r\n      </el-form>\r\n      <div slot=\"footer\">\r\n        <el-button @click=\"importUrlDialogVisible = false\">取 消</el-button>\r\n        <el-button type=\"primary\" @click=\"handleUrlImport\">导 入</el-button>\r\n      </div>\r\n    </el-dialog>\r\n\r\n    <!-- 采集模式设置对话框 -->\r\n    <el-dialog\r\n      title=\"采集模式设置\"\r\n      :visible.sync=\"collectDialogVisible\"\r\n      width=\"500px\">\r\n      <el-form :model=\"collectForm\" label-width=\"100px\" ref=\"collectForm\" :rules=\"collectRules\">\r\n        <el-form-item label=\"采集地址\" prop=\"urls\">\r\n          <el-input \r\n            v-model=\"collectForm.urls[0]\" \r\n            placeholder=\"请输入需要采集的网络地址\">\r\n          </el-input>\r\n        </el-form-item>\r\n        <el-form-item label=\"自动采集\">\r\n          <el-switch v-model=\"collectForm.autoCollect\"></el-switch>\r\n        </el-form-item>\r\n        <el-form-item \r\n          label=\"采集间隔\" \r\n          prop=\"interval\"\r\n          v-if=\"collectForm.autoCollect\">\r\n          <el-input-number \r\n            v-model=\"collectForm.interval\" \r\n            :min=\"1\"\r\n            :max=\"1440\"\r\n            :step=\"1\">\r\n          </el-input-number>\r\n          <span class=\"setting-tip\">分钟</span>\r\n        </el-form-item>\r\n      </el-form>\r\n      <div slot=\"footer\">\r\n        <el-button @click=\"collectDialogVisible = false\">取 消</el-button>\r\n        <el-button type=\"primary\" @click=\"startCollecting\">开始采集</el-button>\r\n      </div>\r\n    </el-dialog>\r\n\r\n    <!-- 生成链接对话框 -->\r\n    <el-dialog\r\n      title=\"生成链接\"\r\n      :visible.sync=\"generateLinkDialogVisible\"\r\n      width=\"500px\"\r\n      custom-class=\"generate-link-dialog\">\r\n      <div class=\"link-container\">\r\n        <!-- 链接展示卡片 -->\r\n        <el-card class=\"link-card\">\r\n          <div class=\"link-content\">\r\n            <el-input\r\n              v-model=\"generatedLink\"\r\n              placeholder=\"正在生成链接...\"\r\n              readonly>\r\n              <template slot=\"prepend\">链接地址</template>\r\n              <el-button \r\n                slot=\"append\" \r\n                icon=\"el-icon-document-copy\"\r\n                @click=\"copyGeneratedLink\">\r\n                复制\r\n              </el-button>\r\n            </el-input>\r\n          </div>\r\n        </el-card>\r\n\r\n        <!-- 使用说明 -->\r\n        <el-card class=\"tips-card\">\r\n          <div class=\"tips-content\">\r\n            <ul>\r\n              <li>生成的链接可以直接在支持网络导入的播放器中使用</li>\r\n              <li>链接内容会随列表更新而自动更新</li>\r\n            </ul>\r\n          </div>\r\n        </el-card>\r\n      </div>\r\n    </el-dialog>\r\n\r\n    <!-- 添加定时检测设置对话框 -->\r\n    <el-dialog\r\n      title=\"定时检测设置\"\r\n      :visible.sync=\"scheduleDialogVisible\"\r\n      width=\"500px\">\r\n      <el-form :model=\"scheduleForm\" label-width=\"100px\" ref=\"scheduleForm\" :rules=\"scheduleRules\">\r\n        <el-form-item label=\"检测周期\" prop=\"interval\">\r\n          <el-select v-model=\"scheduleForm.unit\" style=\"width: 100px; margin-right: 10px\">\r\n            <el-option label=\"秒\" value=\"second\"></el-option>\r\n            <el-option label=\"分钟\" value=\"minute\"></el-option>\r\n          </el-select>\r\n          <el-input-number \r\n            v-model=\"scheduleForm.interval\"\r\n            :min=\"scheduleForm.unit === 'second' ? 10 : 1\"\r\n            :max=\"scheduleForm.unit === 'second' ? 59 : 7980\"\r\n            :step=\"scheduleForm.unit === 'second' ? 10 : 1\">\r\n          </el-input-number>\r\n          <span class=\"setting-tip\">\r\n            {{ scheduleForm.unit === 'second' ? '(10秒 ~ 59秒)' : '(1分钟 ~ 7天)' }}\r\n          </span>\r\n        </el-form-item>\r\n      </el-form>\r\n      <div slot=\"footer\">\r\n        <el-button @click=\"scheduleDialogVisible = false\">取 消</el-button>\r\n        <el-button type=\"primary\" @click=\"startScheduleCheck\">开始定时</el-button>\r\n      </div>\r\n    </el-dialog>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'StreamCheck',\r\n  data() {\r\n    return {\r\n      loading: false,\r\n      streamList: [],\r\n      importUrlDialogVisible: false,\r\n      importForm: {\r\n        url: '',\r\n        group: ''\r\n      },\r\n      importRules: {\r\n        url: [\r\n          { required: true, message: '请输入URL地址', trigger: 'blur' },\r\n          { type: 'url', message: '请输入正确的URL地址', trigger: 'blur' }\r\n        ],\r\n        group: [\r\n          { required: true, message: '请选择分组', trigger: 'change' }\r\n        ]\r\n      },\r\n      currentPage: 1,\r\n      pageSize: 5,\r\n      isChecking: false,\r\n      isPaused: false,\r\n      checkedCount: 0,\r\n      totalCount: 0,\r\n      pausedIndex: -1,\r\n      shouldStop: false,\r\n      isCollecting: false,\r\n      collectDialogVisible: false,\r\n      collectForm: {\r\n        urls: [''],\r\n        autoCollect: false,\r\n        interval: 30\r\n      },\r\n      collectRules: {\r\n        urls: [\r\n          { \r\n            type: 'array',\r\n            validator: (rule, value, callback) => {\r\n              if (value.length === 0) {\r\n                callback(new Error('请至少添加一个采集地址'))\r\n              }\r\n              // 验证每个URL\r\n              const errors = value.map(url => {\r\n                if (!url) return '采集地址不能为空'\r\n                if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址'\r\n                return null\r\n              }).filter(error => error !== null)\r\n              \r\n              if (errors.length > 0) {\r\n                callback(new Error(errors[0]))\r\n              } else {\r\n                callback()\r\n              }\r\n            },\r\n            trigger: 'change'\r\n          }\r\n        ]\r\n      },\r\n      collectTimer: null,\r\n      generateLinkDialogVisible: false,\r\n      generatedLink: '',\r\n      previewContent: '',  // 新增预览内容\r\n      currentLinkId: '',\r\n      scheduleDialogVisible: false,\r\n      isScheduled: false,\r\n      scheduleForm: {\r\n        interval: 30,\r\n        unit: 'minute'\r\n      },\r\n      scheduleRules: {\r\n        interval: [\r\n          { required: true, message: '请设置检测间隔', trigger: 'change' },\r\n          { \r\n            validator: (rule, value, callback) => {\r\n              if (this.scheduleForm.unit === 'second') {\r\n                if (value < 10 || value > 59) {\r\n                  callback(new Error('秒数必须在10到59之间'))\r\n                }\r\n              } else {\r\n                if (value < 1 || value > 7980) {\r\n                  callback(new Error('分钟数必须在1到7980之间'))\r\n                }\r\n              }\r\n              callback()\r\n            }, \r\n            trigger: 'change' \r\n          }\r\n        ]\r\n      },\r\n      scheduleTimer: null,\r\n      nextScheduleTime: null,\r\n      stateKey: 'streamCheckState', // 用于本地存储的key\r\n      hasActiveOperations: false  // 添加标记表示是否有动作在执行\r\n    }\r\n  },\r\n  computed: {\r\n    paginatedData() {\r\n      const start = (this.currentPage - 1) * this.pageSize\r\n      const end = start + this.pageSize\r\n      return this.streamList.slice(start, end)\r\n    },\r\n    checkButtonText() {\r\n      if (!this.isChecking && !this.isPaused) {\r\n        return '批量检测'\r\n      }\r\n      return `检测中 ${this.checkedCount}/${this.totalCount}`\r\n    },\r\n    mergedStreams() {\r\n      // 创建一个Map来存储合并后的直播源\r\n      const streamMap = new Map()\r\n      \r\n      // 按照当前列表顺序处理每个直播源\r\n      this.streamList.forEach(stream => {\r\n        const key = stream.name // 使用名称作为键\r\n        \r\n        if (streamMap.has(key)) {\r\n          // 如果已存在相同名称的直播源，添加到URLs数组\r\n          const existing = streamMap.get(key)\r\n          if (!existing.urls.includes(stream.url)) {\r\n            existing.urls.push(stream.url)\r\n          }\r\n        } else {\r\n          // 如果是新的名称，创建新条目\r\n          streamMap.set(key, {\r\n            name: stream.name,\r\n            urls: [stream.url],\r\n            group: stream.group\r\n          })\r\n        }\r\n      })\r\n      \r\n      // 转换回数组格式\r\n      return Array.from(streamMap.values())\r\n    }\r\n  },\r\n  created() {\r\n    // 初始化时加载持久化的数据\r\n    if (localStorage.getItem('persistentData') === 'true') {\r\n      const savedList = localStorage.getItem('streamList')\r\n      if (savedList) {\r\n        this.streamList = JSON.parse(savedList)\r\n      }\r\n    }\r\n\r\n    // 监听保存事件\r\n    this.$root.$on('save-stream-list', this.saveStreamList)\r\n\r\n    // 从本地存储恢复状态\r\n    this.restoreState()\r\n    // 如果定时检测是开启状态，重新启动定时器\r\n    if (this.isScheduled) {\r\n      this.setupSchedule()\r\n    }\r\n    // 如果采集是开启状态，重新启动采集\r\n    if (this.isCollecting) {\r\n      this.startCollecting(true) // true表示是恢复状态\r\n    }\r\n  },\r\n  beforeDestroy() {\r\n    // 移除事件监听\r\n    this.$root.$off('save-stream-list', this.saveStreamList)\r\n    // 组件销毁前清除定时器\r\n    if (this.collectTimer) {\r\n      clearInterval(this.collectTimer)\r\n    }\r\n    // 组件销毁时清理定时器\r\n    this.stopScheduleCheck()\r\n    // 在组件销毁前保存状态\r\n    this.saveState()\r\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\r\n  },\r\n  methods: {\r\n    async checkStream(stream) {\r\n      const ffprobePath = localStorage.getItem('ffprobePath')\r\n      if (!ffprobePath) {\r\n        this.$message.error('请先在系统设置中配置FFprobe路径')\r\n        return false\r\n      }\r\n\r\n      try {\r\n        const response = await fetch('http://localhost:8080/api/check-stream', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          },\r\n          body: JSON.stringify({\r\n            url: stream.url,\r\n            ffprobePath: ffprobePath\r\n          })\r\n        })\r\n\r\n        if (!response.ok) throw new Error('请求失败')\r\n        \r\n        const result = await response.json()\r\n        \r\n        // 更新流信息\r\n        stream.status = result.available ? '正常' : '异常'\r\n        stream.resolution = result.resolution || ''\r\n        stream.responseTime = result.responseTime || 0\r\n\r\n        // 检查是否需要自动清除\r\n        if (this.shouldRemoveStream(stream)) {\r\n          let reason = ''\r\n          if (stream.status === '异常') {\r\n            reason = '异常源'\r\n          } else if (stream.responseTime > 3000) {\r\n            reason = '响应时间过慢'\r\n          } else {\r\n            reason = '分辨率过低'\r\n          }\r\n\r\n          // 找到当前页的所有项\r\n          const currentPageItems = this.paginatedData\r\n          // 找到要删除项在当前页的索引\r\n          const pageIndex = currentPageItems.indexOf(stream)\r\n          // 找到要删除项在整个列表中的索引\r\n          const listIndex = this.streamList.indexOf(stream)\r\n          \r\n          if (listIndex > -1) {\r\n            this.streamList.splice(listIndex, 1)\r\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\r\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\r\n              this.currentPage--\r\n            }\r\n            // 添加删除原因提示\r\n            this.$message.warning(`已自动清除直播源：${reason}`)\r\n          }\r\n        }\r\n        \r\n        this.saveStreamList()\r\n        return result.available\r\n      } catch (error) {\r\n        console.error('检测错误:', error)\r\n        stream.status = '异常'\r\n        return false\r\n      }\r\n    },\r\n\r\n    async handleBatchCheck() {\r\n      if (this.isPaused) {\r\n        this.resumeCheck()\r\n        return\r\n      }\r\n      \r\n      if (this.streamList.length === 0) {\r\n        this.$message.warning('列表为空')\r\n        return\r\n      }\r\n\r\n      this.isChecking = true\r\n      this.isPaused = false\r\n      this.shouldStop = false\r\n      this.checkedCount = 0\r\n      this.totalCount = this.streamList.length\r\n      \r\n      await this.batchCheck(0)\r\n    },\r\n\r\n    async batchCheck(startIndex) {\r\n      let successCount = 0\r\n      let failCount = 0\r\n      const validStreams = []\r\n      \r\n      for (let i = startIndex; i < this.streamList.length; i++) {\r\n        if (this.shouldStop) {\r\n          this.pausedIndex = i\r\n          this.isPaused = true\r\n          this.isChecking = false\r\n          return\r\n        }\r\n\r\n        const stream = this.streamList[i]\r\n        try {\r\n          const response = await fetch('http://localhost:8080/api/check-stream', {\r\n            method: 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({\r\n              url: stream.url,\r\n              ffprobePath: localStorage.getItem('ffprobePath')\r\n            })\r\n          })\r\n\r\n          if (!response.ok) throw new Error('请求失败')\r\n          \r\n          const result = await response.json()\r\n          \r\n          // 更新流信息\r\n          stream.status = result.available ? '正常' : '异常'\r\n          stream.resolution = result.resolution || ''\r\n          stream.responseTime = result.responseTime || 0\r\n\r\n          if (result.available) {\r\n            successCount++\r\n          } else {\r\n            failCount++\r\n          }\r\n\r\n          // 根据设置决定是否保留该项\r\n          if (!this.shouldRemoveStream(stream)) {\r\n            validStreams.push(stream)\r\n          }\r\n        } catch (error) {\r\n          console.error('检测错误:', error)\r\n          stream.status = '异常'\r\n          failCount++\r\n          \r\n          // 如果不自动清除异常源，则保留该项\r\n          if (!localStorage.getItem('autoRemoveInvalid') === 'true') {\r\n            validStreams.push(stream)\r\n          }\r\n        }\r\n        \r\n        this.checkedCount++\r\n      }\r\n\r\n      // 如果检测完成（不是暂停状态）\r\n      if (!this.shouldStop) {\r\n        // 批量更新列表\r\n        this.streamList = validStreams\r\n        \r\n        // 更新分页\r\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\r\n        if (this.currentPage > maxPage) {\r\n          this.currentPage = Math.max(maxPage, 1)\r\n        }\r\n        \r\n        // 保存更新后的列表\r\n        this.saveStreamList()\r\n        \r\n        this.isChecking = false\r\n        this.isPaused = false\r\n        this.pausedIndex = -1\r\n        this.$message.success(`检测完成: ${successCount}个正常, ${failCount}个异常`)\r\n      }\r\n    },\r\n\r\n    pauseCheck() {\r\n      this.shouldStop = true\r\n    },\r\n\r\n    async resumeCheck() {\r\n      if (this.pausedIndex >= 0) {\r\n        this.isChecking = true\r\n        this.isPaused = false\r\n        this.shouldStop = false\r\n        await this.batchCheck(this.pausedIndex)\r\n      }\r\n    },\r\n\r\n    async handleCheck(row) {\r\n      row.status = '检测中'\r\n      \r\n      const success = await this.checkStream(row)\r\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`)\r\n    },\r\n    handleDelete(row) {\r\n      this.$confirm('确认删除该直播源?', '提示', {\r\n        confirmButtonText: '确定',\r\n        cancelButtonText: '取消',\r\n        type: 'warning'\r\n      }).then(() => {\r\n        const index = this.streamList.indexOf(row)\r\n        this.streamList.splice(index, 1)\r\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\r\n        if (this.currentPage > maxPage) {\r\n          this.currentPage = Math.max(maxPage, 1)\r\n        }\r\n        this.saveStreamList()  // 保存更新后的列表\r\n        this.$message.success('删除成功')\r\n      }).catch(() => {})\r\n    },\r\n    async handleUrlImport() {\r\n      if (!this.importForm.url) {\r\n        this.$message.warning('请输入URL地址')\r\n        return\r\n      }\r\n\r\n      this.loading = true\r\n      try {\r\n        const response = await fetch(this.importForm.url)\r\n        if (!response.ok) throw new Error('网络请求失败')\r\n        \r\n        const content = await response.text()\r\n        const streams = this.parseContent(content)\r\n        this.addStreamsToList(streams)\r\n        \r\n        this.importUrlDialogVisible = false\r\n        this.$message.success('网络文件导入成功')\r\n      } catch (error) {\r\n        this.$message.error('导入失败：' + error.message)\r\n      } finally {\r\n        this.loading = false\r\n      }\r\n    },\r\n    readFile(file) {\r\n      return new Promise((resolve, reject) => {\r\n        const reader = new FileReader()\r\n        reader.onload = (e) => resolve(e.target.result)\r\n        reader.onerror = () => reject(new Error('文件读取失败'))\r\n        reader.readAsText(file)\r\n      })\r\n    },\r\n    parseContent(content) {\r\n      // 将内容按行分割\r\n      const lines = content.split(/\\r?\\n/).filter(line => line.trim())\r\n      const streams = []\r\n      \r\n      // 解析m3u格式\r\n      if (content.includes('#EXTM3U')) {\r\n        let currentName = ''\r\n        \r\n        lines.forEach(line => {\r\n          if (line.startsWith('#EXTINF:')) {\r\n            // 提取频道名称\r\n            currentName = line.split(',')[1]?.trim() || ''\r\n          } else if (!line.startsWith('#') && line.trim()) {\r\n            // 这是一个媒体URL\r\n            streams.push({\r\n              name: currentName || `未命名频道${streams.length + 1}`,\r\n              url: line.trim(),\r\n              resolution: '',\r\n              responseTime: 0,\r\n              status: '未检测',\r\n              group: '未分组'\r\n            })\r\n            currentName = ''\r\n          }\r\n        })\r\n      } else {\r\n        // 解析txt格式\r\n        let currentGroup = '未分组'\r\n        \r\n        lines.forEach(line => {\r\n          const trimmedLine = line.trim()\r\n          \r\n          // 检查是否是分组标签\r\n          if (trimmedLine.includes('#genre#')) {\r\n            currentGroup = trimmedLine.split(',')[0].trim()\r\n            return\r\n          }\r\n          \r\n          // 跳过其他#开头的行和空行\r\n          if (trimmedLine.startsWith('#') || !trimmedLine) {\r\n            return\r\n          }\r\n          \r\n          // 处理实际的直播源行\r\n          if (trimmedLine.includes(',')) {\r\n            // 如果行包含逗号，假设格式为：名称,URL\r\n            const parts = trimmedLine.split(',')\r\n            // 取最后一个部分作为URL，其余部分作为名称\r\n            const url = parts.pop().trim()\r\n            const name = parts.join(',').trim()\r\n            \r\n            if (url && !url.startsWith('#')) { // 确保URL存在且不是注释\r\n              streams.push({\r\n                name: name || `未命名频道${streams.length + 1}`,\r\n                url: url,\r\n                resolution: '',\r\n                responseTime: 0,\r\n                status: '未检测',\r\n                group: currentGroup\r\n              })\r\n            }\r\n          } else {\r\n            // 如果行不包含逗号且不是注释，则整行作为URL\r\n            streams.push({\r\n              name: `未命名频道${streams.length + 1}`,\r\n              url: trimmedLine,\r\n              resolution: '',\r\n              responseTime: 0,\r\n              status: '未检测',\r\n              group: currentGroup\r\n            })\r\n          }\r\n        })\r\n      }\r\n      \r\n      return streams\r\n    },\r\n    addStreamsToList(streams) {\r\n      streams.forEach(stream => {\r\n        this.streamList.push(stream)\r\n      })\r\n      this.currentPage = 1\r\n      this.saveStreamList()  // 保存更新后的列表\r\n    },\r\n    handleSizeChange(val) {\r\n      this.pageSize = val\r\n      // 当每页条数改变时，重置当前页为第一页\r\n      this.currentPage = 1\r\n    },\r\n    handleCurrentChange(val) {\r\n      this.currentPage = val\r\n    },\r\n    async handleFileUpload(event) {\r\n      const file = event.target.files[0]\r\n      if (!file) return\r\n\r\n      try {\r\n        this.loading = true\r\n        const content = await this.readFile(file)\r\n        const streams = this.parseContent(content)\r\n        this.addStreamsToList(streams)\r\n        \r\n        this.$message.success('文件导入成功')\r\n      } catch (error) {\r\n        this.$message.error('文件导入失败：' + error.message)\r\n      } finally {\r\n        this.loading = false\r\n        // 清除文件输入，允许重复选择同一文件\r\n        event.target.value = ''\r\n      }\r\n    },\r\n    getGroupFromFileName(filename) {\r\n      // 从文件名中提取可能的分组名\r\n      const name = filename.toLowerCase()\r\n      if (name.includes('cctv')) return 'CCTV'\r\n      if (name.includes('卫视')) return '卫视'\r\n      if (name.includes('地方')) return '地方台'\r\n      return '未分组'\r\n    },\r\n    handleClearList() {\r\n      if (this.streamList.length === 0) {\r\n        this.$message.warning('列表已经为空')\r\n        return\r\n      }\r\n\r\n      this.$confirm('确认清空所有直播源?', '提示', {\r\n        confirmButtonText: '确定',\r\n        cancelButtonText: '取消',\r\n        type: 'warning'\r\n      }).then(() => {\r\n        this.streamList = []\r\n        this.currentPage = 1\r\n        this.saveStreamList()  // 保存更新后的列表\r\n        this.$message.success('列表已清空')\r\n      }).catch(() => {})\r\n    },\r\n    handleCopy(row) {\r\n      // 创建一个临时输入框来实现复制功能\r\n      const textarea = document.createElement('textarea')\r\n      textarea.value = row.url\r\n      document.body.appendChild(textarea)\r\n      textarea.select()\r\n      \r\n      try {\r\n        document.execCommand('copy')\r\n        this.$message.success('链接已复制到剪贴板')\r\n      } catch (err) {\r\n        this.$message.error('复制失败')\r\n      } finally {\r\n        document.body.removeChild(textarea)\r\n      }\r\n    },\r\n    shouldRemoveStream(stream) {\r\n      // 检查是否需要清除异常源\r\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && \r\n          stream.status === '异常') {\r\n        return true\r\n      }\r\n\r\n      // 检查是否需要清除低分辨率源\r\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && \r\n          stream.resolution !== '未知') {\r\n        const [width, height] = stream.resolution.split('x').map(Number)\r\n        if (width < 1280 || height < 720) {\r\n          return true\r\n        }\r\n      }\r\n\r\n      // 添加新的检查：响应时间\r\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && \r\n          stream.responseTime > 3000) {\r\n        return true\r\n      }\r\n\r\n      return false\r\n    },\r\n    saveStreamList() {\r\n      if (localStorage.getItem('persistentData') === 'true') {\r\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\r\n      }\r\n    },\r\n    handleCollectMode() {\r\n      if (this.isCollecting) {\r\n        this.stopCollecting()\r\n      } else {\r\n        this.collectDialogVisible = true\r\n      }\r\n    },\r\n    async startCollecting(isRestore = false) {\r\n      if (!isRestore) {\r\n        // 正常启动时才验证表单\r\n        const valid = await this.$refs.collectForm.validate()\r\n        if (!valid) return\r\n      }\r\n\r\n      this.collectDialogVisible = false\r\n      this.isCollecting = true\r\n      this.saveState() // 保存状态\r\n      \r\n      // 立即执行一次采集\r\n      if (!isRestore) {\r\n        await this.collect()\r\n      }\r\n      \r\n      // 如果开启了自动采集，设置定时器\r\n      if (this.collectForm.autoCollect) {\r\n        this.collectTimer = setInterval(async () => {\r\n          await this.collect()\r\n        }, this.collectForm.interval * 60 * 1000)\r\n      }\r\n    },\r\n    stopCollecting() {\r\n      this.isCollecting = false\r\n      if (this.collectTimer) {\r\n        clearInterval(this.collectTimer)\r\n        this.collectTimer = null\r\n      }\r\n      this.saveState() // 保存状态\r\n      this.$message.success('已停止采集')\r\n    },\r\n    async collect() {\r\n      try {\r\n        this.$message.info('开始采集直播源...')\r\n        const response = await fetch(this.collectForm.urls[0])\r\n        if (!response.ok) throw new Error('网络请求失败')\r\n        \r\n        const content = await response.text()\r\n        const newStreams = this.parseContent(content)\r\n        \r\n        // 过滤出新的直播源\r\n        const existingUrls = new Set(this.streamList.map(s => s.url))\r\n        const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\r\n        \r\n        if (uniqueStreams.length > 0) {\r\n          this.addStreamsToList(uniqueStreams)\r\n          this.$message.success(`采集成功: 新增${uniqueStreams.length}个直播源`)\r\n        } else {\r\n          this.$message.info('未发现新的直播源')\r\n        }\r\n      } catch (error) {\r\n        this.$message.error('采集失败：' + error.message)\r\n        // 如果是单次采集模式，出错时停止采集\r\n        if (!this.collectForm.autoCollect) {\r\n          this.stopCollecting()\r\n        }\r\n      }\r\n    },\r\n    async handleGenerateLink() {\r\n      try {\r\n        this.generateLinkDialogVisible = true\r\n        \r\n        // 生成内容\r\n        const content = this.generateContent()\r\n        \r\n        // 创建或更新链接内容\r\n        const response = await fetch('http://localhost:8080/api/generate-link', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'text/plain'\r\n          },\r\n          body: content\r\n        })\r\n\r\n        if (!response.ok) {\r\n          throw new Error('生成链接失败')\r\n        }\r\n\r\n        // 使用返回的固定链接\r\n        this.generatedLink = await response.text()\r\n      } catch (error) {\r\n        this.$message.error('生成链接失败：' + error.message)\r\n      }\r\n    },\r\n    generateContent() {\r\n      let content = ''\r\n      let currentGroup = ''\r\n      \r\n      // 按组生成内容\r\n      this.mergedStreams.forEach(stream => {\r\n        // 如果组发生变化，添加组标记\r\n        if (stream.group !== currentGroup) {\r\n          currentGroup = stream.group\r\n          content += `${currentGroup},#genre#\\n`\r\n        }\r\n        \r\n        // 合并相同名称的链接，用#连接\r\n        content += `${stream.name},${stream.urls.join('#')}\\n`\r\n      })\r\n      \r\n      return content.trim()\r\n    },\r\n    copyGeneratedLink() {\r\n      const textarea = document.createElement('textarea')\r\n      textarea.value = this.generatedLink\r\n      document.body.appendChild(textarea)\r\n      textarea.select()\r\n      \r\n      try {\r\n        document.execCommand('copy')\r\n        this.$message.success('链接已复制到剪贴板')\r\n      } catch (err) {\r\n        this.$message.error('复制失败')\r\n      } finally {\r\n        document.body.removeChild(textarea)\r\n      }\r\n    },\r\n    downloadTxtFile() {\r\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\r\n      const url = window.URL.createObjectURL(blob)\r\n      const link = document.createElement('a')\r\n      link.href = url\r\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\r\n      \r\n      document.body.appendChild(link)\r\n      link.click()\r\n      \r\n      // 清理\r\n      window.URL.revokeObjectURL(url)\r\n      document.body.removeChild(link)\r\n      this.$message.success('文件下载成功')\r\n    },\r\n    // 修改更新链接内容的方法\r\n    async updateLinkContent() {\r\n      try {\r\n        const content = this.generateContent()\r\n        await fetch('http://localhost:8080/api/update-content', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'text/plain'\r\n          },\r\n          body: content\r\n        })\r\n      } catch (error) {\r\n        console.error('更新链接内容失败：', error)\r\n      }\r\n    },\r\n    handleScheduleCheck() {\r\n      if (this.isScheduled) {\r\n        this.stopScheduleCheck()\r\n      } else {\r\n        this.scheduleDialogVisible = true\r\n      }\r\n    },\r\n    startScheduleCheck() {\r\n      this.$refs.scheduleForm.validate(valid => {\r\n        if (valid) {\r\n          this.scheduleDialogVisible = false\r\n          this.isScheduled = true\r\n          this.setupSchedule()\r\n          this.saveState() // 保存状态\r\n          this.$message.success('定时检测已开启')\r\n        }\r\n      })\r\n    },\r\n    stopScheduleCheck() {\r\n      if (this.scheduleTimer) {\r\n        clearInterval(this.scheduleTimer)\r\n        this.scheduleTimer = null\r\n      }\r\n      this.isScheduled = false\r\n      this.nextScheduleTime = null\r\n      this.saveState() // 保存状态\r\n      this.$message.success('定时检测已停止')\r\n    },\r\n    setupSchedule() {\r\n      // 清除现有定时器\r\n      if (this.scheduleTimer) {\r\n        clearInterval(this.scheduleTimer)\r\n      }\r\n\r\n      // 计算检查间隔（转换为毫秒）\r\n      const interval = this.scheduleForm.unit === 'second' \r\n        ? this.scheduleForm.interval * 1000 \r\n        : this.scheduleForm.interval * 60 * 1000\r\n      \r\n      // 设置下次执行时间\r\n      this.nextScheduleTime = new Date(Date.now() + interval)\r\n\r\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\r\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000\r\n\r\n      this.scheduleTimer = setInterval(() => {\r\n        const now = new Date()\r\n        \r\n        // 如果当前正在检测中，跳过这次执行\r\n        if (this.isChecking) {\r\n          return\r\n        }\r\n\r\n        // 检查是否到达执行时间\r\n        if (now >= this.nextScheduleTime) {\r\n          this.handleBatchCheck()\r\n          // 更新下次执行时间\r\n          this.nextScheduleTime = new Date(Date.now() + interval)\r\n        }\r\n      }, checkInterval)\r\n    },\r\n    // 保存当前状态到本地存储\r\n    saveState() {\r\n      // 只保存基础数据和设置，不保存运行状态\r\n      const state = {\r\n        streamList: this.streamList,\r\n        currentPage: this.currentPage,\r\n        pageSize: this.pageSize,\r\n        scheduleForm: this.scheduleForm,\r\n        collectForm: this.collectForm\r\n      }\r\n      localStorage.setItem(this.stateKey, JSON.stringify(state))\r\n    },\r\n    // 从本地存储恢复状态\r\n    restoreState() {\r\n      try {\r\n        const savedState = localStorage.getItem(this.stateKey)\r\n        if (savedState) {\r\n          const state = JSON.parse(savedState)\r\n          \r\n          // 只恢复基础数据和设置\r\n          this.streamList = state.streamList || []\r\n          this.currentPage = state.currentPage || 1\r\n          this.pageSize = state.pageSize || 5\r\n          this.scheduleForm = state.scheduleForm || this.scheduleForm\r\n          this.collectForm = state.collectForm || this.collectForm\r\n\r\n          // 重置所有运行状态\r\n          this.isChecking = false\r\n          this.isPaused = false\r\n          this.isScheduled = false\r\n          this.isCollecting = false\r\n          this.checkedCount = 0\r\n          this.totalCount = 0\r\n          this.pausedIndex = -1\r\n          this.nextScheduleTime = null\r\n        }\r\n      } catch (error) {\r\n        console.error('恢复状态失败：', error)\r\n      }\r\n    },\r\n    // 添加重置所有运行状态的方法\r\n    resetAllStates() {\r\n      // 停止定时检测\r\n      if (this.isScheduled) {\r\n        this.stopScheduleCheck()\r\n      }\r\n      \r\n      // 停止采集\r\n      if (this.isCollecting) {\r\n        this.stopCollecting()\r\n      }\r\n      \r\n      // 停止批量检测\r\n      if (this.isChecking) {\r\n        this.shouldStop = true\r\n        this.isChecking = false\r\n        this.isPaused = false\r\n      }\r\n      \r\n      // 重置所有状态\r\n      this.isChecking = false\r\n      this.isPaused = false\r\n      this.isScheduled = false\r\n      this.isCollecting = false\r\n      this.checkedCount = 0\r\n      this.totalCount = 0\r\n      this.pausedIndex = -1\r\n      this.nextScheduleTime = null\r\n      \r\n      // 清除所有定时器\r\n      if (this.scheduleTimer) {\r\n        clearInterval(this.scheduleTimer)\r\n        this.scheduleTimer = null\r\n      }\r\n      if (this.collectTimer) {\r\n        clearInterval(this.collectTimer)\r\n        this.collectTimer = null\r\n      }\r\n      \r\n      // 保存重置后的状态\r\n      this.saveState()\r\n      \r\n      this.$message.success('所有运行状态已重置')\r\n    },\r\n    // 更新活动状态\r\n    updateActiveStatus() {\r\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\r\n      \r\n      if (this.hasActiveOperations !== hasActive) {\r\n        this.hasActiveOperations = hasActive\r\n        if (hasActive) {\r\n          // 添加刷新拦截\r\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\r\n        } else {\r\n          // 移除刷新拦截\r\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\r\n        }\r\n      }\r\n    },\r\n    // 处理页面刷新\r\n    handleBeforeUnload(e) {\r\n      if (this.hasActiveOperations) {\r\n        const message = '有正在执行的操作，确定要离开吗？'\r\n        e.preventDefault()\r\n        e.returnValue = message\r\n        return message\r\n      }\r\n    }\r\n  },\r\n  watch: {\r\n    // 只监听数据变化\r\n    streamList: {\r\n      handler() {\r\n        this.updateLinkContent()\r\n        this.saveState()\r\n      },\r\n      deep: true\r\n    },\r\n    currentPage() {\r\n      this.saveState()\r\n    },\r\n    pageSize() {\r\n      this.saveState()\r\n    },\r\n    // 监听所有可能的运行状态\r\n    isChecking() {\r\n      this.updateActiveStatus()\r\n    },\r\n    isCollecting() {\r\n      this.updateActiveStatus()\r\n    },\r\n    isScheduled() {\r\n      this.updateActiveStatus()\r\n    }\r\n  },\r\n  // 组件被激活时（重新显示）\r\n  activated() {\r\n    // 如果有定时任务，恢复定时器\r\n    if (this.isScheduled) {\r\n      this.setupSchedule()\r\n    }\r\n    // 如果有采集任务，恢复采集\r\n    if (this.isCollecting) {\r\n      this.startCollecting(true)\r\n    }\r\n  },\r\n  // 组件被停用时（离开但不销毁）\r\n  deactivated() {\r\n    // 暂停定时器，但保持状态标志\r\n    if (this.scheduleTimer) {\r\n      clearInterval(this.scheduleTimer)\r\n      this.scheduleTimer = null\r\n    }\r\n    // 暂停采集定时器，但保持状态标志\r\n    if (this.collectTimer) {\r\n      clearInterval(this.collectTimer)\r\n      this.collectTimer = null\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.stream-check {\r\n  padding: 20px;\r\n  background-color: #fff;\r\n  border-radius: 4px;\r\n}\r\n\r\n.table-operations {\r\n  margin-bottom: 20px;\r\n  display: flex;\r\n  gap: 10px; /* 按钮组之间的间距 */\r\n}\r\n\r\n.pagination-container {\r\n  margin-top: 20px;\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n\r\n.el-button [class*=\"el-icon-\"] {\r\n  font-size: 18px;\r\n}\r\n\r\n.delete-btn {\r\n  color: #F56C6C;\r\n}\r\n\r\n.delete-btn:hover {\r\n  color: #ff4d4d;\r\n}\r\n\r\n.setting-tip {\r\n  margin-left: 10px;\r\n  color: #909399;\r\n  font-size: 13px;\r\n}\r\n\r\n.link-info {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 10px;\r\n}\r\n\r\n.link-info p {\r\n  margin: 0;\r\n  color: #606266;\r\n}\r\n\r\n.link-actions {\r\n  display: flex;\r\n  gap: 10px;\r\n  justify-content: flex-end;\r\n  margin-top: 10px;\r\n}\r\n\r\n/* 生成链接对话框样式 */\r\n.generate-link-dialog {\r\n  max-width: 600px;\r\n}\r\n\r\n.link-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 15px;\r\n}\r\n\r\n.link-card, .tips-card {\r\n  margin: 0;\r\n  border: 1px solid #EBEEF5;\r\n}\r\n\r\n.link-content {\r\n  padding: 10px;\r\n}\r\n\r\n.tips-content {\r\n  color: #606266;\r\n  font-size: 14px;\r\n  padding: 10px;\r\n}\r\n\r\n.tips-content ul {\r\n  margin: 0;\r\n  padding-left: 20px;\r\n  line-height: 1.8;\r\n}\r\n\r\n/* 覆盖 element-ui 的一些默认样式 */\r\n:deep(.el-dialog__body) {\r\n  padding: 20px;\r\n}\r\n\r\n:deep(.el-card__header) {\r\n  padding: 12px 20px;\r\n  font-weight: 500;\r\n}\r\n\r\n:deep(.el-card__body) {\r\n  padding: 15px;\r\n}\r\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      // No changes to data section\n    };\n  },\n  computed: {\n    // No changes to computed section\n  },\n  created() {\n    // No changes to created section\n  },\n  beforeDestroy() {\n    // No changes to beforeDestroy section\n  },\n  methods: {\n    async checkStream(stream) {\n      // No changes to checkStream method\n    },\n    async handleBatchCheck() {\n      // No changes to handleBatchCheck method\n    },\n    pauseCheck() {\n      // No changes to pauseCheck method\n    },\n    async resumeCheck() {\n      // No changes to resumeCheck method\n    },\n    async handleCheck(row) {\n      // No changes to handleCheck method\n    },\n    handleDelete(row) {\n      // No changes to handleDelete method\n    },\n    async handleUrlImport() {\n      // No changes to handleUrlImport method\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      const lines = content.split('\\n');\n      const streams = [];\n      let currentGroup = '未分组';\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = '';\n        let currentGroupTitle = '';\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = '';\n\n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i);\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim();\n            }\n\n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',');\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim();\n              }\n            }\n\n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i);\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim();\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i);\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim();\n                }\n              }\n            }\n            currentName = name || '未命名';\n\n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i);\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim();\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i);\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim();\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n            currentName = ''; // 重置当前名称\n          }\n        });\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '');\n            return;\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',');\n          if (!name || !urls) return;\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#');\n\n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n          });\n        });\n      }\n      return streams;\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream);\n      });\n      this.currentPage = 1;\n      this.saveStreamList(); // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (name.includes('cctv')) return 'CCTV';\n      if (name.includes('卫视')) return '卫视';\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空');\n        return;\n      }\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = [];\n        this.currentPage = 1;\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('列表已清空');\n      }).catch(() => {});\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && stream.status === '异常') {\n        return true;\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true';\n      const strictMode = localStorage.getItem('strictMode') === 'true';\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number);\n        if (extremeMode ? width < 1920 || height < 1080 : strictMode ? width < 1920 || height < 1080 : width < 1280 || height < 720) {\n          return true;\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && stream.responseTime > (extremeMode ? 1500 : strictMode ? 2000 : 3000)) {\n        return true;\n      }\n      return false;\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState();\n\n      // 立即执行一次采集\n      await this.collect();\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        if (this.collectForm.timeType === 'interval') {\n          // 使用间隔时间\n          this.collectTimer = setInterval(async () => {\n            await this.collect();\n          }, this.collectForm.interval * 60 * 1000);\n        } else if (this.collectForm.timeType === 'daily') {\n          // 使用每天固定时间\n          this.setupDailyCollect();\n        } else {\n          // 使用每周固定时间\n          this.setupWeeklyCollect();\n        }\n      } else {\n        // 单次采集完成后自动停止\n        this.isCollecting = false;\n        this.saveState();\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集');\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集');\n          return;\n        }\n        this.$message.info('开始采集直播源...');\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(this.collectForm.urls.map(async url => {\n          try {\n            const response = await fetch(url);\n            if (!response.ok) throw new Error(`采集失败: ${url}`);\n            const content = await response.text();\n            const newStreams = this.parseContent(content);\n\n            // 过滤重复的直播源，同时考虑正在检测的源\n            const existingUrls = new Set(this.streamList.map(s => s.url));\n            return newStreams.filter(s => {\n              // 如果源已存在且正在检测中，保留原有状态\n              const existingStream = this.streamList.find(es => es.url === s.url);\n              if (existingStream && existingStream.status === '检测中') {\n                return false;\n              }\n              return !existingUrls.has(s.url);\n            });\n          } catch (error) {\n            console.error(`采集地址 ${url} 失败:`, error);\n            return [];\n          }\n        }));\n\n        // 合并所有采集结果\n        const allNewStreams = results.filter(result => result.status === 'fulfilled').flatMap(result => result.value).filter((stream, index, self) => index === self.findIndex(s => s.url === stream.url));\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams);\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`);\n        } else {\n          this.$message.info('未发现新的直播源');\n        }\n\n        // 统计失败的地址\n        const failedUrls = results.filter(result => result.status === 'rejected').length;\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`);\n        }\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message);\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      }\n    },\n    async handleGenerateLink() {\n      try {\n        this.generateLinkDialogVisible = true;\n        const content = this.generateContent();\n        const format = this.linkForm.format;\n        const response = await fetch('http://localhost:8080/api/generate-link', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': format // 添加格式标记\n          },\n          body: content\n        });\n        if (!response.ok) {\n          throw new Error('生成链接失败');\n        }\n        this.generatedLink = await response.text();\n      } catch (error) {\n        this.$message.error('生成链接失败：' + error.message);\n      }\n    },\n    generateContent() {\n      return this.linkForm.format === 'm3u' ? this.generateM3uContent() : this.generateTxtContent();\n    },\n    generateTxtContent() {\n      let content = '';\n      let currentGroup = '';\n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `${currentGroup},#genre#\\n`;\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`;\n      });\n      return content.trim();\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n';\n      let currentGroup = '';\n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`;\n        }\n        // 对于多个URL，创建多个条目\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`;\n        });\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        const content = this.generateContent();\n        await fetch('http://localhost:8080/api/update-content', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n\n      // 计算检查间隔（转换为毫秒）\n      const interval = this.scheduleForm.unit === 'second' ? this.scheduleForm.interval * 1000 : this.scheduleForm.interval * 60 * 1000;\n\n      // 设置下次执行时间\n      this.nextScheduleTime = new Date(Date.now() + interval);\n\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000;\n      this.scheduleTimer = setInterval(() => {\n        const now = new Date();\n\n        // 如果当前正在检测中，跳过这次执行\n        if (this.isChecking) {\n          return;\n        }\n\n        // 检查是否到达执行时间\n        if (now >= this.nextScheduleTime) {\n          this.handleBatchCheck();\n          // 更新下次执行时间\n          this.nextScheduleTime = new Date(Date.now() + interval);\n        }\n      }, checkInterval);\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      // 只保存基础数据和设置，不保存运行状态\n      const state = {\n        streamList: this.streamList,\n        currentPage: this.currentPage,\n        pageSize: this.pageSize,\n        scheduleForm: this.scheduleForm,\n        collectForm: this.collectForm\n      };\n      localStorage.setItem(this.stateKey, JSON.stringify(state));\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 只恢复基础数据和设置\n          this.streamList = state.streamList || [];\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          this.scheduleForm = state.scheduleForm || this.scheduleForm;\n          this.collectForm = state.collectForm || this.collectForm;\n\n          // 重置所有运行状态\n          this.isChecking = false;\n          this.isPaused = false;\n          this.isScheduled = false;\n          this.isCollecting = false;\n          this.checkedCount = 0;\n          this.totalCount = 0;\n          this.pausedIndex = -1;\n          this.nextScheduleTime = null;\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error);\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', ['']);\n      } else {\n        this.collectForm.urls.push('');\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1);\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info';\n      const [width] = resolution.split('x').map(Number);\n      if (width >= 1920) return 'success';\n      if (width >= 1280) return ''; // 默认类型\n      return 'warning';\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info';\n      if (responseTime <= 1000) return 'success';\n      if (responseTime <= 2000) return ''; // 默认类型\n      if (responseTime <= 3000) return 'warning';\n      return 'danger';\n    },\n    setupWeeklyCollect() {\n      const calculateNextTime = () => {\n        const now = new Date();\n        const targetTime = new Date(this.collectForm.time);\n        const targetHours = targetTime.getHours();\n        const targetMinutes = targetTime.getMinutes();\n        let targetDate = new Date(now);\n        targetDate.setHours(targetHours, targetMinutes, 0, 0);\n\n        // 如果今天的目标时间已过，或者不是目标星期，找下一个符合的日期\n        while (targetDate <= now || targetDate.getDay() !== this.collectForm.weekday) {\n          targetDate.setDate(targetDate.getDate() + 1);\n          targetDate.setHours(targetHours, targetMinutes, 0, 0);\n        }\n        return targetDate;\n      };\n      const scheduleNext = () => {\n        const nextTime = calculateNextTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n        this.collectTimer = setTimeout(async () => {\n          await this.collect();\n          scheduleNext(); // 安排下一次采集\n        }, delay);\n      };\n      scheduleNext();\n    },\n    setupDailyCollect() {\n      const calculateNextTime = () => {\n        const now = new Date();\n        const targetTime = new Date(this.collectForm.dailyTime);\n        const targetHours = targetTime.getHours();\n        const targetMinutes = targetTime.getMinutes();\n        let targetDate = new Date(now);\n        targetDate.setHours(targetHours, targetMinutes, 0, 0);\n\n        // 如果今天的目标时间已过，设置为明天\n        if (targetDate <= now) {\n          targetDate.setDate(targetDate.getDate() + 1);\n        }\n        return targetDate;\n      };\n      const scheduleNext = () => {\n        const nextTime = calculateNextTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n        this.collectTimer = setTimeout(async () => {\n          await this.collect();\n          scheduleNext(); // 安排下一次采集\n        }, delay);\n      };\n      scheduleNext();\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink();\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true);\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","computed","created","beforeDestroy","methods","checkStream","stream","handleBatchCheck","pauseCheck","resumeCheck","handleCheck","row","handleDelete","handleUrlImport","readFile","file","Promise","resolve","reject","reader","FileReader","onload","e","target","result","onerror","Error","readAsText","parseContent","content","lines","split","streams","currentGroup","includes","currentName","currentGroupTitle","forEach","line","trim","startsWith","tvgNameMatch","match","lastCommaIndex","lastIndexOf","substring","tvgIdMatch","tvgIdNoQuoteMatch","groupMatch","groupNoQuoteMatch","push","url","group","status","resolution","responseTime","endsWith","replace","urls","urlList","addStreamsToList","streamList","currentPage","saveStreamList","handleSizeChange","val","pageSize","handleCurrentChange","handleFileUpload","event","files","newStreams","length","existingUrls","Set","map","s","uniqueStreams","filter","has","$message","success","info","warning","error","message","value","getGroupFromFileName","filename","toLowerCase","handleClearList","$confirm","confirmButtonText","cancelButtonText","type","then","catch","handleCopy","textarea","document","createElement","body","appendChild","select","execCommand","err","removeChild","shouldRemoveStream","localStorage","getItem","extremeMode","strictMode","width","height","Number","setItem","JSON","stringify","handleCollectMode","isCollecting","stopCollecting","collectDialogVisible","startCollecting","isRestore","valid","$refs","collectForm","validate","saveState","collect","autoCollect","timeType","collectTimer","setInterval","interval","setupDailyCollect","setupWeeklyCollect","clearInterval","isChecking","results","allSettled","response","fetch","ok","text","existingStream","find","es","console","allNewStreams","flatMap","index","self","findIndex","failedUrls","handleGenerateLink","generateLinkDialogVisible","generateContent","format","linkForm","method","headers","generatedLink","generateM3uContent","generateTxtContent","mergedStreams","join","copyGeneratedLink","downloadTxtFile","blob","Blob","window","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","updateLinkContent","handleScheduleCheck","isScheduled","stopScheduleCheck","scheduleDialogVisible","startScheduleCheck","scheduleForm","setupSchedule","scheduleTimer","nextScheduleTime","unit","now","checkInterval","state","stateKey","restoreState","savedState","parse","isPaused","checkedCount","totalCount","pausedIndex","resetAllStates","shouldStop","updateActiveStatus","hasActive","hasActiveOperations","addEventListener","handleBeforeUnload","removeEventListener","preventDefault","returnValue","addCollectUrl","Array","isArray","$set","removeCollectUrl","splice","getResolutionTagType","getResponseTimeTagType","calculateNextTime","targetTime","time","targetHours","getHours","targetMinutes","getMinutes","targetDate","setHours","getDay","weekday","setDate","getDate","scheduleNext","nextTime","delay","getTime","setTimeout","dailyTime","watch","handler","deep","linkForm.format","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\n  <!-- No changes to template section -->\n</template>\n\n<script>\nexport default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      // No changes to data section\n    }\n  },\n  computed: {\n    // No changes to computed section\n  },\n  created() {\n    // No changes to created section\n  },\n  beforeDestroy() {\n    // No changes to beforeDestroy section\n  },\n  methods: {\n    async checkStream(stream) {\n      // No changes to checkStream method\n    },\n    async handleBatchCheck() {\n      // No changes to handleBatchCheck method\n    },\n    pauseCheck() {\n      // No changes to pauseCheck method\n    },\n    async resumeCheck() {\n      // No changes to resumeCheck method\n    },\n    async handleCheck(row) {\n      // No changes to handleCheck method\n    },\n    handleDelete(row) {\n      // No changes to handleDelete method\n    },\n    async handleUrlImport() {\n      // No changes to handleUrlImport method\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = (e) => resolve(e.target.result)\n        reader.onerror = () => reject(new Error('文件读取失败'))\n        reader.readAsText(file)\n      })\n    },\n    parseContent(content) {\n      const lines = content.split('\\n')\n      const streams = []\n      let currentGroup = '未分组'\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = ''\n        let currentGroupTitle = ''\n\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = ''\n            \n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i)\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim()\n            }\n            \n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',')\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim()\n              }\n            }\n            \n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i)\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim()\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i)\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim()\n                }\n              }\n            }\n\n            currentName = name || '未命名'\n            \n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i)\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim()\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i)\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim()\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n            currentName = ''  // 重置当前名称\n          }\n        })\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '')\n            return\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',')\n          if (!name || !urls) return\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#')\n          \n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n          })\n        })\n      }\n\n      return streams\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream)\n      })\n      this.currentPage = 1\n      this.saveStreamList()  // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase()\n      if (name.includes('cctv')) return 'CCTV'\n      if (name.includes('卫视')) return '卫视'\n      if (name.includes('地方')) return '地方台'\n      return '未分组'\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空')\n        return\n      }\n\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = []\n        this.currentPage = 1\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('列表已清空')\n      }).catch(() => {})\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea')\n      textarea.value = row.url\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && \n          stream.status === '异常') {\n        return true\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true'\n      const strictMode = localStorage.getItem('strictMode') === 'true'\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && \n          stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number)\n        if (extremeMode ? (width < 1920 || height < 1080) : \n            (strictMode ? (width < 1920 || height < 1080) : (width < 1280 || height < 720))) {\n          return true\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && \n          stream.responseTime > (extremeMode ? 1500 : (strictMode ? 2000 : 3000))) {\n        return true\n      }\n\n      return false\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting()\n      } else {\n        this.collectDialogVisible = true\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        const valid = await this.$refs.collectForm.validate()\n        if (!valid) return\n      }\n\n      this.collectDialogVisible = false\n      this.isCollecting = true\n      this.saveState()\n\n      // 立即执行一次采集\n      await this.collect()\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        if (this.collectForm.timeType === 'interval') {\n          // 使用间隔时间\n          this.collectTimer = setInterval(async () => {\n            await this.collect()\n          }, this.collectForm.interval * 60 * 1000)\n        } else if (this.collectForm.timeType === 'daily') {\n          // 使用每天固定时间\n          this.setupDailyCollect()\n        } else {\n          // 使用每周固定时间\n          this.setupWeeklyCollect()\n        }\n      } else {\n        // 单次采集完成后自动停止\n        this.isCollecting = false\n        this.saveState()\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      this.saveState() // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集')\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集')\n          return\n        }\n\n        this.$message.info('开始采集直播源...')\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(\n          this.collectForm.urls.map(async url => {\n            try {\n              const response = await fetch(url)\n              if (!response.ok) throw new Error(`采集失败: ${url}`)\n              \n              const content = await response.text()\n              const newStreams = this.parseContent(content)\n              \n              // 过滤重复的直播源，同时考虑正在检测的源\n              const existingUrls = new Set(this.streamList.map(s => s.url))\n              return newStreams.filter(s => {\n                // 如果源已存在且正在检测中，保留原有状态\n                const existingStream = this.streamList.find(es => es.url === s.url)\n                if (existingStream && existingStream.status === '检测中') {\n                  return false\n                }\n                return !existingUrls.has(s.url)\n              })\n            } catch (error) {\n              console.error(`采集地址 ${url} 失败:`, error)\n              return []\n            }\n          })\n        )\n\n        // 合并所有采集结果\n        const allNewStreams = results\n          .filter(result => result.status === 'fulfilled')\n          .flatMap(result => result.value)\n          .filter((stream, index, self) => \n            index === self.findIndex(s => s.url === stream.url)\n          )\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams)\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`)\n        } else {\n          this.$message.info('未发现新的直播源')\n        }\n\n        // 统计失败的地址\n        const failedUrls = results\n          .filter(result => result.status === 'rejected')\n          .length\n\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`)\n        }\n\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message)\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting()\n        }\n      }\n    },\n    async handleGenerateLink() {\n      try {\n        this.generateLinkDialogVisible = true\n        \n        const content = this.generateContent()\n        const format = this.linkForm.format\n        \n        const response = await fetch('http://localhost:8080/api/generate-link', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': format // 添加格式标记\n          },\n          body: content\n        })\n\n        if (!response.ok) {\n          throw new Error('生成链接失败')\n        }\n\n        this.generatedLink = await response.text()\n      } catch (error) {\n        this.$message.error('生成链接失败：' + error.message)\n      }\n    },\n    generateContent() {\n      return this.linkForm.format === 'm3u' \n        ? this.generateM3uContent() \n        : this.generateTxtContent()\n    },\n    generateTxtContent() {\n      let content = ''\n      let currentGroup = ''\n      \n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `${currentGroup},#genre#\\n`\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`\n      })\n      \n      return content.trim()\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n'\n      let currentGroup = ''\n      \n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`\n        }\n        // 对于多个URL，创建多个条目\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`\n        })\n      })\n      \n      return content.trim()\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea')\n      textarea.value = this.generatedLink\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\n      \n      document.body.appendChild(link)\n      link.click()\n      \n      // 清理\n      window.URL.revokeObjectURL(url)\n      document.body.removeChild(link)\n      this.$message.success('文件下载成功')\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        const content = this.generateContent()\n        await fetch('http://localhost:8080/api/update-content', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        })\n      } catch (error) {\n        console.error('更新链接内容失败：', error)\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      } else {\n        this.scheduleDialogVisible = true\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false\n          this.isScheduled = true\n          this.setupSchedule()\n          this.saveState() // 保存状态\n          this.$message.success('定时检测已开启')\n        }\n      })\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      this.isScheduled = false\n      this.nextScheduleTime = null\n      this.saveState() // 保存状态\n      this.$message.success('定时检测已停止')\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n      }\n\n      // 计算检查间隔（转换为毫秒）\n      const interval = this.scheduleForm.unit === 'second' \n        ? this.scheduleForm.interval * 1000 \n        : this.scheduleForm.interval * 60 * 1000\n      \n      // 设置下次执行时间\n      this.nextScheduleTime = new Date(Date.now() + interval)\n\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000\n\n      this.scheduleTimer = setInterval(() => {\n        const now = new Date()\n        \n        // 如果当前正在检测中，跳过这次执行\n        if (this.isChecking) {\n          return\n        }\n\n        // 检查是否到达执行时间\n        if (now >= this.nextScheduleTime) {\n          this.handleBatchCheck()\n          // 更新下次执行时间\n          this.nextScheduleTime = new Date(Date.now() + interval)\n        }\n      }, checkInterval)\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      // 只保存基础数据和设置，不保存运行状态\n      const state = {\n        streamList: this.streamList,\n        currentPage: this.currentPage,\n        pageSize: this.pageSize,\n        scheduleForm: this.scheduleForm,\n        collectForm: this.collectForm\n      }\n      localStorage.setItem(this.stateKey, JSON.stringify(state))\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey)\n        if (savedState) {\n          const state = JSON.parse(savedState)\n          \n          // 只恢复基础数据和设置\n          this.streamList = state.streamList || []\n          this.currentPage = state.currentPage || 1\n          this.pageSize = state.pageSize || 5\n          this.scheduleForm = state.scheduleForm || this.scheduleForm\n          this.collectForm = state.collectForm || this.collectForm\n\n          // 重置所有运行状态\n          this.isChecking = false\n          this.isPaused = false\n          this.isScheduled = false\n          this.isCollecting = false\n          this.checkedCount = 0\n          this.totalCount = 0\n          this.pausedIndex = -1\n          this.nextScheduleTime = null\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error)\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      }\n      \n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting()\n      }\n      \n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n      }\n      \n      // 重置所有状态\n      this.isChecking = false\n      this.isPaused = false\n      this.isScheduled = false\n      this.isCollecting = false\n      this.checkedCount = 0\n      this.totalCount = 0\n      this.pausedIndex = -1\n      this.nextScheduleTime = null\n      \n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      \n      // 保存重置后的状态\n      this.saveState()\n      \n      this.$message.success('所有运行状态已重置')\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\n      \n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？'\n        e.preventDefault()\n        e.returnValue = message\n        return message\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', [''])\n      } else {\n        this.collectForm.urls.push('')\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1)\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info'\n      const [width] = resolution.split('x').map(Number)\n      if (width >= 1920) return 'success'\n      if (width >= 1280) return ''  // 默认类型\n      return 'warning'\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info'\n      if (responseTime <= 1000) return 'success'\n      if (responseTime <= 2000) return ''  // 默认类型\n      if (responseTime <= 3000) return 'warning'\n      return 'danger'\n    },\n    setupWeeklyCollect() {\n      const calculateNextTime = () => {\n        const now = new Date()\n        const targetTime = new Date(this.collectForm.time)\n        const targetHours = targetTime.getHours()\n        const targetMinutes = targetTime.getMinutes()\n        \n        let targetDate = new Date(now)\n        targetDate.setHours(targetHours, targetMinutes, 0, 0)\n        \n        // 如果今天的目标时间已过，或者不是目标星期，找下一个符合的日期\n        while (targetDate <= now || targetDate.getDay() !== this.collectForm.weekday) {\n          targetDate.setDate(targetDate.getDate() + 1)\n          targetDate.setHours(targetHours, targetMinutes, 0, 0)\n        }\n        \n        return targetDate\n      }\n      \n      const scheduleNext = () => {\n        const nextTime = calculateNextTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n        \n        this.collectTimer = setTimeout(async () => {\n          await this.collect()\n          scheduleNext() // 安排下一次采集\n        }, delay)\n      }\n      \n      scheduleNext()\n    },\n    setupDailyCollect() {\n      const calculateNextTime = () => {\n        const now = new Date()\n        const targetTime = new Date(this.collectForm.dailyTime)\n        const targetHours = targetTime.getHours()\n        const targetMinutes = targetTime.getMinutes()\n        \n        let targetDate = new Date(now)\n        targetDate.setHours(targetHours, targetMinutes, 0, 0)\n        \n        // 如果今天的目标时间已过，设置为明天\n        if (targetDate <= now) {\n          targetDate.setDate(targetDate.getDate() + 1)\n        }\n        \n        return targetDate\n      }\n      \n      const scheduleNext = () => {\n        const nextTime = calculateNextTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n        \n        this.collectTimer = setTimeout(async () => {\n          await this.collect()\n          scheduleNext() // 安排下一次采集\n        }, delay)\n      }\n      \n      scheduleNext()\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent()\n        this.saveState()\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState()\n    },\n    pageSize() {\n      this.saveState()\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus()\n    },\n    isCollecting() {\n      this.updateActiveStatus()\n    },\n    isScheduled() {\n      this.updateActiveStatus()\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink()\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true)\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer)\n      this.scheduleTimer = null\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n      this.collectTimer = null\n    }\n  }\n}\n</script>\n\n<style scoped>\n.stream-check {\n  padding: 0px;\n  background-color: #fff;\n  border-radius: 4px;\n}\n\n.table-operations {\n  margin-bottom: 20px;\n  display: flex;\n  gap: 10px; /* 按钮组之间的间距 */\n}\n\n.pagination-container {\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n}\n\n.el-button [class*=\"el-icon-\"] {\n  font-size: 18px;\n}\n\n.delete-btn {\n  color: #F56C6C;\n}\n\n.delete-btn:hover {\n  color: #ff4d4d;\n}\n\n.setting-tip {\n  margin-left: 10px;\n  color: #909399;\n  font-size: 13px;\n}\n\n.link-info {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.link-info p {\n  margin: 0;\n  color: #606266;\n}\n\n.link-actions {\n  display: flex;\n  gap: 10px;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n/* 生成链接对话框样式 */\n.generate-link-dialog {\n  max-width: 600px;\n}\n\n.link-container {\n  display: flex;\n  flex-direction: column;\n  gap: 15px;\n}\n\n.link-card, .tips-card {\n  margin: 0;\n  border: 1px solid #EBEEF5;\n}\n\n.link-content {\n  padding: 10px;\n}\n\n.tips-content {\n  color: #606266;\n  font-size: 14px;\n  padding: 10px;\n}\n\n.tips-content ul {\n  margin: 0;\n  padding-left: 20px;\n  line-height: 1.8;\n}\n\n/* 覆盖 element-ui 的一些默认样式 */\n:deep(.el-dialog__body) {\n  padding: 20px;\n}\n\n:deep(.el-card__header) {\n  padding: 12px 20px;\n  font-weight: 500;\n}\n\n:deep(.el-card__body) {\n  padding: 15px;\n}\n\n/* 可以添加一些自定义样式 */\n.el-tag {\n  width: 90px;  /* 统一标签宽度 */\n}\n\n.el-tag + .el-tag {\n  margin-left: 4px;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
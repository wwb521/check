{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importForm: {\n        url: '',\n        group: ''\n      },\n      importRules: {\n        url: [{\n          required: true,\n          message: '请输入URL地址',\n          trigger: 'blur'\n        }, {\n          type: 'url',\n          message: '请输入正确的URL地址',\n          trigger: ['blur', 'change']\n        }],\n        group: [{\n          required: true,\n          message: '请选择分组',\n          trigger: 'change'\n        }]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        autoCollect: false,\n        collectType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      collectRules: {\n        urls: [{\n          type: 'array',\n          validator: (rule, value, callback) => {\n            if (value.length === 0) {\n              callback(new Error('请至少添加一个采集地址'));\n            }\n            // 验证每个URL\n            const errors = value.map(url => {\n              if (!url) return '采集地址不能为空';\n              if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址';\n              return null;\n            }).filter(error => error !== null);\n            if (errors.length > 0) {\n              callback(new Error(errors[0]));\n            } else {\n              callback();\n            }\n          },\n          trigger: 'change'\n        }],\n        executeTime: [{\n          required: true,\n          message: '请选择执行时间',\n          trigger: 'change'\n        }],\n        weekDay: [{\n          required: true,\n          message: '请选择执行日期',\n          trigger: 'change'\n        }]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',\n      // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        scheduleType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      scheduleRules: {\n        executeTime: [{\n          required: true,\n          message: '请选择执行时间',\n          trigger: 'change'\n        }],\n        weekDay: [{\n          required: true,\n          message: '请选择执行日期',\n          trigger: 'change'\n        }]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState',\n      // 用于本地存储的key\n      hasActiveOperations: false,\n      // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      },\n      searchDialogVisible: false,\n      searchForm: {\n        name: '',\n        group: '',\n        status: ''\n      },\n      filteredList: [],\n      // 用于存储搜索过滤后的列表\n      realIp: '',\n      // 存储真实IP地址\n      syncDialogVisible: false,\n      syncForm: {\n        token: localStorage.getItem('githubToken') || '',\n        repo: localStorage.getItem('githubRepo') || '',\n        txtPath: localStorage.getItem('githubTxtPath') || '',\n        m3uPath: localStorage.getItem('githubM3uPath') || '',\n        autoSync: localStorage.getItem('githubAutoSync') === 'true',\n        syncType: localStorage.getItem('githubSyncType') || 'daily',\n        executeTime: localStorage.getItem('githubExecuteTime') || '00:00',\n        weekDay: localStorage.getItem('githubWeekDay') || '1',\n        message: '更新直播源列表'\n      },\n      syncRules: {\n        token: [{\n          required: true,\n          message: '请输入GitHub Token',\n          trigger: 'blur'\n        }],\n        repo: [{\n          required: true,\n          message: '请输入仓库名称',\n          trigger: 'blur'\n        }, {\n          pattern: /^[\\w-]+\\/[\\w-]+$/,\n          message: '格式：用户名/仓库名',\n          trigger: 'blur'\n        }],\n        txtPath: [{\n          required: true,\n          message: '请输入文件路径',\n          trigger: 'blur'\n        }],\n        m3uPath: [{\n          required: true,\n          message: '请输入文件路径',\n          trigger: 'blur'\n        }],\n        message: [{\n          required: true,\n          message: '请输入提交消息',\n          trigger: 'blur'\n        }]\n      },\n      syncTimer: null\n    };\n  },\n  computed: {\n    paginatedData() {\n      // 使用过滤后的列表进行分页\n      const start = (this.currentPage - 1) * this.pageSize;\n      const end = start + this.pageSize;\n      return (this.filteredList.length > 0 ? this.filteredList : this.streamList).slice(start, end);\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测';\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`;\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map();\n\n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name; // 使用名称作为键\n\n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key);\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url);\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          });\n        }\n      });\n\n      // 转换回数组格式\n      return Array.from(streamMap.values());\n    },\n    groupOptions() {\n      return [...new Set(this.streamList.map(item => item.group))];\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList');\n      if (savedList) {\n        this.streamList = JSON.parse(savedList);\n        // 初始化时检查多播源\n        this.$nextTick(() => {\n          this.recheckMulticastStreams();\n        });\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList);\n\n    // 监听设置更新事件\n    this.$root.$on('settings-updated', this.handleSettingsUpdate);\n\n    // 从本地存储恢复状态\n    this.restoreState();\n\n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true); // true表示是恢复状态\n    }\n    // 如果GitHub自动同步是开启状态，重新启动同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule();\n    }\n    this.filteredList = [];\n    this.getRealIp(); // 获取真实IP地址\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList);\n    this.$root.$off('settings-updated', this.handleSettingsUpdate);\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck();\n    // 在组件销毁前保存状态\n    this.saveState();\n    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n  },\n  methods: {\n    // 添加处理设置更新的方法\n    handleSettingsUpdate(event) {\n      console.log('收到设置更新事件:', event);\n      // 如果是自动清除未知源设置被更改，重新检查所有未知源\n      if (event && event.type === 'autoRemoveMulticast') {\n        console.log('自动清除未知源设置已更改为:', event.value);\n\n        // 更新本地存储中的设置\n        try {\n          let settings = {};\n          const savedSettings = localStorage.getItem('appSettings');\n          if (savedSettings) {\n            settings = JSON.parse(savedSettings);\n          }\n          settings.autoRemoveMulticast = event.value;\n          localStorage.setItem('appSettings', JSON.stringify(settings));\n          console.log('设置已更新，当前设置:', settings);\n\n          // 如果启用了自动清除，立即执行检查\n          if (event.value === true) {\n            console.log('设置已启用，开始检查未知源...');\n            this.$nextTick(() => {\n              this.recheckUnknownStreams();\n            });\n          }\n        } catch (error) {\n          console.error('更新设置失败:', error);\n        }\n      }\n    },\n    // 修改为检查未知源的方法\n    recheckUnknownStreams() {\n      try {\n        // 直接从 localStorage 获取设置\n        const autoRemoveEnabled = localStorage.getItem('appSettings');\n        if (!autoRemoveEnabled) {\n          console.log('未找到设置配置');\n          return;\n        }\n        let settings;\n        try {\n          settings = JSON.parse(autoRemoveEnabled);\n        } catch (e) {\n          console.error('解析设置失败:', e);\n          return;\n        }\n\n        // 调试输出\n        console.log('当前设置状态:', settings);\n\n        // 严格检查 autoRemoveMulticast 的值\n        if (settings.autoRemoveMulticast !== true) {\n          console.log('自动清除未知源功能未启用，当前值:', settings.autoRemoveMulticast);\n          return;\n        }\n        console.log('开始执行自动清除未知源...');\n        let removedCount = 0;\n        const toRemove = [];\n\n        // 先收集需要删除的索引\n        this.streamList.forEach((stream, index) => {\n          if (stream.status === '未知') {\n            toRemove.push(index);\n            removedCount++;\n          }\n        });\n\n        // 从后向前删除\n        for (let i = toRemove.length - 1; i >= 0; i--) {\n          const index = toRemove[i];\n          const stream = this.streamList[index];\n          console.log('正在删除未知源:', stream.name, stream.url);\n          this.streamList.splice(index, 1);\n        }\n        if (removedCount > 0) {\n          console.log(`成功清除 ${removedCount} 个未知状态的直播源`);\n          this.$message.warning(`已自动清除 ${removedCount} 个未知状态的直播源`);\n          this.saveStreamList();\n\n          // 如果当前页没有数据，跳转到上一页\n          if (this.paginatedData.length === 0 && this.currentPage > 1) {\n            this.currentPage--;\n          }\n        } else {\n          console.log('没有找到需要清除的未知源');\n        }\n      } catch (error) {\n        console.error('检查未知源失败:', error);\n      }\n    },\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath');\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径');\n        return false;\n      }\n\n      // 检查是否是多播源\n      const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url);\n      if (isMulticast) {\n        // 设置为未知状态\n        stream.status = '未知';\n        stream.resolution = '多播源';\n        stream.responseTime = '-';\n        try {\n          const savedSettings = localStorage.getItem('appSettings');\n          if (!savedSettings) {\n            return false;\n          }\n          const settings = JSON.parse(savedSettings);\n          // 如果启用了自动清除未知源\n          if (settings.autoRemoveMulticast === true) {\n            const index = this.streamList.findIndex(s => s.url === stream.url);\n            if (index > -1) {\n              this.streamList.splice(index, 1);\n              this.$message.warning(`已自动清除未知状态直播源: ${stream.name}`);\n              this.saveStreamList();\n              if (this.paginatedData.length === 1 && this.currentPage > 1) {\n                this.currentPage--;\n              }\n              return false;\n            }\n          }\n        } catch (error) {\n          console.error('处理未知源时出错:', error);\n        }\n        return false;\n      }\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n\n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常';\n        stream.resolution = result.resolution || '-';\n        stream.responseTime = result.responseTime || '-';\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = '';\n          if (stream.status === '异常') {\n            reason = '异常源';\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢';\n          } else {\n            reason = '分辨率过低';\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData;\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream);\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`);\n          }\n        }\n        this.saveStreamList();\n        return result.available;\n      } catch (error) {\n        console.error('检测错误:', error);\n        stream.status = '异常';\n        return false;\n      }\n    },\n    async handleBatchCheck() {\n      if (this.isChecking) return;\n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex);\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源');\n        return;\n      }\n      this.isChecking = true;\n      this.shouldStop = false;\n      this.totalCount = uncheckedStreams.length;\n      this.checkedCount = this.isPaused ? this.checkedCount : 0;\n\n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3;\n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0;\n\n        // 分批处理，每批次处理固定数量的流\n        const batchSize = Math.min(concurrentChecks, 10); // 限制最大并发数\n\n        for (let i = startIndex; i < uncheckedStreams.length; i += batchSize) {\n          if (this.shouldStop) break;\n\n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + batchSize);\n\n          // 添加延时，让浏览器有时间响应\n          await new Promise(resolve => setTimeout(resolve, 100));\n\n          // 并发检测当前批次的所有流\n          await Promise.all(batch.map(async stream => {\n            if (this.shouldStop) return;\n            try {\n              stream.status = '检测中';\n              const success = await this.checkStream(stream);\n              this.checkedCount++;\n              if (success) {\n                this.saveState();\n              }\n            } catch (error) {\n              console.error('检测流失败:', error);\n              stream.status = '异常';\n              this.checkedCount++;\n            }\n          }));\n\n          // 更新暂停位置\n          this.pausedIndex = i + batchSize - 1;\n\n          // 每批次完成后保存状态\n          this.saveState();\n        }\n        if (!this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = false;\n          this.pausedIndex = -1;\n          this.$message.success('批量检测完成');\n\n          // 检查是否需要在批量检测完成后同步\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath);\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath);\n            this.$message.success('已同步到GitHub');\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error);\n        this.$message.error('批量检测失败');\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = true;\n          this.$message.info('检测已暂停');\n        }\n      }\n    },\n    pauseCheck() {\n      this.shouldStop = true;\n    },\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true;\n        this.isPaused = false;\n        this.shouldStop = false;\n        await this.batchCheck(this.pausedIndex);\n      }\n    },\n    async handleCheck(row) {\n      row.status = '检测中';\n      const success = await this.checkStream(row);\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`);\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row);\n        this.streamList.splice(index, 1);\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('删除成功');\n      }).catch(() => {});\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate();\n      if (!valid) return;\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importForm.url\n          })\n        });\n        if (!response.ok) throw new Error('导入失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            // 在添加前检查多播源\n            uniqueStreams.forEach(stream => {\n              const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url);\n              if (isMulticast) {\n                stream.status = '未知';\n                stream.resolution = '多播源';\n                stream.responseTime = '-';\n              }\n            });\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n            this.importUrlDialogVisible = false;\n\n            // 导入后立即检查未知源\n            this.$nextTick(() => {\n              this.recheckUnknownStreams();\n            });\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message);\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      const lines = content.split('\\n');\n      const streams = [];\n      let currentGroup = '未分组';\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = '';\n        let currentGroupTitle = '';\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = '';\n\n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i);\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim();\n            }\n\n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',');\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim();\n              }\n            }\n\n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i);\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim();\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i);\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim();\n                }\n              }\n            }\n            currentName = name || '未命名';\n\n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i);\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim();\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i);\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim();\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '-',\n                responseTime: '-'\n              });\n            }\n            currentName = ''; // 重置当前名称\n          }\n        });\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '');\n            return;\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',');\n          if (!name || !urls) return;\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#');\n\n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '-',\n                responseTime: '-'\n              });\n            }\n          });\n        });\n      }\n      return streams;\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream);\n      });\n      this.currentPage = 1;\n      this.saveStreamList(); // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            // 在添加前检查多播源\n            uniqueStreams.forEach(stream => {\n              const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url);\n              if (isMulticast) {\n                stream.status = '未知';\n                stream.resolution = '多播源';\n                stream.responseTime = '-';\n              }\n            });\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n\n            // 导入后立即检查未知源\n            this.$nextTick(() => {\n              this.recheckUnknownStreams();\n            });\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (name.includes('cctv')) return 'CCTV';\n      if (name.includes('卫视')) return '卫视';\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      this.$confirm('确认清空列表吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 只重置批量检测相关的状态\n        this.streamList = [];\n        this.currentPage = 1;\n        this.isChecking = false;\n        this.isPaused = false;\n        this.checkIndex = 0;\n\n        // 更新链接内容和保存状态\n        this.updateLinkContent();\n        this.saveState();\n        this.$message({\n          type: 'success',\n          message: '列表已清空'\n        });\n      }).catch(() => {\n        this.$message({\n          type: 'info',\n          message: '已取消清空'\n        });\n      });\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除未知状态的源\n      if (localStorage.getItem('autoRemoveMulticast') === 'true' && stream.status === '未知') {\n        return true;\n      }\n\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && stream.status === '异常') {\n        return true;\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true';\n      const strictMode = localStorage.getItem('strictMode') === 'true';\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && stream.resolution !== '未知' && stream.resolution !== '多播源' && stream.resolution !== '-') {\n        const [width, height] = stream.resolution.split('x').map(Number);\n        if (extremeMode ? width < 1920 || height < 1080 : strictMode ? width < 1920 || height < 1080 : width < 1280 || height < 720) {\n          return true;\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && stream.responseTime !== '-' && Number(stream.responseTime) > (extremeMode ? 1500 : strictMode ? 2000 : 3000)) {\n        return true;\n      }\n      return false;\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', ['']);\n          return;\n        }\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState(); // 保存状态\n\n      // 立即执行一次采集\n      await this.collect();\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule();\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false;\n        this.saveState();\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集');\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集');\n          return;\n        }\n        this.$message.info('开始采集直播源...');\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(this.collectForm.urls.map(async url => {\n          try {\n            const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n              method: 'GET',\n              headers: {\n                'Accept': 'text/plain'\n              }\n            });\n            if (!response.ok) throw new Error(`采集失败: ${url}`);\n            const content = await response.text();\n            const newStreams = this.parseContent(content);\n\n            // 过滤重复的直播源，同时考虑正在检测的源\n            const existingUrls = new Set(this.streamList.map(s => s.url));\n            return newStreams.filter(s => {\n              // 如果源已存在且正在检测中，保留原有状态\n              const existingStream = this.streamList.find(es => es.url === s.url);\n              if (existingStream && existingStream.status === '检测中') {\n                return false;\n              }\n              return !existingUrls.has(s.url);\n            });\n          } catch (error) {\n            console.error(`采集地址 ${url} 失败:`, error);\n            return [];\n          }\n        }));\n\n        // 合并所有采集结果\n        const allNewStreams = results.filter(result => result.status === 'fulfilled').flatMap(result => result.value).filter((stream, index, self) => index === self.findIndex(s => s.url === stream.url));\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams);\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`);\n        } else {\n          this.$message.info('未发现新的直播源');\n        }\n\n        // 统计失败的地址\n        const failedUrls = results.filter(result => result.status === 'rejected').length;\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`);\n        }\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message);\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      }\n    },\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true;\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text();\n          const m3uLink = await m3uResponse.text();\n\n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          };\n          this.generatedLink = this.generatedLinks[this.linkForm.format];\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error);\n        this.$message.error('生成链接失败');\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent();\n    },\n    generateTxtContent() {\n      let content = '';\n      let currentGroup = '';\n\n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0; // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity;\n        const bTime = Number(b.responseTime) || Infinity;\n        return aTime - bTime;\n      });\n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `${currentGroup},#genre#\\n`;\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`;\n      });\n      return content.trim();\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n';\n      let currentGroup = '';\n\n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0; // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity;\n        const bTime = Number(b.responseTime) || Infinity;\n        return aTime - bTime;\n      });\n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`;\n        }\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`;\n        });\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n      const calculateNextExecutionTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime;\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck();\n          }\n          // 设置下一次执行\n          scheduleNextExecution();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextExecution();\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 清除旧的分块数据\n        this.clearStorageData();\n\n        // 只保存必要的数据字段，减少数据量\n        const minimalStreamList = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution || '',\n          responseTime: stream.responseTime || 0\n        }));\n\n        // 将streamList分块存储，减小分块大小\n        const streamListStr = JSON.stringify(minimalStreamList);\n        const chunkSize = 100000; // 减小到100KB\n        const chunks = Math.ceil(streamListStr.length / chunkSize);\n\n        // 如果数据量太大，只保存基本信息\n        if (chunks > 10) {\n          console.warn('数据量过大，只保存基本状态信息');\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize,\n            scheduleForm: this.scheduleForm,\n            collectForm: this.collectForm\n          };\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n          return;\n        }\n\n        // 分块存储\n        for (let i = 0; i < chunks; i++) {\n          const chunk = streamListStr.slice(i * chunkSize, (i + 1) * chunkSize);\n          try {\n            localStorage.setItem(`${this.stateKey}_streamList_${i}`, chunk);\n          } catch (e) {\n            console.error('存储分块失败:', e);\n            this.clearStorageData();\n            // 尝试只保存基本信息\n            const basicState = {\n              currentPage: this.currentPage,\n              pageSize: this.pageSize,\n              scheduleForm: this.scheduleForm,\n              collectForm: this.collectForm\n            };\n            localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n            return;\n          }\n        }\n\n        // 存储其他状态数据\n        const state = {\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm,\n          streamListChunks: chunks\n        };\n        localStorage.setItem(this.stateKey, JSON.stringify(state));\n      } catch (error) {\n        console.error('保存状态失败:', error);\n        this.clearStorageData();\n        // 尝试只保存基本信息\n        try {\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize\n          };\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState));\n        } catch (e) {\n          console.error('保存基本状态也失败:', e);\n        }\n      }\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 恢复streamList\n          if (state.streamListChunks) {\n            try {\n              let streamListStr = '';\n              for (let i = 0; i < state.streamListChunks; i++) {\n                const chunk = localStorage.getItem(`${this.stateKey}_streamList_${i}`);\n                if (chunk) {\n                  streamListStr += chunk;\n                }\n              }\n              if (streamListStr) {\n                this.streamList = JSON.parse(streamListStr);\n              }\n            } catch (e) {\n              console.error('恢复streamList失败:', e);\n              this.streamList = [];\n            }\n          }\n\n          // 恢复其他状态\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          if (state.scheduleForm) this.scheduleForm = state.scheduleForm;\n          if (state.collectForm) this.collectForm = state.collectForm;\n        }\n\n        // 重置所有运行状态\n        this.isChecking = false;\n        this.isPaused = false;\n        this.isScheduled = false;\n        this.isCollecting = false;\n        this.checkedCount = 0;\n        this.totalCount = 0;\n        this.pausedIndex = -1;\n        this.nextScheduleTime = null;\n      } catch (error) {\n        console.error('恢复状态失败:', error);\n        this.clearStorageData();\n        this.streamList = [];\n      }\n    },\n    // 清理存储数据\n    clearStorageData() {\n      try {\n        localStorage.removeItem(this.stateKey);\n        for (let i = 0;; i++) {\n          const key = `${this.stateKey}_streamList_${i}`;\n          if (localStorage.getItem(key) === null) {\n            break;\n          }\n          localStorage.removeItem(key);\n        }\n      } catch (error) {\n        console.error('清理存储数据失败:', error);\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', ['']);\n      } else {\n        this.collectForm.urls.push('');\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1);\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '-') return 'info';\n      if (resolution === '多播源') return 'warning'; // 为多播源添加特殊样式\n      const [width] = resolution.split('x').map(Number);\n      if (width >= 1920) return 'success';\n      if (width >= 1280) return ''; // 默认类型\n      return 'warning';\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime || responseTime === '-') return 'info';\n      const time = Number(responseTime);\n      if (time <= 1000) return 'success';\n      if (time <= 2000) return ''; // 默认类型\n      if (time <= 3000) return 'warning';\n      return 'danger';\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n      }\n      const calculateNextCollectTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect();\n          // 设置下一次执行\n          scheduleNextCollection();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextCollection();\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        const nameMatch = !this.searchForm.name || item.name.toLowerCase().includes(this.searchForm.name.toLowerCase());\n        const groupMatch = !this.searchForm.group || item.group === this.searchForm.group;\n        const statusMatch = !this.searchForm.status || item.status === this.searchForm.status;\n        return nameMatch && groupMatch && statusMatch;\n      });\n\n      // 重置到第一页\n      this.currentPage = 1;\n      this.searchDialogVisible = false;\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      };\n      this.filteredList = [];\n      this.currentPage = 1;\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`);\n        if (response.ok) {\n          const data = await response.json();\n          this.realIp = data.ip;\n          localStorage.setItem('realIp', data.ip); // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error);\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      const useRealIp = localStorage.getItem('useRealIp') === 'true';\n      return useRealIp && this.realIp ? `http://${this.realIp}:8080` : 'http://localhost:8080';\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate();\n\n        // 保存设置到localStorage\n        localStorage.setItem('githubToken', this.syncForm.token);\n        localStorage.setItem('githubRepo', this.syncForm.repo);\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath);\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath);\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync);\n        localStorage.setItem('githubSyncType', this.syncForm.syncType);\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime);\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay);\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule();\n        } else {\n          this.clearSyncSchedule();\n        }\n        this.$message.success('设置已保存');\n        this.syncDialogVisible = false;\n      } catch (error) {\n        this.$message.error(error.message || '保存失败');\n      }\n    },\n    async syncToGithub(content, path) {\n      const response = await fetch(`${this.getBaseUrl()}/api/sync-github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          token: this.syncForm.token,\n          repo: this.syncForm.repo,\n          path: path,\n          content: content,\n          message: this.syncForm.message\n        })\n      });\n      if (!response.ok) {\n        throw new Error('同步失败');\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule();\n      } else {\n        this.clearSyncSchedule();\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule();\n      const calculateNextSyncTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(async () => {\n          try {\n            // 执行同步\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath);\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath);\n            this.$message.success('已同步到GitHub');\n          } catch (error) {\n            this.$message.error('同步失败：' + error.message);\n          }\n          // 设置下一次执行\n          scheduleNextSync();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextSync();\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer);\n        this.syncTimer = null;\n      }\n    },\n    getStatusTagType(status) {\n      switch (status) {\n        case '正常':\n          return 'success';\n        case '异常':\n          return 'danger';\n        case '未知':\n          return 'warning';\n        case '未检测':\n          return 'info';\n        default:\n          return 'info';\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink();\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true);\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule();\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","loading","streamList","importUrlDialogVisible","importForm","url","group","importRules","required","message","trigger","type","currentPage","pageSize","isChecking","isPaused","checkedCount","totalCount","pausedIndex","shouldStop","isCollecting","collectDialogVisible","collectForm","urls","autoCollect","collectType","executeTime","weekDay","collectRules","validator","rule","value","callback","length","Error","errors","map","test","filter","error","collectTimer","generateLinkDialogVisible","generatedLink","previewContent","currentLinkId","scheduleDialogVisible","isScheduled","scheduleForm","scheduleType","scheduleRules","scheduleTimer","nextScheduleTime","stateKey","hasActiveOperations","linkForm","format","searchDialogVisible","searchForm","status","filteredList","realIp","syncDialogVisible","syncForm","token","localStorage","getItem","repo","txtPath","m3uPath","autoSync","syncType","syncRules","pattern","syncTimer","computed","paginatedData","start","end","slice","checkButtonText","mergedStreams","streamMap","Map","forEach","stream","key","has","existing","get","includes","push","set","Array","from","values","groupOptions","Set","item","created","savedList","JSON","parse","$nextTick","recheckMulticastStreams","$root","$on","saveStreamList","handleSettingsUpdate","restoreState","setupSchedule","startCollecting","setupSyncSchedule","getRealIp","beforeDestroy","$off","clearInterval","stopScheduleCheck","saveState","window","removeEventListener","handleBeforeUnload","methods","event","console","log","settings","savedSettings","autoRemoveMulticast","setItem","stringify","recheckUnknownStreams","autoRemoveEnabled","e","removedCount","toRemove","index","i","splice","$message","warning","checkStream","ffprobePath","isMulticast","resolution","responseTime","findIndex","s","response","fetch","getBaseUrl","method","headers","body","ok","result","json","available","shouldRemoveStream","reason","currentPageItems","pageIndex","indexOf","listIndex","handleBatchCheck","uncheckedStreams","info","concurrentChecks","parseInt","startIndex","batchSize","Math","min","batch","Promise","resolve","setTimeout","all","success","syncToGithub","generateContent","pauseCheck","resumeCheck","batchCheck","handleCheck","row","handleDelete","$confirm","confirmButtonText","cancelButtonText","then","maxPage","ceil","max","catch","handleUrlImport","valid","$refs","validate","content","text","newStreams","parseContent","existingUrls","uniqueStreams","readFile","file","reject","reader","FileReader","onload","target","onerror","readAsText","lines","split","streams","currentGroup","currentName","currentGroupTitle","line","trim","startsWith","tvgNameMatch","match","lastCommaIndex","lastIndexOf","substring","tvgIdMatch","tvgIdNoQuoteMatch","groupMatch","groupNoQuoteMatch","endsWith","replace","urlList","addStreamsToList","handleSizeChange","val","handleCurrentChange","handleFileUpload","files","getGroupFromFileName","filename","toLowerCase","handleClearList","checkIndex","updateLinkContent","handleCopy","textarea","document","createElement","appendChild","select","execCommand","err","removeChild","extremeMode","strictMode","width","height","Number","handleCollectMode","stopCollecting","isRestore","isArray","$set","collect","setupCollectSchedule","results","allSettled","encodeURIComponent","existingStream","find","es","allNewStreams","flatMap","self","failedUrls","handleGenerateLink","txtResponse","m3uResponse","txtLink","m3uLink","generatedLinks","txt","m3u","generateTxtContent","generateM3uContent","sortedStreams","sort","a","b","aTime","Infinity","bTime","join","copyGeneratedLink","downloadTxtFile","blob","Blob","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","handleScheduleCheck","startScheduleCheck","calculateNextExecutionTime","now","hours","minutes","nextTime","setHours","setDate","getDate","targetDay","getDay","scheduleNextExecution","delay","getTime","clearStorageData","minimalStreamList","streamListStr","chunkSize","chunks","warn","basicState","chunk","state","streamListChunks","savedState","removeItem","resetAllStates","updateActiveStatus","hasActive","addEventListener","preventDefault","returnValue","addCollectUrl","removeCollectUrl","getResolutionTagType","getResponseTimeTagType","time","calculateNextCollectTime","scheduleNextCollection","handleSearch","nameMatch","statusMatch","resetSearch","ip","useRealIp","saveGithubSettings","clearSyncSchedule","path","handleAutoSyncChange","calculateNextSyncTime","scheduleNextSync","getStatusTagType","watch","handler","deep","linkForm.format","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\n  <div class=\"stream-check\">\n\n    <div class=\"table-operations\">\n      <el-button-group>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-upload2\"\n            @click=\"$refs.fileInput.click()\"\n            :disabled=\"isCollecting\">\n          导入本地文件\n        </el-button>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-download\"\n            @click=\"importUrlDialogVisible = true\"\n            :disabled=\"isCollecting\">\n          导入网络文件\n        </el-button>\n      </el-button-group>\n\n      <el-button-group>\n        <el-button\n            type=\"success\"\n            icon=\"el-icon-refresh\"\n            @click=\"handleBatchCheck\"\n            :loading=\"isChecking\">\n          {{ checkButtonText }}\n        </el-button>\n        <el-button\n            v-if=\"isChecking\"\n            type=\"warning\"\n            icon=\"el-icon-video-pause\"\n            @click=\"pauseCheck\">\n          暂停检测\n        </el-button>\n        <el-button\n            v-if=\"isPaused\"\n            type=\"primary\"\n            icon=\"el-icon-video-play\"\n            @click=\"resumeCheck\">\n          继续检测\n        </el-button>\n        <el-button\n            type=\"danger\"\n            icon=\"el-icon-delete\"\n            @click=\"handleClearList\">\n          清空列表\n        </el-button>\n      </el-button-group>\n\n      <el-button-group>\n        <el-button\n            :type=\"isCollecting ? 'danger' : 'primary'\"\n            icon=\"el-icon-connection\"\n            @click=\"handleCollectMode\">\n          {{ isCollecting ? '停止采集' : '采集模式' }}\n        </el-button>\n      </el-button-group>\n\n      <el-button-group>\n        <el-button\n            type=\"primary\"\n            icon=\"el-icon-link\"\n            @click=\"handleGenerateLink\">\n          生成链接\n        </el-button>\n        <el-button\n            type=\"success\"\n            icon=\"el-icon-upload\"\n            @click=\"syncDialogVisible = true\">\n          同步到GitHub\n        </el-button>\n      </el-button-group>\n\n      <el-button-group>\n        <el-button\n            :type=\"isScheduled ? 'danger' : 'primary'\"\n            icon=\"el-icon-timer\"\n            @click=\"handleScheduleCheck\">\n          {{ isScheduled ? '停止定时' : '定时检测' }}\n        </el-button>\n      </el-button-group>\n\n      <el-button-group>\n        <el-button\n            :type=\"filteredList.length > 0 ? 'danger' : 'primary'\"\n            icon=\"el-icon-search\"\n            @click=\"filteredList.length > 0 ? resetSearch() : searchDialogVisible = true\">\n          {{ filteredList.length > 0 ? '重置' : '搜索' }}\n        </el-button>\n      </el-button-group>\n\n      <!-- 隐藏的文件输入框 -->\n      <input\n          type=\"file\"\n          ref=\"fileInput\"\n          style=\"display: none\"\n          accept=\".txt,.m3u,.m3u8\"\n          @change=\"handleFileUpload\"\n      >\n    </div>\n\n    <div class=\"el-table-wrapper\">\n      <el-table\n          :data=\"paginatedData\"\n          border\n          style=\"width: 100%\">\n        <el-table-column\n            prop=\"name\"\n            label=\"名称\"\n            min-width=\"120\"\n            align=\"center\">\n        </el-table-column>\n\n        <el-table-column\n            prop=\"url\"\n            label=\"链接\"\n            min-width=\"200\"\n            align=\"center\"\n            show-overflow-tooltip>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"resolution\"\n            label=\"分辨率\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                :type=\"getResolutionTagType(scope.row.resolution)\">\n              {{ scope.row.resolution || '未知' }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"responseTime\"\n            label=\"响应速度\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                :type=\"getResponseTimeTagType(scope.row.responseTime)\">\n              {{ scope.row.responseTime === '-' ? '-' : scope.row.responseTime + 'ms' }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"group\"\n            label=\"分组\"\n            width=\"120\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag\n                type=\"info\">\n              {{ scope.row.group }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            prop=\"status\"\n            label=\"状态\"\n            width=\"100\"\n            align=\"center\">\n          <template slot-scope=\"scope\">\n            <el-tag :type=\"getStatusTagType(scope.row.status)\">\n              {{ scope.row.status }}\n            </el-tag>\n          </template>\n        </el-table-column>\n\n        <el-table-column\n            label=\"操作\"\n            width=\"120\"\n            align=\"center\"\n            fixed=\"right\">\n          <template slot-scope=\"scope\">\n            <el-tooltip content=\"复制链接\" placement=\"top\">\n              <el-button\n                  type=\"text\"\n                  icon=\"el-icon-document-copy\"\n                  @click=\"handleCopy(scope.row)\">\n              </el-button>\n            </el-tooltip>\n            <el-tooltip content=\"删除\" placement=\"top\">\n              <el-button\n                  type=\"text\"\n                  class=\"delete-btn\"\n                  icon=\"el-icon-delete\"\n                  @click=\"handleDelete(scope.row)\">\n              </el-button>\n            </el-tooltip>\n          </template>\n        </el-table-column>\n      </el-table>\n    </div>\n\n    <!-- 添加分页组件 -->\n    <div class=\"pagination-container\">\n      <el-pagination\n          @size-change=\"handleSizeChange\"\n          @current-change=\"handleCurrentChange\"\n          :current-page=\"currentPage\"\n          :page-sizes=\"[5, 10, 20, 50]\"\n          :page-size=\"pageSize\"\n          layout=\"total, sizes, prev, pager, next, jumper\"\n          :total=\"filteredList.length || streamList.length\">\n      </el-pagination>\n    </div>\n\n    <!-- 添加/编辑对话框 -->\n    <el-dialog\n        title=\"导入网络文件\"\n        :visible.sync=\"importUrlDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"importForm\" label-width=\"80px\" ref=\"importForm\" :rules=\"importRules\">\n        <el-form-item label=\"URL地址\" prop=\"url\">\n          <el-input\n              v-model=\"importForm.url\"\n              placeholder=\"请输入txt或m3u文件的网络地址\"\n          ></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"importUrlDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleUrlImport\">导 入</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 采集模式设置对话框 -->\n    <el-dialog\n        title=\"采集模式设置\"\n        :visible.sync=\"collectDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"collectForm\" label-width=\"100px\" ref=\"collectForm\" :rules=\"collectRules\">\n        <!-- 采集地址列表 -->\n        <el-form-item\n            v-for=\"(url, index) in collectForm.urls\"\n            :key=\"index\"\n            :label=\"index === 0 ? '采集地址' : ''\"\n            :prop=\"'urls.' + index\">\n          <el-input\n              v-model=\"collectForm.urls[index]\"\n              placeholder=\"请输入需要采集的网络地址\">\n            <template slot=\"append\">\n              <el-button\n                  icon=\"el-icon-delete\"\n                  @click=\"removeCollectUrl(index)\"\n                  v-if=\"collectForm.urls.length > 1\">\n              </el-button>\n            </template>\n          </el-input>\n        </el-form-item>\n\n        <!-- 添加地址按钮 -->\n        <el-form-item>\n          <el-button\n              type=\"text\"\n              icon=\"el-icon-plus\"\n              @click=\"addCollectUrl\">\n            添加采集地址\n          </el-button>\n        </el-form-item>\n\n        <el-form-item label=\"自动采集\">\n          <el-switch v-model=\"collectForm.autoCollect\"></el-switch>\n        </el-form-item>\n\n        <!-- 采集时间设置 -->\n        <template v-if=\"collectForm.autoCollect\">\n          <el-form-item label=\"采集周期\" prop=\"collectType\">\n            <el-radio-group v-model=\"collectForm.collectType\">\n              <el-radio label=\"daily\">每天</el-radio>\n              <el-radio label=\"weekly\">每周</el-radio>\n            </el-radio-group>\n          </el-form-item>\n\n          <el-form-item label=\"执行时间\" prop=\"executeTime\">\n            <el-time-picker\n                v-model=\"collectForm.executeTime\"\n                format=\"HH:mm\"\n                value-format=\"HH:mm\"\n                placeholder=\"选择时间\">\n            </el-time-picker>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行日期\"\n              prop=\"weekDay\"\n              v-if=\"collectForm.collectType === 'weekly'\">\n            <el-select v-model=\"collectForm.weekDay\">\n              <el-option label=\"星期一\" value=\"1\"></el-option>\n              <el-option label=\"星期二\" value=\"2\"></el-option>\n              <el-option label=\"星期三\" value=\"3\"></el-option>\n              <el-option label=\"星期四\" value=\"4\"></el-option>\n              <el-option label=\"星期五\" value=\"5\"></el-option>\n              <el-option label=\"星期六\" value=\"6\"></el-option>\n              <el-option label=\"星期日\" value=\"0\"></el-option>\n            </el-select>\n          </el-form-item>\n        </template>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"collectDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startCollecting\">开始采集</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 生成链接对话框 -->\n    <el-dialog\n        title=\"生成链接\"\n        :visible.sync=\"generateLinkDialogVisible\"\n        width=\"500px\"\n        custom-class=\"generate-link-dialog\">\n      <div class=\"link-container\">\n        <!-- 添加格式选择 -->\n        <el-form :model=\"linkForm\" label-width=\"80px\">\n          <el-form-item label=\"文件格式\">\n            <el-radio-group v-model=\"linkForm.format\">\n              <el-radio label=\"txt\">TXT格式</el-radio>\n              <el-radio label=\"m3u\">M3U格式</el-radio>\n            </el-radio-group>\n          </el-form-item>\n        </el-form>\n\n        <!-- 链接展示卡片 -->\n        <el-card class=\"link-card\">\n          <div class=\"link-content\">\n            <el-input\n                v-model=\"generatedLink\"\n                placeholder=\"正在生成链接...\"\n                readonly>\n              <template slot=\"prepend\">链接地址</template>\n              <el-button\n                  slot=\"append\"\n                  icon=\"el-icon-document-copy\"\n                  @click=\"copyGeneratedLink\">\n                复制\n              </el-button>\n            </el-input>\n          </div>\n        </el-card>\n\n        <!-- 使用说明 -->\n        <el-card class=\"tips-card\">\n          <div class=\"tips-content\">\n            <ul>\n              <li>生成的链接可以直接在支持网络导入的播放器中使用</li>\n              <li>链接内容会随列表更新而自动更新</li>\n              <li>TXT格式适用于大多数播放器</li>\n              <li>M3U格式提供更好的播放器兼容性</li>\n            </ul>\n          </div>\n        </el-card>\n      </div>\n    </el-dialog>\n\n    <!-- 添加定时检测设置对话框 -->\n    <el-dialog\n        title=\"定时检测设置\"\n        :visible.sync=\"scheduleDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"scheduleForm\" label-width=\"100px\" ref=\"scheduleForm\" :rules=\"scheduleRules\">\n        <el-form-item label=\"检测周期\" prop=\"scheduleType\">\n          <el-radio-group v-model=\"scheduleForm.scheduleType\">\n            <el-radio label=\"daily\">每天</el-radio>\n            <el-radio label=\"weekly\">每周</el-radio>\n          </el-radio-group>\n        </el-form-item>\n\n        <el-form-item label=\"执行时间\" prop=\"executeTime\">\n          <el-time-picker\n              v-model=\"scheduleForm.executeTime\"\n              format=\"HH:mm\"\n              value-format=\"HH:mm\"\n              placeholder=\"选择时间\">\n          </el-time-picker>\n        </el-form-item>\n\n        <el-form-item\n            label=\"执行日期\"\n            prop=\"weekDay\"\n            v-if=\"scheduleForm.scheduleType === 'weekly'\">\n          <el-select v-model=\"scheduleForm.weekDay\">\n            <el-option label=\"星期一\" value=\"1\"></el-option>\n            <el-option label=\"星期二\" value=\"2\"></el-option>\n            <el-option label=\"星期三\" value=\"3\"></el-option>\n            <el-option label=\"星期四\" value=\"4\"></el-option>\n            <el-option label=\"星期五\" value=\"5\"></el-option>\n            <el-option label=\"星期六\" value=\"6\"></el-option>\n            <el-option label=\"星期日\" value=\"0\"></el-option>\n          </el-select>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"scheduleDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startScheduleCheck\">开始定时</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 添加搜索对话框 -->\n    <el-dialog\n        title=\"搜索直播源\"\n        :visible.sync=\"searchDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"searchForm\" label-width=\"80px\">\n        <el-form-item label=\"名称\">\n          <el-input\n              v-model=\"searchForm.name\"\n              placeholder=\"支持模糊搜索\"\n              clearable>\n          </el-input>\n        </el-form-item>\n        <el-form-item label=\"分组\">\n          <el-select\n              v-model=\"searchForm.group\"\n              placeholder=\"请选择\"\n              clearable>\n            <el-option\n                v-for=\"group in groupOptions\"\n                :key=\"group\"\n                :label=\"group\"\n                :value=\"group\">\n            </el-option>\n          </el-select>\n        </el-form-item>\n        <el-form-item label=\"状态\">\n          <el-select\n              v-model=\"searchForm.status\"\n              placeholder=\"请选择\"\n              clearable>\n            <el-option label=\"正常\" value=\"正常\"></el-option>\n            <el-option label=\"异常\" value=\"异常\"></el-option>\n            <el-option label=\"未检测\" value=\"未检测\"></el-option>\n          </el-select>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"searchDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleSearch\">搜 索</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- GitHub同步设置对话框 -->\n    <el-dialog\n        title=\"GitHub同步设置\"\n        :visible.sync=\"syncDialogVisible\"\n        width=\"500px\">\n      <el-form :model=\"syncForm\" ref=\"syncForm\" label-width=\"120px\" :rules=\"syncRules\">\n        <el-form-item label=\"GitHub Token\" prop=\"token\">\n          <el-input\n              v-model=\"syncForm.token\"\n              type=\"password\"\n              placeholder=\"请输入GitHub Personal Access Token\"\n              show-password>\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"仓库名称\" prop=\"repo\">\n          <el-input\n              v-model=\"syncForm.repo\"\n              placeholder=\"格式：用户名/仓库名\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"TXT文件名\" prop=\"txtPath\">\n          <el-input\n              v-model=\"syncForm.txtPath\"\n              placeholder=\"例如：playlist.txt\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"M3U文件名\" prop=\"m3uPath\">\n          <el-input\n              v-model=\"syncForm.m3uPath\"\n              placeholder=\"例如：playlist.m3u\">\n          </el-input>\n        </el-form-item>\n        \n        <el-form-item label=\"定时同步\">\n          <el-switch\n              v-model=\"syncForm.autoSync\"\n              @change=\"handleAutoSyncChange\">\n          </el-switch>\n        </el-form-item>\n        \n        <template v-if=\"syncForm.autoSync\">\n          <el-form-item label=\"同步周期\" prop=\"syncType\">\n            <el-radio-group v-model=\"syncForm.syncType\">\n              <el-radio label=\"daily\">每天</el-radio>\n              <el-radio label=\"weekly\">每周</el-radio>\n              <el-radio label=\"afterCheck\">批量检测完毕后</el-radio>\n            </el-radio-group>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行时间\"\n              prop=\"executeTime\"\n              v-if=\"syncForm.syncType !== 'afterCheck'\">\n            <el-time-picker\n                v-model=\"syncForm.executeTime\"\n                format=\"HH:mm\"\n                value-format=\"HH:mm\"\n                placeholder=\"选择时间\">\n            </el-time-picker>\n          </el-form-item>\n\n          <el-form-item\n              label=\"执行日期\"\n              prop=\"weekDay\"\n              v-if=\"syncForm.syncType === 'weekly'\">\n            <el-select v-model=\"syncForm.weekDay\">\n              <el-option label=\"星期一\" value=\"1\"></el-option>\n              <el-option label=\"星期二\" value=\"2\"></el-option>\n              <el-option label=\"星期三\" value=\"3\"></el-option>\n              <el-option label=\"星期四\" value=\"4\"></el-option>\n              <el-option label=\"星期五\" value=\"5\"></el-option>\n              <el-option label=\"星期六\" value=\"6\"></el-option>\n              <el-option label=\"星期日\" value=\"0\"></el-option>\n            </el-select>\n          </el-form-item>\n        </template>\n        \n        <el-form-item label=\"提交信息\" prop=\"message\">\n          <el-input\n              v-model=\"syncForm.message\"\n              placeholder=\"更新说明\">\n          </el-input>\n        </el-form-item>\n      </el-form>\n      \n      <div slot=\"footer\">\n        <el-button @click=\"syncDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"saveGithubSettings\">保 存</el-button>\n      </div>\n    </el-dialog>\n  </div>\n\n</template>\n\n<script>\nexport default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importForm: {\n        url: '',\n        group: ''\n      },\n      importRules: {\n        url: [\n          { required: true, message: '请输入URL地址', trigger: 'blur' },\n          { type: 'url', message: '请输入正确的URL地址', trigger: ['blur', 'change'] }\n        ],\n        group: [\n          { required: true, message: '请选择分组', trigger: 'change' }\n        ]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        autoCollect: false,\n        collectType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      collectRules: {\n        urls: [\n          { \n            type: 'array',\n            validator: (rule, value, callback) => {\n              if (value.length === 0) {\n                callback(new Error('请至少添加一个采集地址'))\n              }\n              // 验证每个URL\n              const errors = value.map(url => {\n                if (!url) return '采集地址不能为空'\n                if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址'\n                return null\n              }).filter(error => error !== null)\n              \n              if (errors.length > 0) {\n                callback(new Error(errors[0]))\n              } else {\n                callback()\n              }\n            },\n            trigger: 'change'\n          }\n        ],\n        executeTime: [\n          { required: true, message: '请选择执行时间', trigger: 'change' }\n        ],\n        weekDay: [\n          { required: true, message: '请选择执行日期', trigger: 'change' }\n        ]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',  // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        scheduleType: 'daily',\n        executeTime: '09:00',\n        weekDay: '1'\n      },\n      scheduleRules: {\n        executeTime: [\n          { required: true, message: '请选择执行时间', trigger: 'change' }\n        ],\n        weekDay: [\n          { required: true, message: '请选择执行日期', trigger: 'change' }\n        ]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState', // 用于本地存储的key\n      hasActiveOperations: false,  // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      },\n      searchDialogVisible: false,\n      searchForm: {\n        name: '',\n        group: '',\n        status: ''\n      },\n      filteredList: [], // 用于存储搜索过滤后的列表\n      realIp: '',  // 存储真实IP地址\n      syncDialogVisible: false,\n      syncForm: {\n        token: localStorage.getItem('githubToken') || '',\n        repo: localStorage.getItem('githubRepo') || '',\n        txtPath: localStorage.getItem('githubTxtPath') || '',\n        m3uPath: localStorage.getItem('githubM3uPath') || '',\n        autoSync: localStorage.getItem('githubAutoSync') === 'true',\n        syncType: localStorage.getItem('githubSyncType') || 'daily',\n        executeTime: localStorage.getItem('githubExecuteTime') || '00:00',\n        weekDay: localStorage.getItem('githubWeekDay') || '1',\n        message: '更新直播源列表'\n      },\n      syncRules: {\n        token: [\n          { required: true, message: '请输入GitHub Token', trigger: 'blur' }\n        ],\n        repo: [\n          { required: true, message: '请输入仓库名称', trigger: 'blur' },\n          { pattern: /^[\\w-]+\\/[\\w-]+$/, message: '格式：用户名/仓库名', trigger: 'blur' }\n        ],\n        txtPath: [\n          { required: true, message: '请输入文件路径', trigger: 'blur' }\n        ],\n        m3uPath: [\n          { required: true, message: '请输入文件路径', trigger: 'blur' }\n        ],\n        message: [\n          { required: true, message: '请输入提交消息', trigger: 'blur' }\n        ]\n      },\n      syncTimer: null\n    }\n  },\n  computed: {\n    paginatedData() {\n      // 使用过滤后的列表进行分页\n      const start = (this.currentPage - 1) * this.pageSize\n      const end = start + this.pageSize\n      return (this.filteredList.length > 0 ? this.filteredList : this.streamList).slice(start, end)\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测'\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map()\n      \n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name // 使用名称作为键\n        \n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key)\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url)\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          })\n        }\n      })\n      \n      // 转换回数组格式\n      return Array.from(streamMap.values())\n    },\n    groupOptions() {\n      return [...new Set(this.streamList.map(item => item.group))]\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList')\n      if (savedList) {\n        this.streamList = JSON.parse(savedList)\n        // 初始化时检查多播源\n        this.$nextTick(() => {\n          this.recheckMulticastStreams()\n        })\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList)\n    \n    // 监听设置更新事件\n    this.$root.$on('settings-updated', this.handleSettingsUpdate)\n\n    // 从本地存储恢复状态\n    this.restoreState()\n    \n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true) // true表示是恢复状态\n    }\n    // 如果GitHub自动同步是开启状态，重新启动同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule()\n    }\n\n    this.filteredList = []\n    this.getRealIp()  // 获取真实IP地址\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList)\n    this.$root.$off('settings-updated', this.handleSettingsUpdate)\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck()\n    // 在组件销毁前保存状态\n    this.saveState()\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\n  },\n  methods: {\n    // 添加处理设置更新的方法\n    handleSettingsUpdate(event) {\n      console.log('收到设置更新事件:', event)\n      // 如果是自动清除未知源设置被更改，重新检查所有未知源\n      if (event && event.type === 'autoRemoveMulticast') {\n        console.log('自动清除未知源设置已更改为:', event.value)\n        \n        // 更新本地存储中的设置\n        try {\n          let settings = {}\n          const savedSettings = localStorage.getItem('appSettings')\n          if (savedSettings) {\n            settings = JSON.parse(savedSettings)\n          }\n          settings.autoRemoveMulticast = event.value\n          localStorage.setItem('appSettings', JSON.stringify(settings))\n          \n          console.log('设置已更新，当前设置:', settings)\n          \n          // 如果启用了自动清除，立即执行检查\n          if (event.value === true) {\n            console.log('设置已启用，开始检查未知源...')\n            this.$nextTick(() => {\n              this.recheckUnknownStreams()\n            })\n          }\n        } catch (error) {\n          console.error('更新设置失败:', error)\n        }\n      }\n    },\n\n    // 修改为检查未知源的方法\n    recheckUnknownStreams() {\n      try {\n        // 直接从 localStorage 获取设置\n        const autoRemoveEnabled = localStorage.getItem('appSettings')\n        if (!autoRemoveEnabled) {\n          console.log('未找到设置配置')\n          return\n        }\n\n        let settings\n        try {\n          settings = JSON.parse(autoRemoveEnabled)\n        } catch (e) {\n          console.error('解析设置失败:', e)\n          return\n        }\n\n        // 调试输出\n        console.log('当前设置状态:', settings)\n        \n        // 严格检查 autoRemoveMulticast 的值\n        if (settings.autoRemoveMulticast !== true) {\n          console.log('自动清除未知源功能未启用，当前值:', settings.autoRemoveMulticast)\n          return\n        }\n\n        console.log('开始执行自动清除未知源...')\n        let removedCount = 0\n        const toRemove = []\n        \n        // 先收集需要删除的索引\n        this.streamList.forEach((stream, index) => {\n          if (stream.status === '未知') {\n            toRemove.push(index)\n            removedCount++\n          }\n        })\n        \n        // 从后向前删除\n        for (let i = toRemove.length - 1; i >= 0; i--) {\n          const index = toRemove[i]\n          const stream = this.streamList[index]\n          console.log('正在删除未知源:', stream.name, stream.url)\n          this.streamList.splice(index, 1)\n        }\n        \n        if (removedCount > 0) {\n          console.log(`成功清除 ${removedCount} 个未知状态的直播源`)\n          this.$message.warning(`已自动清除 ${removedCount} 个未知状态的直播源`)\n          this.saveStreamList()\n          \n          // 如果当前页没有数据，跳转到上一页\n          if (this.paginatedData.length === 0 && this.currentPage > 1) {\n            this.currentPage--\n          }\n        } else {\n          console.log('没有找到需要清除的未知源')\n        }\n      } catch (error) {\n        console.error('检查未知源失败:', error)\n      }\n    },\n\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath')\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径')\n        return false\n      }\n\n      // 检查是否是多播源\n      const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url)\n      if (isMulticast) {\n        // 设置为未知状态\n        stream.status = '未知'\n        stream.resolution = '多播源'\n        stream.responseTime = '-'\n        \n        try {\n          const savedSettings = localStorage.getItem('appSettings')\n          if (!savedSettings) {\n            return false\n          }\n\n          const settings = JSON.parse(savedSettings)\n          // 如果启用了自动清除未知源\n          if (settings.autoRemoveMulticast === true) {\n            const index = this.streamList.findIndex(s => s.url === stream.url)\n            if (index > -1) {\n              this.streamList.splice(index, 1)\n              this.$message.warning(`已自动清除未知状态直播源: ${stream.name}`)\n              this.saveStreamList()\n              \n              if (this.paginatedData.length === 1 && this.currentPage > 1) {\n                this.currentPage--\n              }\n              return false\n            }\n          }\n        } catch (error) {\n          console.error('处理未知源时出错:', error)\n        }\n        return false\n      }\n\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        })\n\n        if (!response.ok) throw new Error('请求失败')\n        \n        const result = await response.json()\n        \n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常'\n        stream.resolution = result.resolution || '-'\n        stream.responseTime = result.responseTime || '-'\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = ''\n          if (stream.status === '异常') {\n            reason = '异常源'\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢'\n          } else {\n            reason = '分辨率过低'\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream)\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream)\n          \n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1)\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`)\n          }\n        }\n        \n        this.saveStreamList()\n        return result.available\n      } catch (error) {\n        console.error('检测错误:', error)\n        stream.status = '异常'\n        return false\n      }\n    },\n\n    async handleBatchCheck() {\n      if (this.isChecking) return\n      \n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex)\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源')\n        return\n      }\n\n      this.isChecking = true\n      this.shouldStop = false\n      this.totalCount = uncheckedStreams.length\n      this.checkedCount = this.isPaused ? this.checkedCount : 0\n      \n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3\n      \n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0\n        \n        // 分批处理，每批次处理固定数量的流\n        const batchSize = Math.min(concurrentChecks, 10) // 限制最大并发数\n        \n        for (let i = startIndex; i < uncheckedStreams.length; i += batchSize) {\n          if (this.shouldStop) break\n          \n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + batchSize)\n          \n          // 添加延时，让浏览器有时间响应\n          await new Promise(resolve => setTimeout(resolve, 100))\n          \n          // 并发检测当前批次的所有流\n          await Promise.all(\n            batch.map(async stream => {\n              if (this.shouldStop) return\n              \n              try {\n                stream.status = '检测中'\n                const success = await this.checkStream(stream)\n                this.checkedCount++\n                \n                if (success) {\n                  this.saveState()\n                }\n              } catch (error) {\n                console.error('检测流失败:', error)\n                stream.status = '异常'\n                this.checkedCount++\n              }\n            })\n          )\n          \n          // 更新暂停位置\n          this.pausedIndex = i + batchSize - 1\n          \n          // 每批次完成后保存状态\n          this.saveState()\n        }\n\n        if (!this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = false\n          this.pausedIndex = -1\n          this.$message.success('批量检测完成')\n          \n          // 检查是否需要在批量检测完成后同步\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath)\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath)\n            this.$message.success('已同步到GitHub')\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error)\n        this.$message.error('批量检测失败')\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = true\n          this.$message.info('检测已暂停')\n        }\n      }\n    },\n\n    pauseCheck() {\n      this.shouldStop = true\n    },\n\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true\n        this.isPaused = false\n        this.shouldStop = false\n        await this.batchCheck(this.pausedIndex)\n      }\n    },\n\n    async handleCheck(row) {\n      row.status = '检测中'\n      \n      const success = await this.checkStream(row)\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`)\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row)\n        this.streamList.splice(index, 1)\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1)\n        }\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('删除成功')\n      }).catch(() => {})\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate()\n      if (!valid) return\n\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: this.importForm.url })\n        })\n\n        if (!response.ok) throw new Error('导入失败')\n\n        const content = await response.text()\n        const newStreams = this.parseContent(content)\n\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            // 在添加前检查多播源\n            uniqueStreams.forEach(stream => {\n              const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url)\n              if (isMulticast) {\n                stream.status = '未知'\n                stream.resolution = '多播源'\n                stream.responseTime = '-'\n              }\n            })\n            \n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            this.importUrlDialogVisible = false\n            \n            // 导入后立即检查未知源\n            this.$nextTick(() => {\n              this.recheckUnknownStreams()\n            })\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message)\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = (e) => resolve(e.target.result)\n        reader.onerror = () => reject(new Error('文件读取失败'))\n        reader.readAsText(file)\n      })\n    },\n    parseContent(content) {\n      const lines = content.split('\\n')\n      const streams = []\n      let currentGroup = '未分组'\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = ''\n        let currentGroupTitle = ''\n\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = ''\n            \n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i)\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim()\n            }\n            \n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',')\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim()\n              }\n            }\n            \n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i)\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim()\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i)\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim()\n                }\n              }\n            }\n\n            currentName = name || '未命名'\n            \n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i)\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim()\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i)\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim()\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '-',\n                responseTime: '-'\n              })\n            }\n            currentName = ''  // 重置当前名称\n          }\n        })\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '')\n            return\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',')\n          if (!name || !urls) return\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#')\n          \n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '-',\n                responseTime: '-'\n              })\n            }\n          })\n        })\n      }\n\n      return streams\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream)\n      })\n      this.currentPage = 1\n      this.saveStreamList()  // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            // 在添加前检查多播源\n            uniqueStreams.forEach(stream => {\n              const isMulticast = /\\/(udp|rtp)\\/239\\.\\d+\\.\\d+\\.\\d+:\\d+/i.test(stream.url)\n              if (isMulticast) {\n                stream.status = '未知'\n                stream.resolution = '多播源'\n                stream.responseTime = '-'\n              }\n            })\n            \n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            \n            // 导入后立即检查未知源\n            this.$nextTick(() => {\n              this.recheckUnknownStreams()\n            })\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase()\n      if (name.includes('cctv')) return 'CCTV'\n      if (name.includes('卫视')) return '卫视'\n      if (name.includes('地方')) return '地方台'\n      return '未分组'\n    },\n    handleClearList() {\n      this.$confirm('确认清空列表吗？', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        // 只重置批量检测相关的状态\n        this.streamList = []\n        this.currentPage = 1\n        this.isChecking = false\n        this.isPaused = false\n        this.checkIndex = 0\n        \n        // 更新链接内容和保存状态\n        this.updateLinkContent()\n        this.saveState()\n        \n        this.$message({\n          type: 'success',\n          message: '列表已清空'\n        })\n      }).catch(() => {\n        this.$message({\n          type: 'info',\n          message: '已取消清空'\n        })\n      })\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea')\n      textarea.value = row.url\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除未知状态的源\n      if (localStorage.getItem('autoRemoveMulticast') === 'true' && \n          stream.status === '未知') {\n        return true\n      }\n\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && \n          stream.status === '异常') {\n        return true\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true'\n      const strictMode = localStorage.getItem('strictMode') === 'true'\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && \n          stream.resolution !== '未知' && \n          stream.resolution !== '多播源' && \n          stream.resolution !== '-') {\n        const [width, height] = stream.resolution.split('x').map(Number)\n        if (extremeMode ? (width < 1920 || height < 1080) : \n            (strictMode ? (width < 1920 || height < 1080) : (width < 1280 || height < 720))) {\n          return true\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && \n          stream.responseTime !== '-' &&\n          Number(stream.responseTime) > (extremeMode ? 1500 : (strictMode ? 2000 : 3000))) {\n        return true\n      }\n\n      return false\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting()\n      } else {\n        this.collectDialogVisible = true\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', [''])\n          return\n        }\n        \n        const valid = await this.$refs.collectForm.validate()\n        if (!valid) return\n      }\n\n      this.collectDialogVisible = false\n      this.isCollecting = true\n      this.saveState() // 保存状态\n      \n      // 立即执行一次采集\n      await this.collect()\n      \n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule()\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false\n        this.saveState()\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      this.saveState() // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集')\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集')\n          return\n        }\n\n        this.$message.info('开始采集直播源...')\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(\n          this.collectForm.urls.map(async url => {\n            try {\n              const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'text/plain'\n                },\n              })\n              if (!response.ok) throw new Error(`采集失败: ${url}`)\n              \n              const content = await response.text()\n              const newStreams = this.parseContent(content)\n              \n              // 过滤重复的直播源，同时考虑正在检测的源\n              const existingUrls = new Set(this.streamList.map(s => s.url))\n              return newStreams.filter(s => {\n                // 如果源已存在且正在检测中，保留原有状态\n                const existingStream = this.streamList.find(es => es.url === s.url)\n                if (existingStream && existingStream.status === '检测中') {\n                  return false\n                }\n                return !existingUrls.has(s.url)\n              })\n            } catch (error) {\n              console.error(`采集地址 ${url} 失败:`, error)\n              return []\n            }\n          })\n        )\n\n        // 合并所有采集结果\n        const allNewStreams = results\n          .filter(result => result.status === 'fulfilled')\n          .flatMap(result => result.value)\n          .filter((stream, index, self) => \n            index === self.findIndex(s => s.url === stream.url)\n          )\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams)\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`)\n        } else {\n          this.$message.info('未发现新的直播源')\n        }\n\n        // 统计失败的地址\n        const failedUrls = results\n          .filter(result => result.status === 'rejected')\n          .length\n\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`)\n        }\n\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message)\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting()\n        }\n      }\n    },\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n        \n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text()\n          const m3uLink = await m3uResponse.text()\n          \n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          }\n          this.generatedLink = this.generatedLinks[this.linkForm.format]\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error)\n        this.$message.error('生成链接失败')\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent()\n    },\n    generateTxtContent() {\n      let content = ''\n      let currentGroup = ''\n      \n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0  // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity\n        const bTime = Number(b.responseTime) || Infinity\n        return aTime - bTime\n      })\n      \n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `${currentGroup},#genre#\\n`\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`\n      })\n      \n      return content.trim()\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n'\n      let currentGroup = ''\n      \n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0  // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity\n        const bTime = Number(b.responseTime) || Infinity\n        return aTime - bTime\n      })\n      \n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`\n        }\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`\n        })\n      })\n      \n      return content.trim()\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea')\n      textarea.value = this.generatedLink\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\n      \n      document.body.appendChild(link)\n      link.click()\n      \n      // 清理\n      window.URL.revokeObjectURL(url)\n      document.body.removeChild(link)\n      this.$message.success('文件下载成功')\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n      } catch (error) {\n        console.error('更新链接内容失败：', error)\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      } else {\n        this.scheduleDialogVisible = true\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false\n          this.isScheduled = true\n          this.setupSchedule()\n          this.saveState() // 保存状态\n          this.$message.success('定时检测已开启')\n        }\n      })\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      this.isScheduled = false\n      this.nextScheduleTime = null\n      this.saveState() // 保存状态\n      this.$message.success('定时检测已停止')\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n      }\n\n      const calculateNextExecutionTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck()\n          }\n          // 设置下一次执行\n          scheduleNextExecution()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextExecution()\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 清除旧的分块数据\n        this.clearStorageData()\n\n        // 只保存必要的数据字段，减少数据量\n        const minimalStreamList = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution || '',\n          responseTime: stream.responseTime || 0\n        }))\n\n        // 将streamList分块存储，减小分块大小\n        const streamListStr = JSON.stringify(minimalStreamList)\n        const chunkSize = 100000 // 减小到100KB\n        const chunks = Math.ceil(streamListStr.length / chunkSize)\n        \n        // 如果数据量太大，只保存基本信息\n        if (chunks > 10) {\n          console.warn('数据量过大，只保存基本状态信息')\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize,\n            scheduleForm: this.scheduleForm,\n            collectForm: this.collectForm\n          }\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n          return\n        }\n\n        // 分块存储\n        for (let i = 0; i < chunks; i++) {\n          const chunk = streamListStr.slice(i * chunkSize, (i + 1) * chunkSize)\n          try {\n            localStorage.setItem(`${this.stateKey}_streamList_${i}`, chunk)\n          } catch (e) {\n            console.error('存储分块失败:', e)\n            this.clearStorageData()\n            // 尝试只保存基本信息\n            const basicState = {\n              currentPage: this.currentPage,\n              pageSize: this.pageSize,\n              scheduleForm: this.scheduleForm,\n              collectForm: this.collectForm\n            }\n            localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n            return\n          }\n        }\n\n        // 存储其他状态数据\n        const state = {\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm,\n          streamListChunks: chunks\n        }\n        localStorage.setItem(this.stateKey, JSON.stringify(state))\n      } catch (error) {\n        console.error('保存状态失败:', error)\n        this.clearStorageData()\n        // 尝试只保存基本信息\n        try {\n          const basicState = {\n            currentPage: this.currentPage,\n            pageSize: this.pageSize\n          }\n          localStorage.setItem(this.stateKey, JSON.stringify(basicState))\n        } catch (e) {\n          console.error('保存基本状态也失败:', e)\n        }\n      }\n    },\n\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey)\n        if (savedState) {\n          const state = JSON.parse(savedState)\n          \n          // 恢复streamList\n          if (state.streamListChunks) {\n            try {\n              let streamListStr = ''\n              for (let i = 0; i < state.streamListChunks; i++) {\n                const chunk = localStorage.getItem(`${this.stateKey}_streamList_${i}`)\n                if (chunk) {\n                  streamListStr += chunk\n                }\n              }\n              if (streamListStr) {\n                this.streamList = JSON.parse(streamListStr)\n              }\n            } catch (e) {\n              console.error('恢复streamList失败:', e)\n              this.streamList = []\n            }\n          }\n          \n          // 恢复其他状态\n          this.currentPage = state.currentPage || 1\n          this.pageSize = state.pageSize || 5\n          if (state.scheduleForm) this.scheduleForm = state.scheduleForm\n          if (state.collectForm) this.collectForm = state.collectForm\n        }\n\n        // 重置所有运行状态\n        this.isChecking = false\n        this.isPaused = false\n        this.isScheduled = false\n        this.isCollecting = false\n        this.checkedCount = 0\n        this.totalCount = 0\n        this.pausedIndex = -1\n        this.nextScheduleTime = null\n      } catch (error) {\n        console.error('恢复状态失败:', error)\n        this.clearStorageData()\n        this.streamList = []\n      }\n    },\n\n    // 清理存储数据\n    clearStorageData() {\n      try {\n        localStorage.removeItem(this.stateKey)\n        for (let i = 0; ; i++) {\n          const key = `${this.stateKey}_streamList_${i}`\n          if (localStorage.getItem(key) === null) {\n            break\n          }\n          localStorage.removeItem(key)\n        }\n      } catch (error) {\n        console.error('清理存储数据失败:', error)\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      }\n      \n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting()\n      }\n      \n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n      }\n      \n      // 重置所有状态\n      this.isChecking = false\n      this.isPaused = false\n      this.isScheduled = false\n      this.isCollecting = false\n      this.checkedCount = 0\n      this.totalCount = 0\n      this.pausedIndex = -1\n      this.nextScheduleTime = null\n      \n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      \n      // 保存重置后的状态\n      this.saveState()\n      \n      this.$message.success('所有运行状态已重置')\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\n      \n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？'\n        e.preventDefault()\n        e.returnValue = message\n        return message\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', [''])\n      } else {\n        this.collectForm.urls.push('')\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1)\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '-') return 'info'\n      if (resolution === '多播源') return 'warning'  // 为多播源添加特殊样式\n      const [width] = resolution.split('x').map(Number)\n      if (width >= 1920) return 'success'\n      if (width >= 1280) return ''  // 默认类型\n      return 'warning'\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime || responseTime === '-') return 'info'\n      const time = Number(responseTime)\n      if (time <= 1000) return 'success'\n      if (time <= 2000) return ''  // 默认类型\n      if (time <= 3000) return 'warning'\n      return 'danger'\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n      }\n\n      const calculateNextCollectTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect()\n          // 设置下一次执行\n          scheduleNextCollection()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextCollection()\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        const nameMatch = !this.searchForm.name || \n          item.name.toLowerCase().includes(this.searchForm.name.toLowerCase())\n        \n        const groupMatch = !this.searchForm.group || \n          item.group === this.searchForm.group\n        \n        const statusMatch = !this.searchForm.status || \n          item.status === this.searchForm.status\n        \n        return nameMatch && groupMatch && statusMatch\n      })\n      \n      // 重置到第一页\n      this.currentPage = 1\n      this.searchDialogVisible = false\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      }\n      this.filteredList = []\n      this.currentPage = 1\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`)\n        if (response.ok) {\n          const data = await response.json()\n          this.realIp = data.ip\n          localStorage.setItem('realIp', data.ip)  // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error)\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      const useRealIp = localStorage.getItem('useRealIp') === 'true'\n      return useRealIp && this.realIp ? `http://${this.realIp}:8080` : 'http://localhost:8080'\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate()\n\n        // 保存设置到localStorage\n        localStorage.setItem('githubToken', this.syncForm.token)\n        localStorage.setItem('githubRepo', this.syncForm.repo)\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath)\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath)\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync)\n        localStorage.setItem('githubSyncType', this.syncForm.syncType)\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime)\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay)\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule()\n        } else {\n          this.clearSyncSchedule()\n        }\n\n        this.$message.success('设置已保存')\n        this.syncDialogVisible = false\n      } catch (error) {\n        this.$message.error(error.message || '保存失败')\n      }\n    },\n    async syncToGithub(content, path) {\n      const response = await fetch(`${this.getBaseUrl()}/api/sync-github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          token: this.syncForm.token,\n          repo: this.syncForm.repo,\n          path: path,\n          content: content,\n          message: this.syncForm.message\n        })\n      })\n      \n      if (!response.ok) {\n        throw new Error('同步失败')\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule()\n      } else {\n        this.clearSyncSchedule()\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule()\n      const calculateNextSyncTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(async () => {\n          try {\n            // 执行同步\n            await this.syncToGithub(this.generateContent('txt'), this.syncForm.txtPath)\n            await this.syncToGithub(this.generateContent('m3u'), this.syncForm.m3uPath)\n            this.$message.success('已同步到GitHub')\n          } catch (error) {\n            this.$message.error('同步失败：' + error.message)\n          }\n          // 设置下一次执行\n          scheduleNextSync()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextSync()\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer)\n        this.syncTimer = null\n      }\n    },\n    getStatusTagType(status) {\n      switch (status) {\n        case '正常':\n          return 'success'\n        case '异常':\n          return 'danger'\n        case '未知':\n          return 'warning'\n        case '未检测':\n          return 'info'\n        default:\n          return 'info'\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent()\n        this.saveState()\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState()\n    },\n    pageSize() {\n      this.saveState()\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus()\n    },\n    isCollecting() {\n      this.updateActiveStatus()\n    },\n    isScheduled() {\n      this.updateActiveStatus()\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink()\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true)\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule()\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer)\n      this.scheduleTimer = null\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n      this.collectTimer = null\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer)\n      this.syncTimer = null\n    }\n  }\n}\n</script>\n\n<style scoped>\n.stream-check {\n  padding: 25px;\n  background-color: #fff;\n  border-radius: 4px;\n  /* 添加最大高度和滚动控制 */\n  height: calc(100vh - 130px);  /* 减去头部和其他元素的高度 */\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  position: relative; /* 添加相对定位 */\n}\n\n.table-operations {\n  margin-bottom: 20px;\n  display: flex;\n  gap: 10px;\n  flex-shrink: 0; /* 防止工具栏被压缩 */\n}\n\n/* 添加表格容器样式 */\n.el-table-wrapper {\n  flex: 1;\n  position: relative; /* 添加相对定位 */\n  min-height: 200px; /* 设置最小高度 */\n}\n\n/* 覆盖 element-ui 的表格样式 */\n:deep(.el-table) {\n  position: absolute; /* 绝对定位 */\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  height: 100%;\n  max-height: 100%;\n}\n\n:deep(.el-table__body-wrapper) {\n  height: calc(100% - 40px) !important; /* 减去表头高度 */\n  overflow-y: auto !important;\n}\n\n:deep(.el-table__fixed-right) {\n  height: 100% !important; /* 修复固定列的高度 */\n  bottom: 0px;\n}\n\n:deep(.el-table__fixed-right .el-table__fixed-body-wrapper) {\n  height: calc(100% - 40px) !important; /* 减去表头高度 */\n}\n\n.pagination-container {\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n  flex-shrink: 0; /* 防止分页被压缩 */\n  padding-bottom: 10px; /* 添加底部间距 */\n  background-color: #fff; /* 确保分页器背景色 */\n  position: relative; /* 添加相对定位 */\n  z-index: 1; /* 确保分页器在最上层 */\n}\n\n.el-button [class*=\"el-icon-\"] {\n  font-size: 18px;\n}\n\n.delete-btn {\n  color: #F56C6C;\n}\n\n.delete-btn:hover {\n  color: #ff4d4d;\n}\n\n.setting-tip {\n  margin-left: 10px;\n  color: #909399;\n  font-size: 13px;\n}\n\n.link-info {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.link-info p {\n  margin: 0;\n  color: #606266;\n}\n\n.link-actions {\n  display: flex;\n  gap: 10px;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n/* 生成链接对话框样式 */\n.generate-link-dialog {\n  max-width: 600px;\n}\n\n.link-container {\n  display: flex;\n  flex-direction: column;\n  gap: 15px;\n}\n\n.link-card, .tips-card {\n  margin: 0;\n  border: 1px solid #EBEEF5;\n}\n\n.link-content {\n  padding: 10px;\n}\n\n.tips-content {\n  color: #606266;\n  font-size: 14px;\n  padding: 10px;\n}\n\n.tips-content ul {\n  margin: 0;\n  padding-left: 20px;\n  line-height: 1.8;\n}\n\n/* 覆盖 element-ui 的一些默认样式 */\n:deep(.el-dialog__body) {\n  padding: 20px;\n}\n\n:deep(.el-card__header) {\n  padding: 12px 20px;\n  font-weight: 500;\n}\n\n:deep(.el-card__body) {\n  padding: 15px;\n}\n\n/* 可以添加一些自定义样式 */\n.el-tag {\n  width: 90px;  /* 统一标签宽度 */\n}\n\n.el-tag + .el-tag {\n  margin-left: 4px;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
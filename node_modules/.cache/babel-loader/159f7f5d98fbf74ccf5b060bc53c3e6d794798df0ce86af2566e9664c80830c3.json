{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      // No changes to data section\n    };\n  },\n  computed: {\n    // No changes to computed section\n  },\n  created() {\n    // No changes to created section\n  },\n  beforeDestroy() {\n    // No changes to beforeDestroy section\n  },\n  methods: {\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath');\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径');\n        return false;\n      }\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n\n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常';\n        stream.resolution = result.resolution || '';\n        stream.responseTime = result.responseTime || 0;\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = '';\n          if (stream.status === '异常') {\n            reason = '异常源';\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢';\n          } else {\n            reason = '分辨率过低';\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData;\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream);\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`);\n          }\n        }\n        this.saveStreamList();\n        return result.available;\n      } catch (error) {\n        console.error('检测错误:', error);\n        stream.status = '异常';\n        return false;\n      }\n    },\n    async handleBatchCheck() {\n      if (this.isChecking) return;\n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex);\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源');\n        return;\n      }\n      this.isChecking = true;\n      this.shouldStop = false;\n      this.totalCount = uncheckedStreams.length;\n      this.checkedCount = this.isPaused ? this.checkedCount : 0;\n\n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3;\n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0;\n\n        // 使用并发检测\n        for (let i = startIndex; i < uncheckedStreams.length; i += concurrentChecks) {\n          if (this.shouldStop) break;\n\n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + concurrentChecks);\n\n          // 并发检测当前批次的所有流\n          await Promise.all(batch.map(async stream => {\n            if (this.shouldStop) return;\n            stream.status = '检测中';\n            const success = await this.checkStream(stream);\n            this.checkedCount++;\n            if (success) {\n              this.saveState();\n            }\n          }));\n\n          // 更新暂停位置\n          this.pausedIndex = i + concurrentChecks - 1;\n        }\n        if (!this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = false;\n          this.pausedIndex = -1;\n          this.$message.success('批量检测完成');\n\n          // 检查是否需要在检测完成后同步到GitHub\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            try {\n              await this.handleSync();\n            } catch (error) {\n              console.error('检测完成后同步失败:', error);\n              this.$message.error('自动同步失败：' + (error.message || '未知错误'));\n            }\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error);\n        this.$message.error('批量检测失败');\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = true;\n          this.$message.info('检测已暂停');\n        }\n      }\n    },\n    pauseCheck() {\n      this.shouldStop = true;\n    },\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true;\n        this.isPaused = false;\n        this.shouldStop = false;\n        await this.batchCheck(this.pausedIndex);\n      }\n    },\n    async handleCheck(row) {\n      row.status = '检测中';\n      const success = await this.checkStream(row);\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`);\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row);\n        this.streamList.splice(index, 1);\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('删除成功');\n      }).catch(() => {});\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate();\n      if (!valid) return;\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importForm.url\n          })\n        });\n        if (!response.ok) throw new Error('导入失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n            this.importUrlDialogVisible = false;\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message);\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      const lines = content.split('\\n');\n      const streams = [];\n      let currentGroup = '未分组';\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = '';\n        let currentGroupTitle = '';\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = '';\n\n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i);\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim();\n            }\n\n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',');\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim();\n              }\n            }\n\n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i);\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim();\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i);\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim();\n                }\n              }\n            }\n            currentName = name || '未命名';\n\n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i);\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim();\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i);\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim();\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n            currentName = ''; // 重置当前名称\n          }\n        });\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '');\n            return;\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',');\n          if (!name || !urls) return;\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#');\n\n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n          });\n        });\n      }\n      return streams;\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream);\n      });\n      this.currentPage = 1;\n      this.saveStreamList(); // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (name.includes('cctv')) return 'CCTV';\n      if (name.includes('卫视')) return '卫视';\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空');\n        return;\n      }\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = [];\n        this.currentPage = 1;\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('列表已清空');\n      }).catch(() => {});\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && stream.status === '异常') {\n        return true;\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true';\n      const strictMode = localStorage.getItem('strictMode') === 'true';\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number);\n        if (extremeMode ? width < 1920 || height < 1080 : strictMode ? width < 1920 || height < 1080 : width < 1280 || height < 720) {\n          return true;\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && stream.responseTime > (extremeMode ? 1500 : strictMode ? 2000 : 3000)) {\n        return true;\n      }\n      return false;\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', ['']);\n          return;\n        }\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState(); // 保存状态\n\n      // 立即执行一次采集\n      await this.collect();\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule();\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false;\n        this.saveState();\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集');\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集');\n          return;\n        }\n        this.$message.info('开始采集直播源...');\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(this.collectForm.urls.map(async url => {\n          try {\n            const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n              method: 'GET',\n              headers: {\n                'Accept': 'text/plain'\n              }\n            });\n            if (!response.ok) throw new Error(`采集失败: ${url}`);\n            const content = await response.text();\n            const newStreams = this.parseContent(content);\n\n            // 过滤重复的直播源，同时考虑正在检测的源\n            const existingUrls = new Set(this.streamList.map(s => s.url));\n            return newStreams.filter(s => {\n              // 如果源已存在且正在检测中，保留原有状态\n              const existingStream = this.streamList.find(es => es.url === s.url);\n              if (existingStream && existingStream.status === '检测中') {\n                return false;\n              }\n              return !existingUrls.has(s.url);\n            });\n          } catch (error) {\n            console.error(`采集地址 ${url} 失败:`, error);\n            return [];\n          }\n        }));\n\n        // 合并所有采集结果\n        const allNewStreams = results.filter(result => result.status === 'fulfilled').flatMap(result => result.value).filter((stream, index, self) => index === self.findIndex(s => s.url === stream.url));\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams);\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`);\n        } else {\n          this.$message.info('未发现新的直播源');\n        }\n\n        // 统计失败的地址\n        const failedUrls = results.filter(result => result.status === 'rejected').length;\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`);\n        }\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message);\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      }\n    },\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true;\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text();\n          const m3uLink = await m3uResponse.text();\n\n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          };\n          this.generatedLink = this.generatedLinks[this.linkForm.format];\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error);\n        this.$message.error('生成链接失败');\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent();\n    },\n    generateTxtContent() {\n      let content = '';\n      let currentGroup = '';\n\n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0; // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity;\n        const bTime = Number(b.responseTime) || Infinity;\n        return aTime - bTime;\n      });\n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `${currentGroup},#genre#\\n`;\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`;\n      });\n      return content.trim();\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n';\n      let currentGroup = '';\n\n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0; // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity;\n        const bTime = Number(b.responseTime) || Infinity;\n        return aTime - bTime;\n      });\n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`;\n        }\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`;\n        });\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        });\n\n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n      const calculateNextExecutionTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime;\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck();\n          }\n          // 设置下一次执行\n          scheduleNextExecution();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextExecution();\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 只保存必要的数据，减少存储大小\n        const streamListToSave = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution,\n          responseTime: stream.responseTime\n        }));\n\n        // 分块存储大数据\n        const chunkSize = 100; // 每块存储100条数据\n        const chunks = [];\n        for (let i = 0; i < streamListToSave.length; i += chunkSize) {\n          chunks.push(streamListToSave.slice(i, i + chunkSize));\n        }\n\n        // 清除旧的分块数据\n        for (let i = 0; i < localStorage.length; i++) {\n          const key = localStorage.key(i);\n          if (key && key.startsWith(`${this.stateKey}_chunk_`)) {\n            localStorage.removeItem(key);\n          }\n        }\n\n        // 存储新的分块数据\n        chunks.forEach((chunk, index) => {\n          localStorage.setItem(`${this.stateKey}_chunk_${index}`, JSON.stringify(chunk));\n        });\n\n        // 存储分块数量和其他设置\n        const state = {\n          chunkCount: chunks.length,\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm\n        };\n        localStorage.setItem(this.stateKey, JSON.stringify(state));\n      } catch (error) {\n        console.warn('保存状态失败:', error);\n        // 如果存储失败，尝试清理一些旧数据\n        try {\n          for (let i = localStorage.length - 1; i >= 0; i--) {\n            const key = localStorage.key(i);\n            if (key && key.startsWith(`${this.stateKey}_chunk_`)) {\n              localStorage.removeItem(key);\n            }\n          }\n        } catch (e) {\n          console.error('清理存储失败:', e);\n        }\n      }\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 恢复分块数据\n          this.streamList = [];\n          if (state.chunkCount) {\n            for (let i = 0; i < state.chunkCount; i++) {\n              const chunk = localStorage.getItem(`${this.stateKey}_chunk_${i}`);\n              if (chunk) {\n                this.streamList.push(...JSON.parse(chunk));\n              }\n            }\n          }\n\n          // 恢复其他设置\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          this.scheduleForm = state.scheduleForm || this.scheduleForm;\n          this.collectForm = state.collectForm || this.collectForm;\n\n          // 重置所有运行状态\n          this.isChecking = false;\n          this.isPaused = false;\n          this.isScheduled = false;\n          this.isCollecting = false;\n          this.checkedCount = 0;\n          this.totalCount = 0;\n          this.pausedIndex = -1;\n          this.nextScheduleTime = null;\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error);\n        // 如果恢复失败，清空状态\n        this.streamList = [];\n        this.currentPage = 1;\n        this.pageSize = 5;\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', ['']);\n      } else {\n        this.collectForm.urls.push('');\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1);\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info';\n      const [width] = resolution.split('x').map(Number);\n      if (width >= 1920) return 'success';\n      if (width >= 1280) return ''; // 默认类型\n      return 'warning';\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info';\n      if (responseTime <= 1000) return 'success';\n      if (responseTime <= 2000) return ''; // 默认类型\n      if (responseTime <= 3000) return 'warning';\n      return 'danger';\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n      }\n      const calculateNextCollectTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect();\n          // 设置下一次执行\n          scheduleNextCollection();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextCollection();\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        const nameMatch = !this.searchForm.name || item.name.toLowerCase().includes(this.searchForm.name.toLowerCase());\n        const groupMatch = !this.searchForm.group || item.group === this.searchForm.group;\n        const statusMatch = !this.searchForm.status || item.status === this.searchForm.status;\n        return nameMatch && groupMatch && statusMatch;\n      });\n\n      // 重置到第一页\n      this.currentPage = 1;\n      this.searchDialogVisible = false;\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      };\n      this.filteredList = [];\n      this.currentPage = 1;\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`);\n        if (response.ok) {\n          const data = await response.json();\n          this.realIp = data.ip;\n          localStorage.setItem('realIp', data.ip); // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error);\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      const useRealIp = localStorage.getItem('useRealIp') === 'true';\n      return useRealIp && this.realIp ? `http://${this.realIp}:8080` : 'http://localhost:8080';\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate();\n\n        // 保存设置\n        localStorage.setItem('githubToken', this.syncForm.token);\n        localStorage.setItem('githubRepo', this.syncForm.repo);\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath);\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath);\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync);\n        localStorage.setItem('githubSyncType', this.syncForm.syncType);\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime);\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay);\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule();\n        } else {\n          this.clearSyncSchedule();\n        }\n        this.$message.success('设置保存成功');\n        this.syncDialogVisible = false;\n      } catch (error) {\n        this.$message.error(error.message || '保存失败');\n      }\n    },\n    async handleSync() {\n      try {\n        // 同步 TXT 内容\n        const txtContent = this.generateContent('txt');\n        await this.syncToGithub(txtContent, this.syncForm.txtPath);\n\n        // 同步 M3U 内容\n        const m3uContent = this.generateContent('m3u');\n        await this.syncToGithub(m3uContent, this.syncForm.m3uPath);\n        this.$message.success('同步成功');\n      } catch (error) {\n        console.error('同步失败:', error);\n        this.$message.error(error.message || '同步失败');\n        throw error; // 重新抛出错误以便调用者处理\n      }\n    },\n    async syncToGithub(content, path) {\n      const response = await fetch(`${this.getBaseUrl()}/api/sync-github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          token: this.syncForm.token,\n          repo: this.syncForm.repo,\n          path: path,\n          content: content,\n          message: this.syncForm.message\n        })\n      });\n      if (!response.ok) {\n        throw new Error('同步失败');\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule();\n      } else {\n        this.clearSyncSchedule();\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule();\n      const calculateNextSyncTime = () => {\n        const now = new Date();\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number);\n        let nextTime = new Date(now);\n        nextTime.setHours(hours, minutes, 0, 0);\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1);\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay);\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1);\n          }\n        }\n        return nextTime;\n      };\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime();\n        const delay = nextTime.getTime() - new Date().getTime();\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(() => {\n          // 执行同步\n          this.handleSync();\n          // 设置下一次执行\n          scheduleNextSync();\n        }, delay);\n      };\n\n      // 开始第一次调度\n      scheduleNextSync();\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer);\n        this.syncTimer = null;\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink();\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true);\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule();\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","computed","created","beforeDestroy","methods","checkStream","stream","ffprobePath","localStorage","getItem","$message","error","response","fetch","getBaseUrl","method","headers","body","JSON","stringify","url","ok","Error","result","json","status","available","resolution","responseTime","shouldRemoveStream","reason","currentPageItems","paginatedData","pageIndex","indexOf","listIndex","streamList","splice","length","currentPage","warning","saveStreamList","console","handleBatchCheck","isChecking","uncheckedStreams","filter","s","isPaused","pausedIndex","info","shouldStop","totalCount","checkedCount","concurrentChecks","parseInt","startIndex","i","batch","slice","Promise","all","map","success","saveState","syncForm","autoSync","syncType","handleSync","message","pauseCheck","resumeCheck","batchCheck","handleCheck","row","handleDelete","$confirm","confirmButtonText","cancelButtonText","type","then","index","maxPage","Math","ceil","pageSize","max","catch","handleUrlImport","valid","$refs","importForm","validate","content","text","newStreams","parseContent","existingUrls","Set","uniqueStreams","has","push","importUrlDialogVisible","readFile","file","resolve","reject","reader","FileReader","onload","e","target","onerror","readAsText","lines","split","streams","currentGroup","includes","currentName","currentGroupTitle","forEach","line","trim","startsWith","tvgNameMatch","match","lastCommaIndex","lastIndexOf","substring","tvgIdMatch","tvgIdNoQuoteMatch","groupMatch","groupNoQuoteMatch","group","endsWith","replace","urls","urlList","addStreamsToList","handleSizeChange","val","handleCurrentChange","handleFileUpload","event","files","value","getGroupFromFileName","filename","toLowerCase","handleClearList","handleCopy","textarea","document","createElement","appendChild","select","execCommand","err","removeChild","extremeMode","strictMode","width","height","Number","setItem","handleCollectMode","isCollecting","stopCollecting","collectDialogVisible","startCollecting","isRestore","Array","isArray","collectForm","$set","collect","autoCollect","setupCollectSchedule","collectTimer","clearInterval","results","allSettled","encodeURIComponent","existingStream","find","es","allNewStreams","flatMap","self","findIndex","failedUrls","handleGenerateLink","generateLinkDialogVisible","txtResponse","generateContent","m3uResponse","txtLink","m3uLink","generatedLinks","txt","m3u","generatedLink","linkForm","format","generateTxtContent","generateM3uContent","sortedStreams","mergedStreams","sort","a","b","aTime","Infinity","bTime","join","copyGeneratedLink","downloadTxtFile","blob","Blob","window","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","updateLinkContent","handleScheduleCheck","isScheduled","stopScheduleCheck","scheduleDialogVisible","startScheduleCheck","scheduleForm","setupSchedule","scheduleTimer","nextScheduleTime","calculateNextExecutionTime","now","hours","minutes","executeTime","nextTime","setHours","setDate","getDate","scheduleType","targetDay","weekDay","getDay","scheduleNextExecution","delay","getTime","setTimeout","streamListToSave","chunkSize","chunks","key","stateKey","removeItem","chunk","state","chunkCount","warn","restoreState","savedState","parse","resetAllStates","updateActiveStatus","hasActive","hasActiveOperations","addEventListener","handleBeforeUnload","removeEventListener","preventDefault","returnValue","addCollectUrl","removeCollectUrl","getResolutionTagType","getResponseTimeTagType","calculateNextCollectTime","collectType","scheduleNextCollection","handleSearch","filteredList","item","nameMatch","searchForm","statusMatch","searchDialogVisible","resetSearch","getRealIp","realIp","ip","useRealIp","saveGithubSettings","token","repo","txtPath","m3uPath","setupSyncSchedule","clearSyncSchedule","syncDialogVisible","txtContent","syncToGithub","m3uContent","path","handleAutoSyncChange","calculateNextSyncTime","scheduleNextSync","syncTimer","watch","handler","deep","linkForm.format","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\n  <!-- No changes to template section -->\n</template>\n\n<script>\nexport default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      // No changes to data section\n    }\n  },\n  computed: {\n    // No changes to computed section\n  },\n  created() {\n    // No changes to created section\n  },\n  beforeDestroy() {\n    // No changes to beforeDestroy section\n  },\n  methods: {\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath')\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径')\n        return false\n      }\n\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/check-stream`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        })\n\n        if (!response.ok) throw new Error('请求失败')\n        \n        const result = await response.json()\n        \n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常'\n        stream.resolution = result.resolution || ''\n        stream.responseTime = result.responseTime || 0\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = ''\n          if (stream.status === '异常') {\n            reason = '异常源'\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢'\n          } else {\n            reason = '分辨率过低'\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream)\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream)\n          \n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1)\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`)\n          }\n        }\n        \n        this.saveStreamList()\n        return result.available\n      } catch (error) {\n        console.error('检测错误:', error)\n        stream.status = '异常'\n        return false\n      }\n    },\n\n    async handleBatchCheck() {\n      if (this.isChecking) return\n      \n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex)\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源')\n        return\n      }\n\n      this.isChecking = true\n      this.shouldStop = false\n      this.totalCount = uncheckedStreams.length\n      this.checkedCount = this.isPaused ? this.checkedCount : 0\n      \n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3\n      \n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0\n        \n        // 使用并发检测\n        for (let i = startIndex; i < uncheckedStreams.length; i += concurrentChecks) {\n          if (this.shouldStop) break\n          \n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + concurrentChecks)\n          \n          // 并发检测当前批次的所有流\n          await Promise.all(\n            batch.map(async stream => {\n              if (this.shouldStop) return\n              \n              stream.status = '检测中'\n              const success = await this.checkStream(stream)\n              this.checkedCount++\n              \n              if (success) {\n                this.saveState()\n              }\n            })\n          )\n          \n          // 更新暂停位置\n          this.pausedIndex = i + concurrentChecks - 1\n        }\n\n        if (!this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = false\n          this.pausedIndex = -1\n          this.$message.success('批量检测完成')\n          \n          // 检查是否需要在检测完成后同步到GitHub\n          if (this.syncForm.autoSync && this.syncForm.syncType === 'afterCheck') {\n            try {\n              await this.handleSync()\n            } catch (error) {\n              console.error('检测完成后同步失败:', error)\n              this.$message.error('自动同步失败：' + (error.message || '未知错误'))\n            }\n          }\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error)\n        this.$message.error('批量检测失败')\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = true\n          this.$message.info('检测已暂停')\n        }\n      }\n    },\n\n    pauseCheck() {\n      this.shouldStop = true\n    },\n\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true\n        this.isPaused = false\n        this.shouldStop = false\n        await this.batchCheck(this.pausedIndex)\n      }\n    },\n\n    async handleCheck(row) {\n      row.status = '检测中'\n      \n      const success = await this.checkStream(row)\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`)\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row)\n        this.streamList.splice(index, 1)\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1)\n        }\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('删除成功')\n      }).catch(() => {})\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate()\n      if (!valid) return\n\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch(`${this.getBaseUrl()}/api/import-url`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: this.importForm.url })\n        })\n\n        if (!response.ok) throw new Error('导入失败')\n\n        const content = await response.text()\n        const newStreams = this.parseContent(content)\n\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            this.importUrlDialogVisible = false\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message)\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = (e) => resolve(e.target.result)\n        reader.onerror = () => reject(new Error('文件读取失败'))\n        reader.readAsText(file)\n      })\n    },\n    parseContent(content) {\n      const lines = content.split('\\n')\n      const streams = []\n      let currentGroup = '未分组'\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = ''\n        let currentGroupTitle = ''\n\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          if (line.startsWith('#EXTINF:')) {\n            // 尝试不同的名称提取方式\n            let name = ''\n            \n            // 1. 尝试提取 tvg-name 属性\n            const tvgNameMatch = line.match(/tvg-name=\"([^\"]+)\"/i)\n            if (tvgNameMatch) {\n              name = tvgNameMatch[1].trim()\n            }\n            \n            // 2. 如果没有 tvg-name，尝试提取最后的逗号后的名称\n            if (!name) {\n              const lastCommaIndex = line.lastIndexOf(',')\n              if (lastCommaIndex !== -1) {\n                name = line.substring(lastCommaIndex + 1).trim()\n              }\n            }\n            \n            // 3. 如果还是没有名称，尝试提取 tvg-id\n            if (!name) {\n              const tvgIdMatch = line.match(/tvg-id=\"([^\"]+)\"/i)\n              if (tvgIdMatch) {\n                name = tvgIdMatch[1].trim()\n              } else {\n                // 3.1 尝试提取不带引号的 tvg-id\n                const tvgIdNoQuoteMatch = line.match(/tvg-id=([^,\\s]+)/i)\n                if (tvgIdNoQuoteMatch) {\n                  name = tvgIdNoQuoteMatch[1].trim()\n                }\n              }\n            }\n\n            currentName = name || '未命名'\n            \n            // 提取分组信息\n            // 1. 先尝试带引号的 group-title\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/i)\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim()\n            } else {\n              // 2. 尝试不带引号的 group-title\n              const groupNoQuoteMatch = line.match(/group-title=([^,\\s]+)/i)\n              if (groupNoQuoteMatch) {\n                currentGroupTitle = groupNoQuoteMatch[1].trim()\n              }\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL行\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n            currentName = ''  // 重置当前名称\n          }\n        })\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '')\n            return\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',')\n          if (!name || !urls) return\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#')\n          \n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n          })\n        })\n      }\n\n      return streams\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream)\n      })\n      this.currentPage = 1\n      this.saveStreamList()  // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase()\n      if (name.includes('cctv')) return 'CCTV'\n      if (name.includes('卫视')) return '卫视'\n      if (name.includes('地方')) return '地方台'\n      return '未分组'\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空')\n        return\n      }\n\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = []\n        this.currentPage = 1\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('列表已清空')\n      }).catch(() => {})\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea')\n      textarea.value = row.url\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && \n          stream.status === '异常') {\n        return true\n      }\n\n      // 获取模式设置\n      const extremeMode = localStorage.getItem('extremeMode') === 'true'\n      const strictMode = localStorage.getItem('strictMode') === 'true'\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && \n          stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number)\n        if (extremeMode ? (width < 1920 || height < 1080) : \n            (strictMode ? (width < 1920 || height < 1080) : (width < 1280 || height < 720))) {\n          return true\n        }\n      }\n\n      // 检查响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && \n          stream.responseTime > (extremeMode ? 1500 : (strictMode ? 2000 : 3000))) {\n        return true\n      }\n\n      return false\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting()\n      } else {\n        this.collectDialogVisible = true\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', [''])\n          return\n        }\n        \n        const valid = await this.$refs.collectForm.validate()\n        if (!valid) return\n      }\n\n      this.collectDialogVisible = false\n      this.isCollecting = true\n      this.saveState() // 保存状态\n      \n      // 立即执行一次采集\n      await this.collect()\n      \n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.setupCollectSchedule()\n      } else {\n        // 单次采集完成后停止\n        this.isCollecting = false\n        this.saveState()\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      this.saveState() // 保存状态\n      // 只有在自动采集模式下才显示停止提示\n      if (this.collectForm.autoCollect) {\n        this.$message.success('已停止采集')\n      }\n    },\n    async collect() {\n      try {\n        // 检查是否有检测正在进行\n        if (this.isChecking) {\n          this.$message.warning('检测正在进行中，暂时跳过本次采集')\n          return\n        }\n\n        this.$message.info('开始采集直播源...')\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(\n          this.collectForm.urls.map(async url => {\n            try {\n              const response = await fetch(`${this.getBaseUrl()}/api/collect-url?url=${encodeURIComponent(url)}`, {\n                method: 'GET',\n                headers: {\n                  'Accept': 'text/plain'\n                },\n              })\n              if (!response.ok) throw new Error(`采集失败: ${url}`)\n              \n              const content = await response.text()\n              const newStreams = this.parseContent(content)\n              \n              // 过滤重复的直播源，同时考虑正在检测的源\n              const existingUrls = new Set(this.streamList.map(s => s.url))\n              return newStreams.filter(s => {\n                // 如果源已存在且正在检测中，保留原有状态\n                const existingStream = this.streamList.find(es => es.url === s.url)\n                if (existingStream && existingStream.status === '检测中') {\n                  return false\n                }\n                return !existingUrls.has(s.url)\n              })\n            } catch (error) {\n              console.error(`采集地址 ${url} 失败:`, error)\n              return []\n            }\n          })\n        )\n\n        // 合并所有采集结果\n        const allNewStreams = results\n          .filter(result => result.status === 'fulfilled')\n          .flatMap(result => result.value)\n          .filter((stream, index, self) => \n            index === self.findIndex(s => s.url === stream.url)\n          )\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams)\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`)\n        } else {\n          this.$message.info('未发现新的直播源')\n        }\n\n        // 统计失败的地址\n        const failedUrls = results\n          .filter(result => result.status === 'rejected')\n          .length\n\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`)\n        }\n\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message)\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting()\n        }\n      }\n    },\n    async handleGenerateLink() {\n      this.generateLinkDialogVisible = true\n      try {\n        // 先生成 TXT 格式链接\n        const txtResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 再生成 M3U 格式链接\n        const m3uResponse = await fetch(`${this.getBaseUrl()}/api/generate-link`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n        \n        if (txtResponse.ok && m3uResponse.ok) {\n          const txtLink = await txtResponse.text()\n          const m3uLink = await m3uResponse.text()\n          \n          // 根据当前选择的格式显示对应的链接\n          this.generatedLinks = {\n            txt: txtLink,\n            m3u: m3uLink\n          }\n          this.generatedLink = this.generatedLinks[this.linkForm.format]\n        }\n      } catch (error) {\n        console.error('生成链接失败：', error)\n        this.$message.error('生成链接失败')\n      }\n    },\n    generateContent(format) {\n      return format === 'txt' ? this.generateTxtContent() : this.generateM3uContent()\n    },\n    generateTxtContent() {\n      let content = ''\n      let currentGroup = ''\n      \n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0  // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity\n        const bTime = Number(b.responseTime) || Infinity\n        return aTime - bTime\n      })\n      \n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `${currentGroup},#genre#\\n`\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`\n      })\n      \n      return content.trim()\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n'\n      let currentGroup = ''\n      \n      // 对每个分组内的直播源按响应速度排序\n      const sortedStreams = [...this.mergedStreams].sort((a, b) => {\n        if (a.group !== b.group) return 0  // 不同分组不改变顺序\n        const aTime = Number(a.responseTime) || Infinity\n        const bTime = Number(b.responseTime) || Infinity\n        return aTime - bTime\n      })\n      \n      sortedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`\n        }\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`\n        })\n      })\n      \n      return content.trim()\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea')\n      textarea.value = this.generatedLink\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\n      \n      document.body.appendChild(link)\n      link.click()\n      \n      // 清理\n      window.URL.revokeObjectURL(url)\n      document.body.removeChild(link)\n      this.$message.success('文件下载成功')\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        // 更新 TXT 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'txt'\n          },\n          body: this.generateContent('txt')\n        })\n        \n        // 更新 M3U 格式内容\n        await fetch(`${this.getBaseUrl()}/api/update-content`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': 'm3u'\n          },\n          body: this.generateContent('m3u')\n        })\n      } catch (error) {\n        console.error('更新链接内容失败：', error)\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      } else {\n        this.scheduleDialogVisible = true\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false\n          this.isScheduled = true\n          this.setupSchedule()\n          this.saveState() // 保存状态\n          this.$message.success('定时检测已开启')\n        }\n      })\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      this.isScheduled = false\n      this.nextScheduleTime = null\n      this.saveState() // 保存状态\n      this.$message.success('定时检测已停止')\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n      }\n\n      const calculateNextExecutionTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.scheduleForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.scheduleForm.scheduleType === 'weekly') {\n          const targetDay = parseInt(this.scheduleForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextExecution = () => {\n        const nextTime = calculateNextExecutionTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 更新下次执行时间显示\n        this.nextScheduleTime = nextTime\n\n        // 设置下次执行的定时器\n        this.scheduleTimer = setTimeout(() => {\n          // 如果当前正在检测中，等待检测完成后再执行\n          if (!this.isChecking) {\n            this.handleBatchCheck()\n          }\n          // 设置下一次执行\n          scheduleNextExecution()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextExecution()\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      try {\n        // 只保存必要的数据，减少存储大小\n        const streamListToSave = this.streamList.map(stream => ({\n          name: stream.name,\n          url: stream.url,\n          group: stream.group,\n          status: stream.status,\n          resolution: stream.resolution,\n          responseTime: stream.responseTime\n        }))\n\n        // 分块存储大数据\n        const chunkSize = 100  // 每块存储100条数据\n        const chunks = []\n        for (let i = 0; i < streamListToSave.length; i += chunkSize) {\n          chunks.push(streamListToSave.slice(i, i + chunkSize))\n        }\n\n        // 清除旧的分块数据\n        for (let i = 0; i < localStorage.length; i++) {\n          const key = localStorage.key(i)\n          if (key && key.startsWith(`${this.stateKey}_chunk_`)) {\n            localStorage.removeItem(key)\n          }\n        }\n\n        // 存储新的分块数据\n        chunks.forEach((chunk, index) => {\n          localStorage.setItem(`${this.stateKey}_chunk_${index}`, JSON.stringify(chunk))\n        })\n\n        // 存储分块数量和其他设置\n        const state = {\n          chunkCount: chunks.length,\n          currentPage: this.currentPage,\n          pageSize: this.pageSize,\n          scheduleForm: this.scheduleForm,\n          collectForm: this.collectForm\n        }\n        localStorage.setItem(this.stateKey, JSON.stringify(state))\n      } catch (error) {\n        console.warn('保存状态失败:', error)\n        // 如果存储失败，尝试清理一些旧数据\n        try {\n          for (let i = localStorage.length - 1; i >= 0; i--) {\n            const key = localStorage.key(i)\n            if (key && key.startsWith(`${this.stateKey}_chunk_`)) {\n              localStorage.removeItem(key)\n            }\n          }\n        } catch (e) {\n          console.error('清理存储失败:', e)\n        }\n      }\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey)\n        if (savedState) {\n          const state = JSON.parse(savedState)\n          \n          // 恢复分块数据\n          this.streamList = []\n          if (state.chunkCount) {\n            for (let i = 0; i < state.chunkCount; i++) {\n              const chunk = localStorage.getItem(`${this.stateKey}_chunk_${i}`)\n              if (chunk) {\n                this.streamList.push(...JSON.parse(chunk))\n              }\n            }\n          }\n\n          // 恢复其他设置\n          this.currentPage = state.currentPage || 1\n          this.pageSize = state.pageSize || 5\n          this.scheduleForm = state.scheduleForm || this.scheduleForm\n          this.collectForm = state.collectForm || this.collectForm\n\n          // 重置所有运行状态\n          this.isChecking = false\n          this.isPaused = false\n          this.isScheduled = false\n          this.isCollecting = false\n          this.checkedCount = 0\n          this.totalCount = 0\n          this.pausedIndex = -1\n          this.nextScheduleTime = null\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error)\n        // 如果恢复失败，清空状态\n        this.streamList = []\n        this.currentPage = 1\n        this.pageSize = 5\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      }\n      \n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting()\n      }\n      \n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n      }\n      \n      // 重置所有状态\n      this.isChecking = false\n      this.isPaused = false\n      this.isScheduled = false\n      this.isCollecting = false\n      this.checkedCount = 0\n      this.totalCount = 0\n      this.pausedIndex = -1\n      this.nextScheduleTime = null\n      \n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      \n      // 保存重置后的状态\n      this.saveState()\n      \n      this.$message.success('所有运行状态已重置')\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\n      \n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？'\n        e.preventDefault()\n        e.returnValue = message\n        return message\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', [''])\n      } else {\n        this.collectForm.urls.push('')\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1)\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info'\n      const [width] = resolution.split('x').map(Number)\n      if (width >= 1920) return 'success'\n      if (width >= 1280) return ''  // 默认类型\n      return 'warning'\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info'\n      if (responseTime <= 1000) return 'success'\n      if (responseTime <= 2000) return ''  // 默认类型\n      if (responseTime <= 3000) return 'warning'\n      return 'danger'\n    },\n    setupCollectSchedule() {\n      // 清除现有定时器\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n      }\n\n      const calculateNextCollectTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.collectForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.collectForm.collectType === 'weekly') {\n          const targetDay = parseInt(this.collectForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextCollection = () => {\n        const nextTime = calculateNextCollectTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.collectTimer = setTimeout(() => {\n          // 执行采集\n          this.collect()\n          // 设置下一次执行\n          scheduleNextCollection()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextCollection()\n    },\n    handleSearch() {\n      this.filteredList = this.streamList.filter(item => {\n        const nameMatch = !this.searchForm.name || \n          item.name.toLowerCase().includes(this.searchForm.name.toLowerCase())\n        \n        const groupMatch = !this.searchForm.group || \n          item.group === this.searchForm.group\n        \n        const statusMatch = !this.searchForm.status || \n          item.status === this.searchForm.status\n        \n        return nameMatch && groupMatch && statusMatch\n      })\n      \n      // 重置到第一页\n      this.currentPage = 1\n      this.searchDialogVisible = false\n    },\n    resetSearch() {\n      this.searchForm = {\n        name: '',\n        group: '',\n        status: ''\n      }\n      this.filteredList = []\n      this.currentPage = 1\n    },\n    // 获取真实IP地址\n    async getRealIp() {\n      try {\n        const response = await fetch(`${this.getBaseUrl()}/api/local-ip`)\n        if (response.ok) {\n          const data = await response.json()\n          this.realIp = data.ip\n          localStorage.setItem('realIp', data.ip)  // 保存真实IP到localStorage\n        }\n      } catch (error) {\n        console.error('获取IP失败:', error)\n      }\n    },\n    // 获取基础URL\n    getBaseUrl() {\n      const useRealIp = localStorage.getItem('useRealIp') === 'true'\n      return useRealIp && this.realIp ? `http://${this.realIp}:8080` : 'http://localhost:8080'\n    },\n    async saveGithubSettings() {\n      try {\n        await this.$refs.syncForm.validate()\n\n        // 保存设置\n        localStorage.setItem('githubToken', this.syncForm.token)\n        localStorage.setItem('githubRepo', this.syncForm.repo)\n        localStorage.setItem('githubTxtPath', this.syncForm.txtPath)\n        localStorage.setItem('githubM3uPath', this.syncForm.m3uPath)\n        localStorage.setItem('githubAutoSync', this.syncForm.autoSync)\n        localStorage.setItem('githubSyncType', this.syncForm.syncType)\n        localStorage.setItem('githubExecuteTime', this.syncForm.executeTime)\n        localStorage.setItem('githubWeekDay', this.syncForm.weekDay)\n\n        // 如果开启了自动同步，重新设置定时器\n        if (this.syncForm.autoSync) {\n          this.setupSyncSchedule()\n        } else {\n          this.clearSyncSchedule()\n        }\n\n        this.$message.success('设置保存成功')\n        this.syncDialogVisible = false\n      } catch (error) {\n        this.$message.error(error.message || '保存失败')\n      }\n    },\n    async handleSync() {\n      try {\n        // 同步 TXT 内容\n        const txtContent = this.generateContent('txt')\n        await this.syncToGithub(txtContent, this.syncForm.txtPath)\n\n        // 同步 M3U 内容\n        const m3uContent = this.generateContent('m3u')\n        await this.syncToGithub(m3uContent, this.syncForm.m3uPath)\n\n        this.$message.success('同步成功')\n      } catch (error) {\n        console.error('同步失败:', error)\n        this.$message.error(error.message || '同步失败')\n        throw error // 重新抛出错误以便调用者处理\n      }\n    },\n    async syncToGithub(content, path) {\n      const response = await fetch(`${this.getBaseUrl()}/api/sync-github`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          token: this.syncForm.token,\n          repo: this.syncForm.repo,\n          path: path,\n          content: content,\n          message: this.syncForm.message\n        })\n      })\n      \n      if (!response.ok) {\n        throw new Error('同步失败')\n      }\n    },\n    handleAutoSyncChange(value) {\n      if (value) {\n        this.setupSyncSchedule()\n      } else {\n        this.clearSyncSchedule()\n      }\n    },\n    setupSyncSchedule() {\n      this.clearSyncSchedule()\n      const calculateNextSyncTime = () => {\n        const now = new Date()\n        const [hours, minutes] = this.syncForm.executeTime.split(':').map(Number)\n        let nextTime = new Date(now)\n        nextTime.setHours(hours, minutes, 0, 0)\n\n        // 如果当前时间已经过了今天的执行时间，设置为明天\n        if (nextTime <= now) {\n          nextTime.setDate(nextTime.getDate() + 1)\n        }\n\n        // 如果是每周模式，调整到下一个符合条件的星期\n        if (this.syncForm.syncType === 'weekly') {\n          const targetDay = parseInt(this.syncForm.weekDay)\n          while (nextTime.getDay() !== targetDay) {\n            nextTime.setDate(nextTime.getDate() + 1)\n          }\n        }\n\n        return nextTime\n      }\n\n      const scheduleNextSync = () => {\n        const nextTime = calculateNextSyncTime()\n        const delay = nextTime.getTime() - new Date().getTime()\n\n        // 设置下次执行的定时器\n        this.syncTimer = setTimeout(() => {\n          // 执行同步\n          this.handleSync()\n          // 设置下一次执行\n          scheduleNextSync()\n        }, delay)\n      }\n\n      // 开始第一次调度\n      scheduleNextSync()\n    },\n    clearSyncSchedule() {\n      if (this.syncTimer) {\n        clearInterval(this.syncTimer)\n        this.syncTimer = null\n      }\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent()\n        this.saveState()\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState()\n    },\n    pageSize() {\n      this.saveState()\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus()\n    },\n    isCollecting() {\n      this.updateActiveStatus()\n    },\n    isScheduled() {\n      this.updateActiveStatus()\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink()\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true)\n    }\n    // 如果有GitHub自动同步，恢复同步定时器\n    if (this.syncForm.autoSync) {\n      this.setupSyncSchedule()\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer)\n      this.scheduleTimer = null\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n      this.collectTimer = null\n    }\n    // 暂停同步定时器，但保持状态标志\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer)\n      this.syncTimer = null\n    }\n  }\n}\n</script>\n\n<style scoped>\n.stream-check {\n  padding: 25px;\n  background-color: #fff;\n  border-radius: 4px;\n}\n\n.table-operations {\n  margin-bottom: 20px;\n  display: flex;\n  gap: 10px; /* 按钮组之间的间距 */\n}\n\n.pagination-container {\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n}\n\n.el-button [class*=\"el-icon-\"] {\n  font-size: 18px;\n}\n\n.delete-btn {\n  color: #F56C6C;\n}\n\n.delete-btn:hover {\n  color: #ff4d4d;\n}\n\n.setting-tip {\n  margin-left: 10px;\n  color: #909399;\n  font-size: 13px;\n}\n\n.link-info {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.link-info p {\n  margin: 0;\n  color: #606266;\n}\n\n.link-actions {\n  display: flex;\n  gap: 10px;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n/* 生成链接对话框样式 */\n.generate-link-dialog {\n  max-width: 600px;\n}\n\n.link-container {\n  display: flex;\n  flex-direction: column;\n  gap: 15px;\n}\n\n.link-card, .tips-card {\n  margin: 0;\n  border: 1px solid #EBEEF5;\n}\n\n.link-content {\n  padding: 10px;\n}\n\n.tips-content {\n  color: #606266;\n  font-size: 14px;\n  padding: 10px;\n}\n\n.tips-content ul {\n  margin: 0;\n  padding-left: 20px;\n  line-height: 1.8;\n}\n\n/* 覆盖 element-ui 的一些默认样式 */\n:deep(.el-dialog__body) {\n  padding: 20px;\n}\n\n:deep(.el-card__header) {\n  padding: 12px 20px;\n  font-weight: 500;\n}\n\n:deep(.el-card__body) {\n  padding: 15px;\n}\n\n/* 可以添加一些自定义样式 */\n.el-tag {\n  width: 90px;  /* 统一标签宽度 */\n}\n\n.el-tag + .el-tag {\n  margin-left: 4px;\n}\n</style> "],"mappings":"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MACA,SAAAS,SAAA;QACArI,aAAA,MAAAqI,SAAA;QACA,KAAAA,SAAA;MACA;IACA;EACA;EACAC,KAAA;IACA;IACAtR,UAAA;MACAuR,QAAA;QACA,KAAArF,iBAAA;QACA,KAAAtK,SAAA;MACA;MACA4P,IAAA;IACA;IACArR,YAAA;MACA,KAAAyB,SAAA;IACA;IACAqB,SAAA;MACA,KAAArB,SAAA;IACA;IACA;IACApB,WAAA;MACA,KAAAmO,kBAAA;IACA;IACAxG,aAAA;MACA,KAAAwG,kBAAA;IACA;IACAvC,YAAA;MACA,KAAAuC,kBAAA;IACA;IACA;IACA,iBAAA8C,CAAA;MACA,SAAA5H,yBAAA;QACA,KAAAD,kBAAA;MACA;IACA;EACA;EACA;EACA8H,UAAA;IACA;IACA,SAAAtF,WAAA;MACA,KAAAK,aAAA;IACA;IACA;IACA,SAAAtE,YAAA;MACA,KAAAG,eAAA;IACA;IACA;IACA,SAAAzG,QAAA,CAAAC,QAAA;MACA,KAAA6O,iBAAA;IACA;EACA;EACA;EACAgB,YAAA;IACA;IACA,SAAAjF,aAAA;MACA1D,aAAA,MAAA0D,aAAA;MACA,KAAAA,aAAA;IACA;IACA;IACA,SAAA3D,YAAA;MACAC,aAAA,MAAAD,YAAA;MACA,KAAAA,YAAA;IACA;IACA;IACA,SAAAsI,SAAA;MACArI,aAAA,MAAAqI,SAAA;MACA,KAAAA,SAAA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
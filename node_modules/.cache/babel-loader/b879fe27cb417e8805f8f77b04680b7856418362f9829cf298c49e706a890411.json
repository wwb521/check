{"ast":null,"code":"export default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importForm: {\n        url: '',\n        group: ''\n      },\n      importRules: {\n        url: [{\n          required: true,\n          message: '请输入URL地址',\n          trigger: 'blur'\n        }, {\n          type: 'url',\n          message: '请输入正确的URL地址',\n          trigger: 'blur'\n        }],\n        group: [{\n          required: true,\n          message: '请选择分组',\n          trigger: 'change'\n        }]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        autoCollect: false,\n        interval: 60\n      },\n      collectRules: {\n        urls: [{\n          type: 'array',\n          validator: (rule, value, callback) => {\n            if (value.length === 0) {\n              callback(new Error('请至少添加一个采集地址'));\n            }\n            // 验证每个URL\n            const errors = value.map(url => {\n              if (!url) return '采集地址不能为空';\n              if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址';\n              return null;\n            }).filter(error => error !== null);\n            if (errors.length > 0) {\n              callback(new Error(errors[0]));\n            } else {\n              callback();\n            }\n          },\n          trigger: 'change'\n        }],\n        interval: [{\n          required: true,\n          message: '请输入采集间隔',\n          trigger: 'blur'\n        }, {\n          validator: (rule, value, callback) => {\n            if (value < 1 || value > 10080) {\n              callback(new Error('采集间隔必须在1分钟到7天之间'));\n            } else {\n              callback();\n            }\n          },\n          trigger: 'change'\n        }]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',\n      // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        interval: 30,\n        unit: 'minute'\n      },\n      scheduleRules: {\n        interval: [{\n          required: true,\n          message: '请设置检测间隔',\n          trigger: 'change'\n        }, {\n          validator: (rule, value, callback) => {\n            if (this.scheduleForm.unit === 'second') {\n              if (value < 10 || value > 59) {\n                callback(new Error('秒数必须在10到59之间'));\n              }\n            } else {\n              if (value < 1 || value > 7980) {\n                callback(new Error('分钟数必须在1到7980之间'));\n              }\n            }\n            callback();\n          },\n          trigger: 'change'\n        }]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState',\n      // 用于本地存储的key\n      hasActiveOperations: false,\n      // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      }\n    };\n  },\n  computed: {\n    paginatedData() {\n      const start = (this.currentPage - 1) * this.pageSize;\n      const end = start + this.pageSize;\n      return this.streamList.slice(start, end);\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测';\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`;\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map();\n\n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name; // 使用名称作为键\n\n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key);\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url);\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          });\n        }\n      });\n\n      // 转换回数组格式\n      return Array.from(streamMap.values());\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList');\n      if (savedList) {\n        this.streamList = JSON.parse(savedList);\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList);\n\n    // 从本地存储恢复状态\n    this.restoreState();\n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true); // true表示是恢复状态\n    }\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList);\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck();\n    // 在组件销毁前保存状态\n    this.saveState();\n    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n  },\n  methods: {\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath');\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径');\n        return false;\n      }\n      try {\n        const response = await fetch('http://localhost:8080/api/check-stream', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        });\n        if (!response.ok) throw new Error('请求失败');\n        const result = await response.json();\n\n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常';\n        stream.resolution = result.resolution || '';\n        stream.responseTime = result.responseTime || 0;\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = '';\n          if (stream.status === '异常') {\n            reason = '异常源';\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢';\n          } else {\n            reason = '分辨率过低';\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData;\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream);\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream);\n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1);\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--;\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`);\n          }\n        }\n        this.saveStreamList();\n        return result.available;\n      } catch (error) {\n        console.error('检测错误:', error);\n        stream.status = '异常';\n        return false;\n      }\n    },\n    async handleBatchCheck() {\n      if (this.isChecking) return;\n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex);\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源');\n        return;\n      }\n      this.isChecking = true;\n      this.shouldStop = false;\n      this.totalCount = uncheckedStreams.length;\n      this.checkedCount = this.isPaused ? this.checkedCount : 0;\n\n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3;\n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0;\n\n        // 使用并发检测\n        for (let i = startIndex; i < uncheckedStreams.length; i += concurrentChecks) {\n          if (this.shouldStop) break;\n\n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + concurrentChecks);\n\n          // 并发检测当前批次的所有流\n          await Promise.all(batch.map(async stream => {\n            if (this.shouldStop) return;\n            stream.status = '检测中';\n            const success = await this.checkStream(stream);\n            this.checkedCount++;\n            if (success) {\n              this.saveState();\n            }\n          }));\n\n          // 更新暂停位置\n          this.pausedIndex = i + concurrentChecks - 1;\n        }\n        if (!this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = false;\n          this.pausedIndex = -1;\n          this.$message.success('批量检测完成');\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error);\n        this.$message.error('批量检测失败');\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false;\n          this.isPaused = true;\n          this.$message.info('检测已暂停');\n        }\n      }\n    },\n    pauseCheck() {\n      this.shouldStop = true;\n    },\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true;\n        this.isPaused = false;\n        this.shouldStop = false;\n        await this.batchCheck(this.pausedIndex);\n      }\n    },\n    async handleCheck(row) {\n      row.status = '检测中';\n      const success = await this.checkStream(row);\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`);\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row);\n        this.streamList.splice(index, 1);\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize);\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1);\n        }\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('删除成功');\n      }).catch(() => {});\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate();\n      if (!valid) return;\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch('http://localhost:8080/api/import-url', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: this.importForm.url\n          })\n        });\n        if (!response.ok) throw new Error('导入失败');\n        const content = await response.text();\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n            this.importUrlDialogVisible = false;\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message);\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = e => resolve(e.target.result);\n        reader.onerror = () => reject(new Error('文件读取失败'));\n        reader.readAsText(file);\n      });\n    },\n    parseContent(content) {\n      const lines = content.split('\\n');\n      const streams = [];\n      let currentGroup = '未分组';\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = '';\n        let currentGroupTitle = '';\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n          if (line.startsWith('#EXTINF:')) {\n            // 提取频道名称\n            const nameMatch = line.match(/,(.+)$/);\n            currentName = nameMatch ? nameMatch[1].trim() : '';\n\n            // 检查是否有分组信息\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/);\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim();\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n            currentName = '';\n          }\n        });\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim();\n          if (!line) return;\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '');\n            return;\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',');\n          if (!name || !urls) return;\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#');\n\n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              });\n            }\n          });\n        });\n      }\n      return streams;\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream);\n      });\n      this.currentPage = 1;\n      this.saveStreamList(); // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val;\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1;\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val;\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0];\n      if (!file) return;\n      try {\n        const content = await this.readFile(file);\n        const newStreams = this.parseContent(content);\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url));\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url));\n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams);\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`);\n          } else {\n            this.$message.info('没有新的直播源可以导入');\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源');\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message);\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = '';\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase();\n      if (name.includes('cctv')) return 'CCTV';\n      if (name.includes('卫视')) return '卫视';\n      if (name.includes('地方')) return '地方台';\n      return '未分组';\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空');\n        return;\n      }\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = [];\n        this.currentPage = 1;\n        this.saveStreamList(); // 保存更新后的列表\n        this.$message.success('列表已清空');\n      }).catch(() => {});\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea');\n      textarea.value = row.url;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && stream.status === '异常') {\n        return true;\n      }\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number);\n        if (width < 1280 || height < 720) {\n          return true;\n        }\n      }\n\n      // 添加新的检查：响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && stream.responseTime > 3000) {\n        return true;\n      }\n      return false;\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList));\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting();\n      } else {\n        this.collectDialogVisible = true;\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', ['']);\n          return;\n        }\n        const valid = await this.$refs.collectForm.validate();\n        if (!valid) return;\n      }\n      this.collectDialogVisible = false;\n      this.isCollecting = true;\n      this.saveState(); // 保存状态\n\n      // 立即执行一次采集\n      if (!isRestore) {\n        await this.collect();\n      }\n\n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.collectTimer = setInterval(async () => {\n          await this.collect();\n        }, this.collectForm.interval * 60 * 1000);\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false;\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n      this.saveState(); // 保存状态\n      this.$message.success('已停止采集');\n    },\n    async collect() {\n      try {\n        this.$message.info('开始采集直播源...');\n        let totalNew = 0;\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(this.collectForm.urls.map(async url => {\n          try {\n            // 修改为通过后端获取内容\n            const response = await fetch('http://localhost:8080/api/collect-url', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify({\n                url\n              })\n            });\n            if (!response.ok) throw new Error(`采集失败: ${url}`);\n            const content = await response.text();\n            const newStreams = this.parseContent(content);\n\n            // 过滤重复的直播源\n            const existingUrls = new Set(this.streamList.map(s => s.url));\n            return newStreams.filter(s => {\n              // 如果源已存在且正在检测中，保留原有状态\n              const existingStream = this.streamList.find(es => es.url === s.url);\n              if (existingStream && existingStream.status === '检测中') {\n                return false;\n              }\n              return !existingUrls.has(s.url);\n            });\n          } catch (error) {\n            console.error(`采集地址 ${url} 失败:`, error);\n            return [];\n          }\n        }));\n\n        // 合并所有采集结果\n        const allNewStreams = results.filter(result => result.status === 'fulfilled').flatMap(result => result.value).filter((stream, index, self) => index === self.findIndex(s => s.url === stream.url));\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams);\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`);\n        } else {\n          this.$message.info('未发现新的直播源');\n        }\n\n        // 统计失败的地址\n        const failedUrls = results.filter(result => result.status === 'rejected').length;\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`);\n        }\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message);\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting();\n        }\n      }\n    },\n    async handleGenerateLink() {\n      try {\n        this.generateLinkDialogVisible = true;\n        const content = this.generateContent();\n        const format = this.linkForm.format;\n        const response = await fetch('http://localhost:8080/api/generate-link', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': format // 添加格式标记\n          },\n          body: content\n        });\n        if (!response.ok) {\n          throw new Error('生成链接失败');\n        }\n        this.generatedLink = await response.text();\n      } catch (error) {\n        this.$message.error('生成链接失败：' + error.message);\n      }\n    },\n    generateContent() {\n      return this.linkForm.format === 'm3u' ? this.generateM3uContent() : this.generateTxtContent();\n    },\n    generateTxtContent() {\n      let content = '';\n      let currentGroup = '';\n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `${currentGroup},#genre#\\n`;\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`;\n      });\n      return content.trim();\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n';\n      let currentGroup = '';\n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group;\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`;\n        }\n        // 对于多个URL，创建多个条目\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`;\n        });\n      });\n      return content.trim();\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea');\n      textarea.value = this.generatedLink;\n      document.body.appendChild(textarea);\n      textarea.select();\n      try {\n        document.execCommand('copy');\n        this.$message.success('链接已复制到剪贴板');\n      } catch (err) {\n        this.$message.error('复制失败');\n      } finally {\n        document.body.removeChild(textarea);\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], {\n        type: 'text/plain;charset=utf-8'\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`;\n      document.body.appendChild(link);\n      link.click();\n\n      // 清理\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(link);\n      this.$message.success('文件下载成功');\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        const content = this.generateContent();\n        await fetch('http://localhost:8080/api/update-content', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        });\n      } catch (error) {\n        console.error('更新链接内容失败：', error);\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      } else {\n        this.scheduleDialogVisible = true;\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false;\n          this.isScheduled = true;\n          this.setupSchedule();\n          this.saveState(); // 保存状态\n          this.$message.success('定时检测已开启');\n        }\n      });\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      this.isScheduled = false;\n      this.nextScheduleTime = null;\n      this.saveState(); // 保存状态\n      this.$message.success('定时检测已停止');\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n      }\n\n      // 计算检查间隔（转换为毫秒）\n      const interval = this.scheduleForm.unit === 'second' ? this.scheduleForm.interval * 1000 : this.scheduleForm.interval * 60 * 1000;\n\n      // 设置下次执行时间\n      this.nextScheduleTime = new Date(Date.now() + interval);\n\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000;\n      this.scheduleTimer = setInterval(() => {\n        const now = new Date();\n\n        // 如果当前正在检测中，跳过这次执行\n        if (this.isChecking) {\n          return;\n        }\n\n        // 检查是否到达执行时间\n        if (now >= this.nextScheduleTime) {\n          this.handleBatchCheck();\n          // 更新下次执行时间\n          this.nextScheduleTime = new Date(Date.now() + interval);\n        }\n      }, checkInterval);\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      // 只保存基础数据和设置，不保存运行状态\n      const state = {\n        streamList: this.streamList,\n        currentPage: this.currentPage,\n        pageSize: this.pageSize,\n        scheduleForm: this.scheduleForm,\n        collectForm: this.collectForm\n      };\n      localStorage.setItem(this.stateKey, JSON.stringify(state));\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey);\n        if (savedState) {\n          const state = JSON.parse(savedState);\n\n          // 只恢复基础数据和设置\n          this.streamList = state.streamList || [];\n          this.currentPage = state.currentPage || 1;\n          this.pageSize = state.pageSize || 5;\n          this.scheduleForm = state.scheduleForm || this.scheduleForm;\n          this.collectForm = state.collectForm || this.collectForm;\n\n          // 重置所有运行状态\n          this.isChecking = false;\n          this.isPaused = false;\n          this.isScheduled = false;\n          this.isCollecting = false;\n          this.checkedCount = 0;\n          this.totalCount = 0;\n          this.pausedIndex = -1;\n          this.nextScheduleTime = null;\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error);\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck();\n      }\n\n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting();\n      }\n\n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true;\n        this.isChecking = false;\n        this.isPaused = false;\n      }\n\n      // 重置所有状态\n      this.isChecking = false;\n      this.isPaused = false;\n      this.isScheduled = false;\n      this.isCollecting = false;\n      this.checkedCount = 0;\n      this.totalCount = 0;\n      this.pausedIndex = -1;\n      this.nextScheduleTime = null;\n\n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer);\n        this.scheduleTimer = null;\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer);\n        this.collectTimer = null;\n      }\n\n      // 保存重置后的状态\n      this.saveState();\n      this.$message.success('所有运行状态已重置');\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled;\n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive;\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload);\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload);\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', ['']);\n      } else {\n        this.collectForm.urls.push('');\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1);\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info';\n      const [width] = resolution.split('x').map(Number);\n      if (width >= 1920) return 'success';\n      if (width >= 1280) return ''; // 默认类型\n      return 'warning';\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info';\n      if (responseTime <= 1000) return 'success';\n      if (responseTime <= 2000) return ''; // 默认类型\n      if (responseTime <= 3000) return 'warning';\n      return 'danger';\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent();\n        this.saveState();\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState();\n    },\n    pageSize() {\n      this.saveState();\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus();\n    },\n    isCollecting() {\n      this.updateActiveStatus();\n    },\n    isScheduled() {\n      this.updateActiveStatus();\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink();\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule();\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true);\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer);\n      this.scheduleTimer = null;\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer);\n      this.collectTimer = null;\n    }\n  }\n};","map":{"version":3,"names":["name","data","loading","streamList","importUrlDialogVisible","importForm","url","group","importRules","required","message","trigger","type","currentPage","pageSize","isChecking","isPaused","checkedCount","totalCount","pausedIndex","shouldStop","isCollecting","collectDialogVisible","collectForm","urls","autoCollect","interval","collectRules","validator","rule","value","callback","length","Error","errors","map","test","filter","error","collectTimer","generateLinkDialogVisible","generatedLink","previewContent","currentLinkId","scheduleDialogVisible","isScheduled","scheduleForm","unit","scheduleRules","scheduleTimer","nextScheduleTime","stateKey","hasActiveOperations","linkForm","format","computed","paginatedData","start","end","slice","checkButtonText","mergedStreams","streamMap","Map","forEach","stream","key","has","existing","get","includes","push","set","Array","from","values","created","localStorage","getItem","savedList","JSON","parse","$root","$on","saveStreamList","restoreState","setupSchedule","startCollecting","beforeDestroy","$off","clearInterval","stopScheduleCheck","saveState","window","removeEventListener","handleBeforeUnload","methods","checkStream","ffprobePath","$message","response","fetch","method","headers","body","stringify","ok","result","json","status","available","resolution","responseTime","shouldRemoveStream","reason","currentPageItems","pageIndex","indexOf","listIndex","splice","warning","console","handleBatchCheck","uncheckedStreams","s","info","concurrentChecks","parseInt","startIndex","i","batch","Promise","all","success","pauseCheck","resumeCheck","batchCheck","handleCheck","row","handleDelete","$confirm","confirmButtonText","cancelButtonText","then","index","maxPage","Math","ceil","max","catch","handleUrlImport","valid","$refs","validate","content","text","newStreams","parseContent","existingUrls","Set","uniqueStreams","readFile","file","resolve","reject","reader","FileReader","onload","e","target","onerror","readAsText","lines","split","streams","currentGroup","currentName","currentGroupTitle","line","trim","startsWith","nameMatch","match","groupMatch","endsWith","replace","urlList","addStreamsToList","handleSizeChange","val","handleCurrentChange","handleFileUpload","event","files","getGroupFromFileName","filename","toLowerCase","handleClearList","handleCopy","textarea","document","createElement","appendChild","select","execCommand","err","removeChild","width","height","Number","setItem","handleCollectMode","stopCollecting","isRestore","isArray","$set","collect","setInterval","totalNew","results","allSettled","existingStream","find","es","allNewStreams","flatMap","self","findIndex","failedUrls","handleGenerateLink","generateContent","generateM3uContent","generateTxtContent","join","copyGeneratedLink","downloadTxtFile","blob","Blob","URL","createObjectURL","link","href","download","Date","toLocaleDateString","click","revokeObjectURL","updateLinkContent","handleScheduleCheck","startScheduleCheck","now","checkInterval","state","savedState","resetAllStates","updateActiveStatus","hasActive","addEventListener","preventDefault","returnValue","addCollectUrl","removeCollectUrl","getResolutionTagType","getResponseTimeTagType","watch","handler","deep","linkForm.format","activated","deactivated"],"sources":["src/components/StreamCheck.vue"],"sourcesContent":["<template>\n  <div class=\"stream-check\">\n    <div class=\"table-operations\">\n      <el-button-group>\n        <el-button \n          type=\"primary\" \n          icon=\"el-icon-upload2\"\n          @click=\"$refs.fileInput.click()\"\n          :disabled=\"isCollecting\">\n          导入本地文件\n        </el-button>\n        <el-button \n          type=\"primary\" \n          icon=\"el-icon-download\"\n          @click=\"importUrlDialogVisible = true\"\n          :disabled=\"isCollecting\">\n          导入网络文件\n        </el-button>\n      </el-button-group>\n      \n      <el-button-group>\n        <el-button \n          type=\"success\" \n          icon=\"el-icon-refresh\"\n          @click=\"handleBatchCheck\"\n          :loading=\"isChecking\">\n          {{ checkButtonText }}\n        </el-button>\n        <el-button \n          v-if=\"isChecking\"\n          type=\"warning\" \n          icon=\"el-icon-video-pause\"\n          @click=\"pauseCheck\">\n          暂停检测\n        </el-button>\n        <el-button \n          v-if=\"isPaused\"\n          type=\"primary\" \n          icon=\"el-icon-video-play\"\n          @click=\"resumeCheck\">\n          继续检测\n        </el-button>\n        <el-button \n          type=\"danger\" \n          icon=\"el-icon-delete\"\n          @click=\"handleClearList\">\n          清空列表\n        </el-button>\n      </el-button-group>\n      \n      <el-button-group>\n        <el-button \n          :type=\"isCollecting ? 'danger' : 'primary'\"\n          icon=\"el-icon-connection\"\n          @click=\"handleCollectMode\">\n          {{ isCollecting ? '停止采集' : '采集模式' }}\n        </el-button>\n      </el-button-group>\n      \n      <el-button-group>\n        <el-button \n          type=\"primary\"\n          icon=\"el-icon-link\"\n          @click=\"handleGenerateLink\">\n          生成链接\n        </el-button>\n      </el-button-group>\n      \n      <el-button-group>\n        <el-button \n          :type=\"isScheduled ? 'danger' : 'primary'\"\n          icon=\"el-icon-timer\"\n          @click=\"handleScheduleCheck\">\n          {{ isScheduled ? '停止定时' : '定时检测' }}\n        </el-button>\n      </el-button-group>\n      \n      <!-- 隐藏的文件输入框 -->\n      <input\n        type=\"file\"\n        ref=\"fileInput\"\n        style=\"display: none\"\n        accept=\".txt,.m3u,.m3u8\"\n        @change=\"handleFileUpload\"\n      >\n    </div>\n\n    <el-table\n      :data=\"paginatedData\"\n      border\n      style=\"width: 100%\">\n      <el-table-column\n        prop=\"name\"\n        label=\"名称\"\n        min-width=\"120\"\n        align=\"center\">\n      </el-table-column>\n      \n      <el-table-column\n        prop=\"url\"\n        label=\"链接\"\n        min-width=\"200\"\n        align=\"center\"\n        show-overflow-tooltip>\n      </el-table-column>\n      \n      <el-table-column\n        prop=\"resolution\"\n        label=\"分辨率\"\n        width=\"120\"\n        align=\"center\">\n        <template slot-scope=\"scope\">\n          <el-tag \n            :type=\"getResolutionTagType(scope.row.resolution)\">\n            {{ scope.row.resolution || '未知' }}\n          </el-tag>\n        </template>\n      </el-table-column>\n      \n      <el-table-column\n        prop=\"responseTime\"\n        label=\"响应速度\"\n        width=\"120\"\n        align=\"center\">\n        <template slot-scope=\"scope\">\n          <el-tag \n            :type=\"getResponseTimeTagType(scope.row.responseTime)\">\n            {{ scope.row.responseTime }}ms\n          </el-tag>\n        </template>\n      </el-table-column>\n      \n      <el-table-column\n        prop=\"group\"\n        label=\"分组\"\n        width=\"120\"\n        align=\"center\">\n        <template slot-scope=\"scope\">\n          <el-tag \n            type=\"info\">\n            {{ scope.row.group }}\n          </el-tag>\n        </template>\n      </el-table-column>\n      \n      <el-table-column\n        prop=\"status\"\n        label=\"状态\"\n        width=\"100\"\n        align=\"center\">\n        <template slot-scope=\"scope\">\n          <el-tag :type=\"scope.row.status === '正常' ? 'success' : 'danger'\">\n            {{ scope.row.status }}\n          </el-tag>\n        </template>\n      </el-table-column>\n      \n      <el-table-column\n        label=\"操作\"\n        width=\"120\"\n        align=\"center\"\n        fixed=\"right\">\n        <template slot-scope=\"scope\">\n          <el-tooltip content=\"复制链接\" placement=\"top\">\n            <el-button\n              type=\"text\"\n              icon=\"el-icon-document-copy\"\n              @click=\"handleCopy(scope.row)\">\n            </el-button>\n          </el-tooltip>\n          <el-tooltip content=\"删除\" placement=\"top\">\n            <el-button\n              type=\"text\"\n              class=\"delete-btn\"\n              icon=\"el-icon-delete\"\n              @click=\"handleDelete(scope.row)\">\n            </el-button>\n          </el-tooltip>\n        </template>\n      </el-table-column>\n    </el-table>\n\n    <!-- 添加分页组件 -->\n    <div class=\"pagination-container\">\n      <el-pagination\n        @size-change=\"handleSizeChange\"\n        @current-change=\"handleCurrentChange\"\n        :current-page=\"currentPage\"\n        :page-sizes=\"[5, 10, 20, 50]\"\n        :page-size=\"pageSize\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        :total=\"streamList.length\">\n      </el-pagination>\n    </div>\n\n    <!-- 添加/编辑对话框 -->\n    <el-dialog\n      title=\"导入网络文件\"\n      :visible.sync=\"importUrlDialogVisible\"\n      width=\"500px\">\n      <el-form :model=\"importForm\" label-width=\"80px\" ref=\"importForm\" :rules=\"importRules\">\n        <el-form-item label=\"URL地址\" prop=\"url\">\n          <el-input \n            v-model=\"importForm.url\" \n            placeholder=\"请输入txt或m3u文件的网络地址\"\n          ></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"importUrlDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"handleUrlImport\">导 入</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 采集模式设置对话框 -->\n    <el-dialog\n      title=\"采集模式设置\"\n      :visible.sync=\"collectDialogVisible\"\n      width=\"500px\">\n      <el-form :model=\"collectForm\" label-width=\"100px\" ref=\"collectForm\" :rules=\"collectRules\">\n        <!-- 采集地址列表 -->\n        <el-form-item \n          v-for=\"(url, index) in collectForm.urls\" \n          :key=\"index\"\n          :label=\"index === 0 ? '采集地址' : ''\"\n          :prop=\"'urls.' + index\">\n          <el-input \n            v-model=\"collectForm.urls[index]\" \n            placeholder=\"请输入需要采集的网络地址\">\n            <template slot=\"append\">\n              <el-button \n                icon=\"el-icon-delete\"\n                @click=\"removeCollectUrl(index)\"\n                v-if=\"collectForm.urls.length > 1\">\n              </el-button>\n            </template>\n          </el-input>\n        </el-form-item>\n        \n        <!-- 添加地址按钮 -->\n        <el-form-item>\n          <el-button \n            type=\"text\" \n            icon=\"el-icon-plus\"\n            @click=\"addCollectUrl\">\n            添加采集地址\n          </el-button>\n        </el-form-item>\n\n        <el-form-item label=\"自动采集\">\n          <el-switch v-model=\"collectForm.autoCollect\"></el-switch>\n        </el-form-item>\n\n        <el-form-item \n          label=\"采集间隔\" \n          prop=\"interval\"\n          v-if=\"collectForm.autoCollect\">\n          <el-input-number \n            v-model=\"collectForm.interval\" \n            :min=\"1\"\n            :max=\"10080\"\n            :step=\"30\">\n          </el-input-number>\n          <span class=\"setting-tip\">分钟 (1分钟 ~ 7天)</span>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"collectDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startCollecting\">开始采集</el-button>\n      </div>\n    </el-dialog>\n\n    <!-- 生成链接对话框 -->\n    <el-dialog\n      title=\"生成链接\"\n      :visible.sync=\"generateLinkDialogVisible\"\n      width=\"500px\"\n      custom-class=\"generate-link-dialog\">\n      <div class=\"link-container\">\n        <!-- 添加格式选择 -->\n        <el-form :model=\"linkForm\" label-width=\"80px\">\n          <el-form-item label=\"文件格式\">\n            <el-radio-group v-model=\"linkForm.format\">\n              <el-radio label=\"txt\">TXT格式</el-radio>\n              <el-radio label=\"m3u\">M3U格式</el-radio>\n            </el-radio-group>\n          </el-form-item>\n        </el-form>\n\n        <!-- 链接展示卡片 -->\n        <el-card class=\"link-card\">\n          <div class=\"link-content\">\n            <el-input\n              v-model=\"generatedLink\"\n              placeholder=\"正在生成链接...\"\n              readonly>\n              <template slot=\"prepend\">链接地址</template>\n              <el-button \n                slot=\"append\" \n                icon=\"el-icon-document-copy\"\n                @click=\"copyGeneratedLink\">\n                复制\n              </el-button>\n            </el-input>\n          </div>\n        </el-card>\n\n        <!-- 使用说明 -->\n        <el-card class=\"tips-card\">\n          <div class=\"tips-content\">\n            <ul>\n              <li>生成的链接可以直接在支持网络导入的播放器中使用</li>\n              <li>链接内容会随列表更新而自动更新</li>\n              <li>TXT格式适用于大多数播放器</li>\n              <li>M3U格式提供更好的播放器兼容性</li>\n            </ul>\n          </div>\n        </el-card>\n      </div>\n    </el-dialog>\n\n    <!-- 添加定时检测设置对话框 -->\n    <el-dialog\n      title=\"定时检测设置\"\n      :visible.sync=\"scheduleDialogVisible\"\n      width=\"500px\">\n      <el-form :model=\"scheduleForm\" label-width=\"100px\" ref=\"scheduleForm\" :rules=\"scheduleRules\">\n        <el-form-item label=\"检测周期\" prop=\"interval\">\n          <el-select v-model=\"scheduleForm.unit\" style=\"width: 100px; margin-right: 10px\">\n            <el-option label=\"秒\" value=\"second\"></el-option>\n            <el-option label=\"分钟\" value=\"minute\"></el-option>\n          </el-select>\n          <el-input-number \n            v-model=\"scheduleForm.interval\"\n            :min=\"scheduleForm.unit === 'second' ? 10 : 1\"\n            :max=\"scheduleForm.unit === 'second' ? 59 : 7980\"\n            :step=\"scheduleForm.unit === 'second' ? 10 : 1\">\n          </el-input-number>\n          <span class=\"setting-tip\">\n            {{ scheduleForm.unit === 'second' ? '(10秒 ~ 59秒)' : '(1分钟 ~ 7天)' }}\n          </span>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\">\n        <el-button @click=\"scheduleDialogVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"startScheduleCheck\">开始定时</el-button>\n      </div>\n    </el-dialog>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'StreamCheck',\n  data() {\n    return {\n      loading: false,\n      streamList: [],\n      importUrlDialogVisible: false,\n      importForm: {\n        url: '',\n        group: ''\n      },\n      importRules: {\n        url: [\n          { required: true, message: '请输入URL地址', trigger: 'blur' },\n          { type: 'url', message: '请输入正确的URL地址', trigger: 'blur' }\n        ],\n        group: [\n          { required: true, message: '请选择分组', trigger: 'change' }\n        ]\n      },\n      currentPage: 1,\n      pageSize: 5,\n      isChecking: false,\n      isPaused: false,\n      checkedCount: 0,\n      totalCount: 0,\n      pausedIndex: -1,\n      shouldStop: false,\n      isCollecting: false,\n      collectDialogVisible: false,\n      collectForm: {\n        urls: [''],\n        autoCollect: false,\n        interval: 60\n      },\n      collectRules: {\n        urls: [\n          { \n            type: 'array',\n            validator: (rule, value, callback) => {\n              if (value.length === 0) {\n                callback(new Error('请至少添加一个采集地址'))\n              }\n              // 验证每个URL\n              const errors = value.map(url => {\n                if (!url) return '采集地址不能为空'\n                if (!/^https?:\\/\\/.+/.test(url)) return '请输入正确的URL地址'\n                return null\n              }).filter(error => error !== null)\n              \n              if (errors.length > 0) {\n                callback(new Error(errors[0]))\n              } else {\n                callback()\n              }\n            },\n            trigger: 'change'\n          }\n        ],\n        interval: [\n          { required: true, message: '请输入采集间隔', trigger: 'blur' },\n          { \n            validator: (rule, value, callback) => {\n              if (value < 1 || value > 10080) {\n                callback(new Error('采集间隔必须在1分钟到7天之间'))\n              } else {\n                callback()\n              }\n            }, \n            trigger: 'change' \n          }\n        ]\n      },\n      collectTimer: null,\n      generateLinkDialogVisible: false,\n      generatedLink: '',\n      previewContent: '',  // 新增预览内容\n      currentLinkId: '',\n      scheduleDialogVisible: false,\n      isScheduled: false,\n      scheduleForm: {\n        interval: 30,\n        unit: 'minute'\n      },\n      scheduleRules: {\n        interval: [\n          { required: true, message: '请设置检测间隔', trigger: 'change' },\n          { \n            validator: (rule, value, callback) => {\n              if (this.scheduleForm.unit === 'second') {\n                if (value < 10 || value > 59) {\n                  callback(new Error('秒数必须在10到59之间'))\n                }\n              } else {\n                if (value < 1 || value > 7980) {\n                  callback(new Error('分钟数必须在1到7980之间'))\n                }\n              }\n              callback()\n            }, \n            trigger: 'change' \n          }\n        ]\n      },\n      scheduleTimer: null,\n      nextScheduleTime: null,\n      stateKey: 'streamCheckState', // 用于本地存储的key\n      hasActiveOperations: false,  // 添加标记表示是否有动作在执行\n      linkForm: {\n        format: 'txt' // 默认txt格式\n      }\n    }\n  },\n  computed: {\n    paginatedData() {\n      const start = (this.currentPage - 1) * this.pageSize\n      const end = start + this.pageSize\n      return this.streamList.slice(start, end)\n    },\n    checkButtonText() {\n      if (!this.isChecking && !this.isPaused) {\n        return '批量检测'\n      }\n      return `检测中 ${this.checkedCount}/${this.totalCount}`\n    },\n    mergedStreams() {\n      // 创建一个Map来存储合并后的直播源\n      const streamMap = new Map()\n      \n      // 按照当前列表顺序处理每个直播源\n      this.streamList.forEach(stream => {\n        const key = stream.name // 使用名称作为键\n        \n        if (streamMap.has(key)) {\n          // 如果已存在相同名称的直播源，添加到URLs数组\n          const existing = streamMap.get(key)\n          if (!existing.urls.includes(stream.url)) {\n            existing.urls.push(stream.url)\n          }\n        } else {\n          // 如果是新的名称，创建新条目\n          streamMap.set(key, {\n            name: stream.name,\n            urls: [stream.url],\n            group: stream.group\n          })\n        }\n      })\n      \n      // 转换回数组格式\n      return Array.from(streamMap.values())\n    }\n  },\n  created() {\n    // 初始化时加载持久化的数据\n    if (localStorage.getItem('persistentData') === 'true') {\n      const savedList = localStorage.getItem('streamList')\n      if (savedList) {\n        this.streamList = JSON.parse(savedList)\n      }\n    }\n\n    // 监听保存事件\n    this.$root.$on('save-stream-list', this.saveStreamList)\n\n    // 从本地存储恢复状态\n    this.restoreState()\n    // 如果定时检测是开启状态，重新启动定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果采集是开启状态，重新启动采集\n    if (this.isCollecting) {\n      this.startCollecting(true) // true表示是恢复状态\n    }\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    this.$root.$off('save-stream-list', this.saveStreamList)\n    // 组件销毁前清除定时器\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n    }\n    // 组件销毁时清理定时器\n    this.stopScheduleCheck()\n    // 在组件销毁前保存状态\n    this.saveState()\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\n  },\n  methods: {\n    async checkStream(stream) {\n      const ffprobePath = localStorage.getItem('ffprobePath')\n      if (!ffprobePath) {\n        this.$message.error('请先在系统设置中配置FFprobe路径')\n        return false\n      }\n\n      try {\n        const response = await fetch('http://localhost:8080/api/check-stream', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            url: stream.url,\n            ffprobePath: ffprobePath\n          })\n        })\n\n        if (!response.ok) throw new Error('请求失败')\n        \n        const result = await response.json()\n        \n        // 更新流信息\n        stream.status = result.available ? '正常' : '异常'\n        stream.resolution = result.resolution || ''\n        stream.responseTime = result.responseTime || 0\n\n        // 检查是否需要自动清除\n        if (this.shouldRemoveStream(stream)) {\n          let reason = ''\n          if (stream.status === '异常') {\n            reason = '异常源'\n          } else if (stream.responseTime > 3000) {\n            reason = '响应时间过慢'\n          } else {\n            reason = '分辨率过低'\n          }\n\n          // 找到当前页的所有项\n          const currentPageItems = this.paginatedData\n          // 找到要删除项在当前页的索引\n          const pageIndex = currentPageItems.indexOf(stream)\n          // 找到要删除项在整个列表中的索引\n          const listIndex = this.streamList.indexOf(stream)\n          \n          if (listIndex > -1) {\n            this.streamList.splice(listIndex, 1)\n            // 如果删除的是当前页的最后一项，且不是第一页，则跳转到上一页\n            if (pageIndex === currentPageItems.length - 1 && this.currentPage > 1) {\n              this.currentPage--\n            }\n            // 添加删除原因提示\n            this.$message.warning(`已自动清除直播源：${reason}`)\n          }\n        }\n        \n        this.saveStreamList()\n        return result.available\n      } catch (error) {\n        console.error('检测错误:', error)\n        stream.status = '异常'\n        return false\n      }\n    },\n\n    async handleBatchCheck() {\n      if (this.isChecking) return\n      \n      const uncheckedStreams = this.streamList.filter(s => !this.isPaused || this.streamList.indexOf(s) > this.pausedIndex)\n      if (uncheckedStreams.length === 0) {\n        this.$message.info('没有需要检测的直播源')\n        return\n      }\n\n      this.isChecking = true\n      this.shouldStop = false\n      this.totalCount = uncheckedStreams.length\n      this.checkedCount = this.isPaused ? this.checkedCount : 0\n      \n      // 获取并发检测数量设置\n      const concurrentChecks = parseInt(localStorage.getItem('concurrentChecks')) || 3\n      \n      try {\n        // 从暂停的位置或开始位置继续检测\n        const startIndex = this.isPaused ? this.pausedIndex + 1 : 0\n        \n        // 使用并发检测\n        for (let i = startIndex; i < uncheckedStreams.length; i += concurrentChecks) {\n          if (this.shouldStop) break\n          \n          // 获取当前批次要检测的流\n          const batch = uncheckedStreams.slice(i, i + concurrentChecks)\n          \n          // 并发检测当前批次的所有流\n          await Promise.all(\n            batch.map(async stream => {\n              if (this.shouldStop) return\n              \n              stream.status = '检测中'\n              const success = await this.checkStream(stream)\n              this.checkedCount++\n              \n              if (success) {\n                this.saveState()\n              }\n            })\n          )\n          \n          // 更新暂停位置\n          this.pausedIndex = i + concurrentChecks - 1\n        }\n\n        if (!this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = false\n          this.pausedIndex = -1\n          this.$message.success('批量检测完成')\n        }\n      } catch (error) {\n        console.error('批量检测错误:', error)\n        this.$message.error('批量检测失败')\n      } finally {\n        if (this.shouldStop) {\n          this.isChecking = false\n          this.isPaused = true\n          this.$message.info('检测已暂停')\n        }\n      }\n    },\n\n    pauseCheck() {\n      this.shouldStop = true\n    },\n\n    async resumeCheck() {\n      if (this.pausedIndex >= 0) {\n        this.isChecking = true\n        this.isPaused = false\n        this.shouldStop = false\n        await this.batchCheck(this.pausedIndex)\n      }\n    },\n\n    async handleCheck(row) {\n      row.status = '检测中'\n      \n      const success = await this.checkStream(row)\n      this.$message[success ? 'success' : 'error'](`检测${success ? '成功' : '失败'}: ${row.name}`)\n    },\n    handleDelete(row) {\n      this.$confirm('确认删除该直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        const index = this.streamList.indexOf(row)\n        this.streamList.splice(index, 1)\n        const maxPage = Math.ceil(this.streamList.length / this.pageSize)\n        if (this.currentPage > maxPage) {\n          this.currentPage = Math.max(maxPage, 1)\n        }\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('删除成功')\n      }).catch(() => {})\n    },\n    async handleUrlImport() {\n      const valid = await this.$refs.importForm.validate()\n      if (!valid) return\n\n      try {\n        // 先发送请求到后端，让后端去获取文件内容\n        const response = await fetch('http://localhost:8080/api/import-url', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({ url: this.importForm.url })\n        })\n\n        if (!response.ok) throw new Error('导入失败')\n\n        const content = await response.text()\n        const newStreams = this.parseContent(content)\n\n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n            this.importUrlDialogVisible = false\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('导入失败：' + error.message)\n      }\n    },\n    readFile(file) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader()\n        reader.onload = (e) => resolve(e.target.result)\n        reader.onerror = () => reject(new Error('文件读取失败'))\n        reader.readAsText(file)\n      })\n    },\n    parseContent(content) {\n      const lines = content.split('\\n')\n      const streams = []\n      let currentGroup = '未分组'\n\n      // 检测是否是 m3u 格式\n      if (content.includes('#EXTM3U')) {\n        let currentName = ''\n        let currentGroupTitle = ''\n\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          if (line.startsWith('#EXTINF:')) {\n            // 提取频道名称\n            const nameMatch = line.match(/,(.+)$/)\n            currentName = nameMatch ? nameMatch[1].trim() : ''\n            \n            // 检查是否有分组信息\n            const groupMatch = line.match(/group-title=\"([^\"]+)\"/)\n            if (groupMatch) {\n              currentGroupTitle = groupMatch[1].trim()\n            }\n          } else if (!line.startsWith('#') && line.trim()) {\n            // 这是一个媒体URL\n            if (currentName) {\n              streams.push({\n                name: currentName,\n                url: line.trim(),\n                group: currentGroupTitle || currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n            currentName = ''\n          }\n        })\n      } else {\n        // txt 格式处理\n        lines.forEach(line => {\n          line = line.trim()\n          if (!line) return\n\n          // 检查是否是分组标记\n          if (line.endsWith(',#genre#')) {\n            currentGroup = line.replace(',#genre#', '')\n            return\n          }\n\n          // 解析直播源行\n          const [name, urls] = line.split(',')\n          if (!name || !urls) return\n\n          // 检查是否包含多个URL（用#分隔）\n          const urlList = urls.split('#')\n          \n          // 为每个URL创建一个新的直播源条目\n          urlList.forEach(url => {\n            if (url && url.trim()) {\n              streams.push({\n                name: name,\n                url: url.trim(),\n                group: currentGroup,\n                status: '未检测',\n                resolution: '',\n                responseTime: 0\n              })\n            }\n          })\n        })\n      }\n\n      return streams\n    },\n    addStreamsToList(streams) {\n      streams.forEach(stream => {\n        this.streamList.push(stream)\n      })\n      this.currentPage = 1\n      this.saveStreamList()  // 保存更新后的列表\n    },\n    handleSizeChange(val) {\n      this.pageSize = val\n      // 当每页条数改变时，重置当前页为第一页\n      this.currentPage = 1\n    },\n    handleCurrentChange(val) {\n      this.currentPage = val\n    },\n    async handleFileUpload(event) {\n      const file = event.target.files[0]\n      if (!file) return\n\n      try {\n        const content = await this.readFile(file)\n        const newStreams = this.parseContent(content)\n        \n        if (newStreams.length > 0) {\n          // 过滤重复的直播源\n          const existingUrls = new Set(this.streamList.map(s => s.url))\n          const uniqueStreams = newStreams.filter(s => !existingUrls.has(s.url))\n          \n          if (uniqueStreams.length > 0) {\n            this.streamList.push(...uniqueStreams)\n            this.$message.success(`成功导入 ${uniqueStreams.length} 个直播源`)\n          } else {\n            this.$message.info('没有新的直播源可以导入')\n          }\n        } else {\n          this.$message.warning('未找到有效的直播源')\n        }\n      } catch (error) {\n        this.$message.error('文件读取失败：' + error.message)\n      } finally {\n        // 清除文件输入，允许重复选择同一文件\n        event.target.value = ''\n      }\n    },\n    getGroupFromFileName(filename) {\n      // 从文件名中提取可能的分组名\n      const name = filename.toLowerCase()\n      if (name.includes('cctv')) return 'CCTV'\n      if (name.includes('卫视')) return '卫视'\n      if (name.includes('地方')) return '地方台'\n      return '未分组'\n    },\n    handleClearList() {\n      if (this.streamList.length === 0) {\n        this.$message.warning('列表已经为空')\n        return\n      }\n\n      this.$confirm('确认清空所有直播源?', '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        this.streamList = []\n        this.currentPage = 1\n        this.saveStreamList()  // 保存更新后的列表\n        this.$message.success('列表已清空')\n      }).catch(() => {})\n    },\n    handleCopy(row) {\n      // 创建一个临时输入框来实现复制功能\n      const textarea = document.createElement('textarea')\n      textarea.value = row.url\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    shouldRemoveStream(stream) {\n      // 检查是否需要清除异常源\n      if (localStorage.getItem('autoRemoveInvalid') === 'true' && \n          stream.status === '异常') {\n        return true\n      }\n\n      // 检查是否需要清除低分辨率源\n      if (localStorage.getItem('autoRemoveLowRes') === 'true' && \n          stream.resolution !== '未知') {\n        const [width, height] = stream.resolution.split('x').map(Number)\n        if (width < 1280 || height < 720) {\n          return true\n        }\n      }\n\n      // 添加新的检查：响应时间\n      if (localStorage.getItem('autoRemoveSlowResponse') === 'true' && \n          stream.responseTime > 3000) {\n        return true\n      }\n\n      return false\n    },\n    saveStreamList() {\n      if (localStorage.getItem('persistentData') === 'true') {\n        localStorage.setItem('streamList', JSON.stringify(this.streamList))\n      }\n    },\n    handleCollectMode() {\n      if (this.isCollecting) {\n        this.stopCollecting()\n      } else {\n        this.collectDialogVisible = true\n      }\n    },\n    async startCollecting(isRestore = false) {\n      if (!isRestore) {\n        // 确保 urls 是数组\n        if (!Array.isArray(this.collectForm.urls)) {\n          this.$set(this.collectForm, 'urls', [''])\n          return\n        }\n        \n        const valid = await this.$refs.collectForm.validate()\n        if (!valid) return\n      }\n\n      this.collectDialogVisible = false\n      this.isCollecting = true\n      this.saveState() // 保存状态\n      \n      // 立即执行一次采集\n      if (!isRestore) {\n        await this.collect()\n      }\n      \n      // 如果开启了自动采集，设置定时器\n      if (this.collectForm.autoCollect) {\n        this.collectTimer = setInterval(async () => {\n          await this.collect()\n        }, this.collectForm.interval * 60 * 1000)\n      }\n    },\n    stopCollecting() {\n      this.isCollecting = false\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      this.saveState() // 保存状态\n      this.$message.success('已停止采集')\n    },\n    async collect() {\n      try {\n        this.$message.info('开始采集直播源...')\n        let totalNew = 0\n\n        // 并发采集所有地址\n        const results = await Promise.allSettled(\n          this.collectForm.urls.map(async url => {\n            try {\n              // 修改为通过后端获取内容\n              const response = await fetch('http://localhost:8080/api/collect-url', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ url })\n              })\n\n              if (!response.ok) throw new Error(`采集失败: ${url}`)\n              \n              const content = await response.text()\n              const newStreams = this.parseContent(content)\n              \n              // 过滤重复的直播源\n              const existingUrls = new Set(this.streamList.map(s => s.url))\n              return newStreams.filter(s => {\n                // 如果源已存在且正在检测中，保留原有状态\n                const existingStream = this.streamList.find(es => es.url === s.url)\n                if (existingStream && existingStream.status === '检测中') {\n                  return false\n                }\n                return !existingUrls.has(s.url)\n              })\n            } catch (error) {\n              console.error(`采集地址 ${url} 失败:`, error)\n              return []\n            }\n          })\n        )\n\n        // 合并所有采集结果\n        const allNewStreams = results\n          .filter(result => result.status === 'fulfilled')\n          .flatMap(result => result.value)\n          .filter((stream, index, self) => \n            index === self.findIndex(s => s.url === stream.url)\n          )\n\n        // 添加新的直播源到列表\n        if (allNewStreams.length > 0) {\n          this.addStreamsToList(allNewStreams)\n          this.$message.success(`采集成功: 新增${allNewStreams.length}个直播源`)\n        } else {\n          this.$message.info('未发现新的直播源')\n        }\n\n        // 统计失败的地址\n        const failedUrls = results\n          .filter(result => result.status === 'rejected')\n          .length\n\n        if (failedUrls > 0) {\n          this.$message.warning(`${failedUrls}个地址采集失败`)\n        }\n\n      } catch (error) {\n        this.$message.error('采集失败：' + error.message)\n        if (!this.collectForm.autoCollect) {\n          this.stopCollecting()\n        }\n      }\n    },\n    async handleGenerateLink() {\n      try {\n        this.generateLinkDialogVisible = true\n        \n        const content = this.generateContent()\n        const format = this.linkForm.format\n        \n        const response = await fetch('http://localhost:8080/api/generate-link', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain',\n            'X-File-Format': format // 添加格式标记\n          },\n          body: content\n        })\n\n        if (!response.ok) {\n          throw new Error('生成链接失败')\n        }\n\n        this.generatedLink = await response.text()\n      } catch (error) {\n        this.$message.error('生成链接失败：' + error.message)\n      }\n    },\n    generateContent() {\n      return this.linkForm.format === 'm3u' \n        ? this.generateM3uContent() \n        : this.generateTxtContent()\n    },\n    generateTxtContent() {\n      let content = ''\n      let currentGroup = ''\n      \n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `${currentGroup},#genre#\\n`\n        }\n        content += `${stream.name},${stream.urls.join('#')}\\n`\n      })\n      \n      return content.trim()\n    },\n    generateM3uContent() {\n      let content = '#EXTM3U\\n'\n      let currentGroup = ''\n      \n      this.mergedStreams.forEach(stream => {\n        if (stream.group !== currentGroup) {\n          currentGroup = stream.group\n          content += `\\n#EXTINF:-1 group-title=\"${currentGroup}\"\\n`\n        }\n        // 对于多个URL，创建多个条目\n        stream.urls.forEach(url => {\n          content += `#EXTINF:-1,${stream.name}\\n${url}\\n`\n        })\n      })\n      \n      return content.trim()\n    },\n    copyGeneratedLink() {\n      const textarea = document.createElement('textarea')\n      textarea.value = this.generatedLink\n      document.body.appendChild(textarea)\n      textarea.select()\n      \n      try {\n        document.execCommand('copy')\n        this.$message.success('链接已复制到剪贴板')\n      } catch (err) {\n        this.$message.error('复制失败')\n      } finally {\n        document.body.removeChild(textarea)\n      }\n    },\n    downloadTxtFile() {\n      const blob = new Blob([this.generatedLink], { type: 'text/plain;charset=utf-8' })\n      const url = window.URL.createObjectURL(blob)\n      const link = document.createElement('a')\n      link.href = url\n      link.download = `直播源列表_${new Date().toLocaleDateString()}.txt`\n      \n      document.body.appendChild(link)\n      link.click()\n      \n      // 清理\n      window.URL.revokeObjectURL(url)\n      document.body.removeChild(link)\n      this.$message.success('文件下载成功')\n    },\n    // 修改更新链接内容的方法\n    async updateLinkContent() {\n      try {\n        const content = this.generateContent()\n        await fetch('http://localhost:8080/api/update-content', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'text/plain'\n          },\n          body: content\n        })\n      } catch (error) {\n        console.error('更新链接内容失败：', error)\n      }\n    },\n    handleScheduleCheck() {\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      } else {\n        this.scheduleDialogVisible = true\n      }\n    },\n    startScheduleCheck() {\n      this.$refs.scheduleForm.validate(valid => {\n        if (valid) {\n          this.scheduleDialogVisible = false\n          this.isScheduled = true\n          this.setupSchedule()\n          this.saveState() // 保存状态\n          this.$message.success('定时检测已开启')\n        }\n      })\n    },\n    stopScheduleCheck() {\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      this.isScheduled = false\n      this.nextScheduleTime = null\n      this.saveState() // 保存状态\n      this.$message.success('定时检测已停止')\n    },\n    setupSchedule() {\n      // 清除现有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n      }\n\n      // 计算检查间隔（转换为毫秒）\n      const interval = this.scheduleForm.unit === 'second' \n        ? this.scheduleForm.interval * 1000 \n        : this.scheduleForm.interval * 60 * 1000\n      \n      // 设置下次执行时间\n      this.nextScheduleTime = new Date(Date.now() + interval)\n\n      // 设置检查频率（秒级检测使用1秒检查，分钟级使用1分钟检查）\n      const checkInterval = this.scheduleForm.unit === 'second' ? 1000 : 60000\n\n      this.scheduleTimer = setInterval(() => {\n        const now = new Date()\n        \n        // 如果当前正在检测中，跳过这次执行\n        if (this.isChecking) {\n          return\n        }\n\n        // 检查是否到达执行时间\n        if (now >= this.nextScheduleTime) {\n          this.handleBatchCheck()\n          // 更新下次执行时间\n          this.nextScheduleTime = new Date(Date.now() + interval)\n        }\n      }, checkInterval)\n    },\n    // 保存当前状态到本地存储\n    saveState() {\n      // 只保存基础数据和设置，不保存运行状态\n      const state = {\n        streamList: this.streamList,\n        currentPage: this.currentPage,\n        pageSize: this.pageSize,\n        scheduleForm: this.scheduleForm,\n        collectForm: this.collectForm\n      }\n      localStorage.setItem(this.stateKey, JSON.stringify(state))\n    },\n    // 从本地存储恢复状态\n    restoreState() {\n      try {\n        const savedState = localStorage.getItem(this.stateKey)\n        if (savedState) {\n          const state = JSON.parse(savedState)\n          \n          // 只恢复基础数据和设置\n          this.streamList = state.streamList || []\n          this.currentPage = state.currentPage || 1\n          this.pageSize = state.pageSize || 5\n          this.scheduleForm = state.scheduleForm || this.scheduleForm\n          this.collectForm = state.collectForm || this.collectForm\n\n          // 重置所有运行状态\n          this.isChecking = false\n          this.isPaused = false\n          this.isScheduled = false\n          this.isCollecting = false\n          this.checkedCount = 0\n          this.totalCount = 0\n          this.pausedIndex = -1\n          this.nextScheduleTime = null\n        }\n      } catch (error) {\n        console.error('恢复状态失败：', error)\n      }\n    },\n    // 添加重置所有运行状态的方法\n    resetAllStates() {\n      // 停止定时检测\n      if (this.isScheduled) {\n        this.stopScheduleCheck()\n      }\n      \n      // 停止采集\n      if (this.isCollecting) {\n        this.stopCollecting()\n      }\n      \n      // 停止批量检测\n      if (this.isChecking) {\n        this.shouldStop = true\n        this.isChecking = false\n        this.isPaused = false\n      }\n      \n      // 重置所有状态\n      this.isChecking = false\n      this.isPaused = false\n      this.isScheduled = false\n      this.isCollecting = false\n      this.checkedCount = 0\n      this.totalCount = 0\n      this.pausedIndex = -1\n      this.nextScheduleTime = null\n      \n      // 清除所有定时器\n      if (this.scheduleTimer) {\n        clearInterval(this.scheduleTimer)\n        this.scheduleTimer = null\n      }\n      if (this.collectTimer) {\n        clearInterval(this.collectTimer)\n        this.collectTimer = null\n      }\n      \n      // 保存重置后的状态\n      this.saveState()\n      \n      this.$message.success('所有运行状态已重置')\n    },\n    // 更新活动状态\n    updateActiveStatus() {\n      const hasActive = this.isChecking || this.isCollecting || this.isScheduled\n      \n      if (this.hasActiveOperations !== hasActive) {\n        this.hasActiveOperations = hasActive\n        if (hasActive) {\n          // 添加刷新拦截\n          window.addEventListener('beforeunload', this.handleBeforeUnload)\n        } else {\n          // 移除刷新拦截\n          window.removeEventListener('beforeunload', this.handleBeforeUnload)\n        }\n      }\n    },\n    // 处理页面刷新\n    handleBeforeUnload(e) {\n      if (this.hasActiveOperations) {\n        const message = '有正在执行的操作，确定要离开吗？'\n        e.preventDefault()\n        e.returnValue = message\n        return message\n      }\n    },\n    addCollectUrl() {\n      if (!Array.isArray(this.collectForm.urls)) {\n        // 如果 urls 不是数组，先初始化它\n        this.$set(this.collectForm, 'urls', [''])\n      } else {\n        this.collectForm.urls.push('')\n      }\n    },\n    removeCollectUrl(index) {\n      if (Array.isArray(this.collectForm.urls) && this.collectForm.urls.length > 1) {\n        this.collectForm.urls.splice(index, 1)\n      }\n    },\n    // 添加判断分辨率标签类型的方法\n    getResolutionTagType(resolution) {\n      if (!resolution || resolution === '未知') return 'info'\n      const [width] = resolution.split('x').map(Number)\n      if (width >= 1920) return 'success'\n      if (width >= 1280) return ''  // 默认类型\n      return 'warning'\n    },\n    // 添加判断响应时间标签类型的方法\n    getResponseTimeTagType(responseTime) {\n      if (!responseTime) return 'info'\n      if (responseTime <= 1000) return 'success'\n      if (responseTime <= 2000) return ''  // 默认类型\n      if (responseTime <= 3000) return 'warning'\n      return 'danger'\n    }\n  },\n  watch: {\n    // 只监听数据变化\n    streamList: {\n      handler() {\n        this.updateLinkContent()\n        this.saveState()\n      },\n      deep: true\n    },\n    currentPage() {\n      this.saveState()\n    },\n    pageSize() {\n      this.saveState()\n    },\n    // 监听所有可能的运行状态\n    isChecking() {\n      this.updateActiveStatus()\n    },\n    isCollecting() {\n      this.updateActiveStatus()\n    },\n    isScheduled() {\n      this.updateActiveStatus()\n    },\n    // 添加格式变化监听\n    'linkForm.format'() {\n      if (this.generateLinkDialogVisible) {\n        this.handleGenerateLink()\n      }\n    }\n  },\n  // 组件被激活时（重新显示）\n  activated() {\n    // 如果有定时任务，恢复定时器\n    if (this.isScheduled) {\n      this.setupSchedule()\n    }\n    // 如果有采集任务，恢复采集\n    if (this.isCollecting) {\n      this.startCollecting(true)\n    }\n  },\n  // 组件被停用时（离开但不销毁）\n  deactivated() {\n    // 暂停定时器，但保持状态标志\n    if (this.scheduleTimer) {\n      clearInterval(this.scheduleTimer)\n      this.scheduleTimer = null\n    }\n    // 暂停采集定时器，但保持状态标志\n    if (this.collectTimer) {\n      clearInterval(this.collectTimer)\n      this.collectTimer = null\n    }\n  }\n}\n</script>\n\n<style scoped>\n.stream-check {\n  padding: 0px;\n  background-color: #fff;\n  border-radius: 4px;\n}\n\n.table-operations {\n  margin-bottom: 20px;\n  display: flex;\n  gap: 10px; /* 按钮组之间的间距 */\n}\n\n.pagination-container {\n  margin-top: 20px;\n  display: flex;\n  justify-content: center;\n}\n\n.el-button [class*=\"el-icon-\"] {\n  font-size: 18px;\n}\n\n.delete-btn {\n  color: #F56C6C;\n}\n\n.delete-btn:hover {\n  color: #ff4d4d;\n}\n\n.setting-tip {\n  margin-left: 10px;\n  color: #909399;\n  font-size: 13px;\n}\n\n.link-info {\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.link-info p {\n  margin: 0;\n  color: #606266;\n}\n\n.link-actions {\n  display: flex;\n  gap: 10px;\n  justify-content: flex-end;\n  margin-top: 10px;\n}\n\n/* 生成链接对话框样式 */\n.generate-link-dialog {\n  max-width: 600px;\n}\n\n.link-container {\n  display: flex;\n  flex-direction: column;\n  gap: 15px;\n}\n\n.link-card, .tips-card {\n  margin: 0;\n  border: 1px solid #EBEEF5;\n}\n\n.link-content {\n  padding: 10px;\n}\n\n.tips-content {\n  color: #606266;\n  font-size: 14px;\n  padding: 10px;\n}\n\n.tips-content ul {\n  margin: 0;\n  padding-left: 20px;\n  line-height: 1.8;\n}\n\n/* 覆盖 element-ui 的一些默认样式 */\n:deep(.el-dialog__body) {\n  padding: 20px;\n}\n\n:deep(.el-card__header) {\n  padding: 12px 20px;\n  font-weight: 500;\n}\n\n:deep(.el-card__body) {\n  padding: 15px;\n}\n\n/* 可以添加一些自定义样式 */\n.el-tag {\n  width: 90px;  /* 统一标签宽度 */\n}\n\n.el-tag + .el-tag {\n  margin-left: 4px;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}